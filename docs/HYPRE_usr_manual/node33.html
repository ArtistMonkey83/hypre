<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML 96.1-g (June 11, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>7.5 Euclid</TITLE>
<META NAME="description" CONTENT="7.5 Euclid">
<META NAME="keywords" CONTENT="usr_manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="usr_manual.css">
</HEAD>
<BODY LANG="EN" >
 <A NAME="tex2html504" HREF="node34.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="http://cbl.leeds.ac.uk/nikos/figs/next_motif.gif"></A> <A NAME="tex2html502" HREF="node26.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="http://cbl.leeds.ac.uk/nikos/figs/up_motif.gif"></A> <A NAME="tex2html496" HREF="node32.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="http://cbl.leeds.ac.uk/nikos/figs/previous_motif.gif"></A> <A NAME="tex2html506" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="http://cbl.leeds.ac.uk/nikos/figs/contents_motif.gif"></A> <A NAME="tex2html507" HREF="node40.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="http://cbl.leeds.ac.uk/nikos/figs/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME="tex2html505" HREF="node34.html">7.6 PILUT: Parallel Incomplete </A>
<B>Up:</B> <A NAME="tex2html503" HREF="node26.html">7 Solvers and Preconditioners</A>
<B> Previous:</B> <A NAME="tex2html497" HREF="node32.html">7.4 ParaSails</A>
<BR> <P>
<H1><A NAME="SECTION00870000000000000000">7.5 Euclid</A></H1>
<P>
The Euclid library is a scalable implementation of the 
Parallel ILU algorithm that was presented at SC99&nbsp;[&make_named_href('',
	"node39.html#hysom:sc99","[7]")],
and published in expanded form in the 
SIAM Journal on Scientific Computing&nbsp;[&make_named_href('',
	"node39.html#hysomSIAM","[8]")].
By <EM>scalable</EM> we mean that the factorization (setup)
and application (triangular solve) timings remain nearly constant
when the global problem size is scaled in proportion to the number of 
processors.
As with all ILU preconditioning methods, the number of iterations
is expected to increase with global problem size.
<P>
Experimental results have shown that PILU preconditioning is in general
more effective than Block Jacobi preconditioning 
for minimizing total solution time.
For scaled problems, the relative advantage appears to increase 
as the number of processors is scaled upwards.
Euclid may also be used to good advantage as a smoother within 
multigrid methods.
<P>
<H2><A NAME="SECTION00871000000000000000">Synopsis</A></H2>
<P>
Euclid is best thought of as an ``extensible ILU preconditioning
framework.''
<EM>Extensible</EM> means that Euclid can (and eventually will, time and
contributing agencies permitting) support many variants of ILU(<I>k</I>)
and ILUT preconditioning.
(The current release includes Block Jacobi ILU(<I>k</I>) and
Parallel ILU(<I>k</I>) methods.)
Due to this extensibility, and also because Euclid was developed 
independently of the HYPRE project, the methods by which one
passes runtime parameters to Euclid preconditioners
differ in some respects from the HYPRE norm.
While users can directly set options within their code,
options can also be passed to Euclid preconditioners via
command line switches and/or small text-based configuration files.
The latter strategies have the advantage that users will not need to
alter their codes as Euclid's capabilities are extended.
<P>
The following fragment illustrates the minimum coding required to invoke Euclid preconditioning within HYPRE application contexts.
The next subsection provides examples of the various ways in which
Euclid's options can be set. 
The final subsection lists the options,
and provides guidance as to the settings that (in our experience) 
will likely prove effective for minimizing execution time.
<P>
<blockquote><PRE>#include &quot;HYPRE_parcsr_ls.h&quot;

HYPRE_Solver eu;
HYPRE_Solver pcg_solver;
HYPRE_ParVector b, x;
HYPRE_ParCSRMatrix A;

//Instantiate the preconditioner.
HYPRE_EuclidCreate(comm, &amp;eu);

//Optionally use the following three calls to set runtime options.
// 1. pass options from command line or string array.
HYPRE_EuclidSetParams(eu, argc, argv);

// 2. pass individual options from within your  code.
HYPRE_EuclidSetParam(eu, &quot;-level&quot;, &quot;3&quot;);

// 3. pass options from a configuration file.
HYPRE_EuclidSetParamsFromFile(eu, &quot;filename&quot;);

//Set Euclid as the preconditioning method for some
//other solver, using the function calls HYPRE_EuclidSetup
//and HYPRE_EuclidSolve.  We assume that the pcg_solver
//has been properly initialized.
HYPRE_PCGSetPrecond(pcg_solver,
                    (HYPRE_PtrToSolverFcn) HYPRE_EuclidSolve,
                    (HYPRE_PtrToSolverFcn) HYPRE_EuclidSetup,
                    eu);

//Solve the system by calling the Setup and Solve methods for, 
//in this case, the HYPRE_PCG solver.  We assume that A, b, and x
//have been properly initialized.
HYPRE_PCGSetup(pcg_solver, (HYPRE_Matrix)A, (HYPRE_Vector)b, (HYPRE_Vector)x);
HYPRE_PCGSolve(pcg_solver, (HYPRE_Matrix)parcsr_A, (HYPRE_Vector)b, (HYPRE_Vector)x);

//Destroy the Euclid preconditioning object.
HYPRE_EuclidDestroy(eu);</PRE>
</blockquote><H2><A NAME="SECTION00872000000000000000">7.5.2 Setting options: examples</A></H2>
<P>
For expositional purposes, assume you wish to set the ILU(<I>k</I>)
factorization level to the value <I>k</I> = 3.
There are several methods of accomplishing this.
Internal to Euclid, options are stored in a simple database that
contains (name, value) pairs.
Various of Euclid's internal (private) functions query this
database to determine, at runtime, what action the user
has requested.
If you enter the option ``<B>-eu_stats 1''</B>, a report will
be printed when Euclid's destructor is called; this
report lists (among other statistics) the options that
were in effect during the factorization phase.
<P>
<B>Method 1.</B>
By default, Euclid always looks for a file titled
``database'' in the working directory. 
If it finds such a file, it opens it and attempts to parse it as
a configuration file.
Configuration files should be formatted as follows.
<P>
<TT>&gt;cat database</TT> <BR> 
<TT>#this is an optional comment</TT> <BR> 
<TT>-level 3</TT>
Any line in a configuration file that contains a ``<TT>#</TT>''
character in the first column is ignored.
All other lines should begin with an option <EM>name</EM>, followed by
one or more blanks, followed by the option <EM>value</EM>.
Note that option names always begin with a ``-'' character.
If you include an option name that is not recognized by Euclid,
no harm should ensue.
<P>
<B>Method 2.</B>
To pass options on the command line, call
<blockquote><PRE>HYPRE_EuclidSetParams(HYPRE_Solver solver, int argc, char *argv[]);</PRE>
</blockquote>
where <TT>argc</TT> and <TT>argv</TT> carry the usual connotation:
<TT>main(int argc, char *argv[])</TT>.
If your HYPRE application is called <TT>phoo</TT>, you can
then pass options on the command line per the following example.
<P>
<blockquote><PRE>mpirun -np 2 phoo -level 3</PRE>
</blockquote>
<P>
Since Euclid looks for the ``database'' file when 
<TT>HYPRE_EuclidCreate</TT> is called, and parses the command line 
when <TT>HYPRE_EuclidSetParams</TT> is called,
option values passed on the command line will override 
any similar settings that may be contained in the ``database'' file.
Also, if same option name appears more than once on the command 
line, the final appearance determines the setting.
<P>
Some options, such as ``<TT>-bj</TT>'' (see next subsection) are boolean.
Euclid always treats these options as the value ``1'' (true)
or ``0'' (false).  
When passing boolean options from the command line
the value may be committed, in which case it assumed to be ``1.''
Note, however, that when boolean options are contained in a
configuration file, either the ``1'' or ``0'' must
stated explicitly.
<P>
<B>Method 3.</B>
Individual options can be hardcoded via calls such as the following.
<P>
<blockquote><PRE>HYPRE_EuclidSetParams(solver, &quot;-level&quot;, &quot;3&quot;);</PRE>
</blockquote>
<P>
<B>Method 4.</B>
There are two ways in which you can read in options from a file
whose name is other than ``database.''
First, you can call <TT>HYPRE_EuclidSetParamsFromFile</TT>
to specify a configuration filename.
Second, if you have passed the command line arguments as 
described above in Method 2, 
you can then specify the configuration filename on the command
line using the <B>-db_filename filename</B> option, e.g.,
<P>
<blockquote><PRE>mpirun -np 2 phoo -db_filename ../myConfigFile</PRE>
</blockquote><H2><A NAME="SECTION00873000000000000000">7.5.3 Options summary</A></H2>
<P>
<DL ><DT><STRONG>-level  <IMG WIDTH=35 HEIGHT=29 ALIGN=MIDDLE  SRC="img40.gif"  > </STRONG>
<DD> Factorization level for ILU(<I>k</I>).  
           Default: 1.
           Guidance: for 2D convection-diffusion and similar problems, 
           fastest solution time is typically obtained with levels 4 through
           8.  For 3D problems fastest solution time is typically 
           obtained with level 1.
<P>
<DT><STRONG>-bj</STRONG>
<DD> Use Block Jacobi ILU preconditioning instead of PILU.
           Default: 0 (false). Guidance: if subdomains contain
           relatively few nodes (less than 1,000), or the problem is
           not well partitioned, Block Jacobi ILU 
           may give faster solution time than PILU.
<DT><STRONG>-eu_stats</STRONG>
<DD> When Euclid's destructor is called a summary of
                 runtime settings and timing information is printed
                 to stdout.  Default: 0 (false).
                 The timing marks in the report are the maximum over 
                 all processors in the MPI communicator.
<DT><STRONG>-eu_mem</STRONG>
<DD> When Euclid's destructor is called a summary of
               Euclid's memory usage is printed to stdout.
               Default: 0 (false).
               The statistics are for the processor whose rank 
               in MPI_COMM_WORLD is 0.
<DT><STRONG>-printTestData</STRONG>
<DD> This option is used in our autotest procedures,
                 and should not normally be invoked by users.
<P>
 </DL>
<P>
The following options are partially implemented, but not
yet fully functional (i.e, don't use them until further notice).
<P>
<DL ><DT><STRONG>-sparseA  <IMG WIDTH=53 HEIGHT=29 ALIGN=MIDDLE  SRC="img41.gif"  > </STRONG>
<DD> Drop-tolerance for ILU(<I>k</I>) factorization.
                        Default: 0 (no dropping).
                        Entries are treated as zero if their absolute
                        value is less than (sparseA * max), where ``max''
                        is the largest absolute value of any entry in the
                        row. Guidance: try this in conjunction with 
                        -rowScale.  CAUTION: If the coefficient matrix <I>A</I> is 
                        symmetric, this
                        setting is likely to cause the filled matrix,
                        <I>F</I> = <I>L</I>+<I>U</I>-<I>I</I>, to be unsymmetric.
                        This setting has no effect when ILUT factorization
                        is selected.
<DT><STRONG>-rowScale</STRONG>
<DD> Scale values prior to factorization such that the
                 largest value in any row is +1 or -1.
                 Default: 0 (false).
                 CAUTION: If the coefficient matrix <I>A</I> is symmetric, this 
                 setting is likely to cause the filled matrix,
                 <I>F</I> = <I>L</I>+<I>U</I>-<I>I</I>, to be unsymmetric.
                 Guidance: if the matrix is poorly scaled, turning on
                 row scaling may help convergence.
<DT><STRONG>-ilut  <IMG WIDTH=53 HEIGHT=29 ALIGN=MIDDLE  SRC="img41.gif"  > </STRONG>
<DD> Use ILUT factorization instead
                 of the default, ILU(<I>k</I>).  Here,  <IMG WIDTH=53 HEIGHT=29 ALIGN=MIDDLE  SRC="img41.gif"  > 
                 is the drop tolerance, which is relative to the largest 
                 absolute value of any entry in the row being factored.
                 CAUTION: If the coefficient matrix <I>A</I> is symmetric, this 
                 setting is likely to cause the filled matrix,
                 <I>F</I> = <I>L</I>+<I>U</I>-<I>I</I>, to be unsymmetric.
<DT><STRONG>-maxNzPerRow   <IMG WIDTH=35 HEIGHT=29 ALIGN=MIDDLE  SRC="img40.gif"  > </STRONG>
<DD> This sets the maximum number
                 of nonzeros that is permitted in any row of <I>F</I>, in
                 addition to the number that would result from an ILU(0)
                 factorization.  A negative value indicates infinity (no limit).
                 This setting is effective for both ILU(<I>k</I>)
                 and ILUT factorization methods.
                 Default: infinity, for ILU(<I>k</I>); 5, for ILUT.
<P>
 </DL><HR><A NAME="tex2html504" HREF="node34.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="http://cbl.leeds.ac.uk/nikos/figs/next_motif.gif"></A> <A NAME="tex2html502" HREF="node26.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="http://cbl.leeds.ac.uk/nikos/figs/up_motif.gif"></A> <A NAME="tex2html496" HREF="node32.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="http://cbl.leeds.ac.uk/nikos/figs/previous_motif.gif"></A> <A NAME="tex2html506" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="http://cbl.leeds.ac.uk/nikos/figs/contents_motif.gif"></A> <A NAME="tex2html507" HREF="node40.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="http://cbl.leeds.ac.uk/nikos/figs/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME="tex2html505" HREF="node34.html">7.6 PILUT: Parallel Incomplete </A>
<B>Up:</B> <A NAME="tex2html503" HREF="node26.html">7 Solvers and Preconditioners</A>
<B> Previous:</B> <A NAME="tex2html497" HREF="node32.html">7.4 ParaSails</A>
<P><ADDRESS>
<I>Thomas Treadway <BR>
Fri Jul 27 10:01:25 PDT 2001</I>
</ADDRESS>
</BODY>
</HTML>
