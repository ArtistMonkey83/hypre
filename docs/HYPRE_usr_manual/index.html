<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with jLaTeX2HTML 2002 (1.62) JA patch-1.4
patched version by:  Kenshi Muto, Debian Project.
LaTeX2HTML 2002 (1.62),
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>User's Manual</TITLE>
<META NAME="description" CONTENT="User's Manual">
<META NAME="keywords" CONTENT="usr_manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="jLaTeX2HTML v2002 JA patch-1.4">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="usr_manual.css">

</HEAD>

<BODY >
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="file:/usr/share/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev_g.png">   
<BR>
<BR><BR>
<!--End of Navigation Panel-->

<P>
<DIV ALIGN="LEFT">

<P>
<H1>User's Manual</H1>
<HR SIZE=4 ALIGN="CENTER" NOSHADE>
<H3 ALIGN="RIGHT">Software Version: 1.9.0b</H3>

<H3 ALIGN="RIGHT">Date: 2005/02/09 09:25:00</H3>

<DIV ALIGN="CENTER">
<img src="hypre_wiw.gif">

</DIV>

<H3>Center for Applied Scientific Computing
<BR>Lawrence Livermore National Laboratory
</H3>
<HR SIZE=2 ALIGN="CENTER" NOSHADE>

<P>
</DIV>

<P>


<P>
Copyright &#169; 1998 The Regents of the University of California.

<P>
<BR>
<BR>
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

<P>
<BR>
<BR>
This work was produced at the University of California, Lawrence
Livermore National Laboratory (UC LLNL) under contract
no. W-7405-ENG-48 (Contract 48) between the U.S. Department of Energy
(DOE) and The Regents of the University of California (University) for
the operation of UC LLNL. The rights of the Federal Government are
reserved under Contract 48 subject to the restrictions agreed upon by
the DOE and University as allowed under DOE Acquisition Letter 97-1.

<P>
<BR>
<BR>
This work was prepared as an account of work sponsored by an agency of
the United States Government. Neither the United States Government nor
the University of California nor any of their employees, makes any
warranty, express or implied, or assumes any liability or
responsibility for the accuracy, completeness, or usefulness of any
information, apparatus, product, or process disclosed, or represents
that its use would not infringe privately-owned rights.  Reference
herein to any specific commercial products, process, or service by
trade name, trademark, manufacturer or otherwise does not necessarily
constitute or imply its endorsement, recommendation, or favoring by
the United States Government or the University of California. The
views and opinions of authors expressed herein do not necessarily
state or reflect those of the United States Government or the
University of California, and shall not be used for advertising or
product endorsement purposes.

<P>
<BR>
<BR>
UCRL-MA-137155 DR

<P>

<BR>

<H2><A NAME="SECTION00100000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html80"
  HREF="usr_manual.html">1. Introduction and Mailing List Information</A>
<UL>
<LI><A NAME="tex2html81"
  HREF="usr_manual.html#SECTION00210000000000000000">1.1 Features</A>
<LI><A NAME="tex2html82"
  HREF="usr_manual.html#SECTION00220000000000000000">1.2 Assumptions and Limitations</A>
</UL><BR>
<LI><A NAME="tex2html83"
  HREF="usr_manual.html#SECTION00300000000000000000">2. Getting Started</A>
<UL>
<LI><A NAME="tex2html84"
  HREF="usr_manual.html#SECTION00310000000000000000">2.1 A Simple Example</A>
<LI><A NAME="tex2html85"
  HREF="usr_manual.html#SECTION00320000000000000000">2.2 What are conceptual interfaces?</A>
<LI><A NAME="tex2html86"
  HREF="usr_manual.html#SECTION00330000000000000000">2.3 Which conceptual interface should I use?</A>
</UL><BR>
<LI><A NAME="tex2html87"
  HREF="usr_manual.html#SECTION00400000000000000000">3. Structured-Grid System Interface (Struct)</A>
<UL>
<LI><A NAME="tex2html88"
  HREF="usr_manual.html#SECTION00410000000000000000">3.1 Setting Up the Struct Grid</A>
<LI><A NAME="tex2html89"
  HREF="usr_manual.html#SECTION00420000000000000000">3.2 Setting Up the Struct Stencil</A>
<LI><A NAME="tex2html90"
  HREF="usr_manual.html#SECTION00430000000000000000">3.3 Setting Up the Struct Matrix</A>
<LI><A NAME="tex2html91"
  HREF="usr_manual.html#SECTION00440000000000000000">3.4 Setting Up the Struct Right-Hand-Side Vector</A>
<LI><A NAME="tex2html92"
  HREF="usr_manual.html#SECTION00450000000000000000">3.5 Symmetric Matrices</A>
</UL><BR>
<LI><A NAME="tex2html93"
  HREF="usr_manual.html#SECTION00500000000000000000">4. Semi-Structured-Grid System Interface (SStruct)</A>
<UL>
<LI><A NAME="tex2html94"
  HREF="usr_manual.html#SECTION00510000000000000000">4.1 Setting Up the SStruct Grid</A>
<LI><A NAME="tex2html95"
  HREF="usr_manual.html#SECTION00520000000000000000">4.2 Setting Up the SStruct Stencil</A>
<LI><A NAME="tex2html96"
  HREF="usr_manual.html#SECTION00530000000000000000">4.3 Setting Up the SStruct Graph</A>
<LI><A NAME="tex2html97"
  HREF="usr_manual.html#SECTION00540000000000000000">4.4 Setting Up the SStruct Matrix</A>
<LI><A NAME="tex2html98"
  HREF="usr_manual.html#SECTION00550000000000000000">4.5 Setting Up the SStruct Right-Hand-Side Vector</A>
</UL><BR>
<LI><A NAME="tex2html99"
  HREF="usr_manual.html#SECTION00600000000000000000">5. Finite Element Interface (FEI)</A>
<UL>
<LI><A NAME="tex2html100"
  HREF="usr_manual.html#SECTION00610000000000000000">5.1 Iterative methods and preconditioners available</A>
<UL>
<LI><A NAME="tex2html101"
  HREF="usr_manual.html#SECTION00611000000000000000">5.1.1 Iterative methods</A>
<LI><A NAME="tex2html102"
  HREF="usr_manual.html#SECTION00612000000000000000">5.1.2 Preconditioners</A>
</UL>
</UL><BR>
<LI><A NAME="tex2html103"
  HREF="usr_manual.html#SECTION00700000000000000000">6. Linear-Algebraic System Interface (IJ)</A>
<UL>
<LI><A NAME="tex2html104"
  HREF="usr_manual.html#SECTION00710000000000000000">6.1 IJ Matrix Interface</A>
<LI><A NAME="tex2html105"
  HREF="usr_manual.html#SECTION00720000000000000000">6.2 IJ Vector Interface</A>
</UL><BR>
<LI><A NAME="tex2html106"
  HREF="usr_manual.html#SECTION00800000000000000000">7. Solvers and Preconditioners</A>
<UL>
<LI><A NAME="tex2html107"
  HREF="usr_manual.html#SECTION00810000000000000000">Setup:</A>
<LI><A NAME="tex2html108"
  HREF="usr_manual.html#SECTION00820000000000000000">Use:</A>
<LI><A NAME="tex2html109"
  HREF="usr_manual.html#SECTION00830000000000000000">7.1 SMG</A>
<LI><A NAME="tex2html110"
  HREF="usr_manual.html#SECTION00840000000000000000">7.2 PFMG</A>
<LI><A NAME="tex2html111"
  HREF="usr_manual.html#SECTION00850000000000000000">7.3 BoomerAMG</A>
<UL>
<LI><A NAME="tex2html112"
  HREF="usr_manual.html#SECTION00851000000000000000">7.3.1 Synopsis</A>
<LI><A NAME="tex2html113"
  HREF="usr_manual.html#SECTION00852000000000000000">7.3.2 Interface functions</A>
</UL>
<LI><A NAME="tex2html114"
  HREF="usr_manual.html#SECTION00860000000000000000">7.4 ParaSails</A>
<UL>
<LI><A NAME="tex2html115"
  HREF="usr_manual.html#SECTION00861000000000000000">7.4.1 Synopsis</A>
<LI><A NAME="tex2html116"
  HREF="usr_manual.html#SECTION00862000000000000000">7.4.2 Interface functions</A>
<LI><A NAME="tex2html117"
  HREF="usr_manual.html#SECTION00863000000000000000">7.4.3 Preconditioning nearly symmetric matrices</A>
</UL>
<LI><A NAME="tex2html118"
  HREF="usr_manual.html#SECTION00870000000000000000">7.5 Euclid</A>
<UL>
<LI><A NAME="tex2html119"
  HREF="usr_manual.html#SECTION00871000000000000000">7.5.1 Synopsis</A>
<LI><A NAME="tex2html120"
  HREF="usr_manual.html#SECTION00872000000000000000">7.5.2 Setting options: examples</A>
<LI><A NAME="tex2html121"
  HREF="usr_manual.html#SECTION00873000000000000000">7.5.3 Options summary</A>
</UL>
<LI><A NAME="tex2html122"
  HREF="usr_manual.html#SECTION00880000000000000000">7.6 PILUT: Parallel Incomplete Factorization</A>
<UL>
<LI><A NAME="tex2html123"
  HREF="usr_manual.html#SECTION00881000000000000000">Parameters:</A>
</UL>
</UL><BR>
<LI><A NAME="tex2html124"
  HREF="usr_manual.html#SECTION00900000000000000000">8. Additional Information</A>
<UL>
<LI><A NAME="tex2html125"
  HREF="usr_manual.html#SECTION00910000000000000000">8.1 Building the Library</A>
<UL>
<LI><A NAME="tex2html126"
  HREF="usr_manual.html#SECTION00911000000000000000">8.1.1 Getting the Library</A>
<LI><A NAME="tex2html127"
  HREF="usr_manual.html#SECTION00912000000000000000">8.1.2 Library configuration</A>
<LI><A NAME="tex2html128"
  HREF="usr_manual.html#SECTION00913000000000000000">8.1.3 Testing the Library</A>
<LI><A NAME="tex2html129"
  HREF="usr_manual.html#SECTION00914000000000000000">8.1.4 Linking to the Library</A>
<LI><A NAME="tex2html130"
  HREF="usr_manual.html#SECTION00915000000000000000">8.1.5 Configure Options</A>
<LI><A NAME="tex2html131"
  HREF="usr_manual.html#SECTION00916000000000000000">8.1.6 Make Targets</A>
<LI><A NAME="tex2html132"
  HREF="usr_manual.html#SECTION00917000000000000000">8.1.7 Hints</A>
</UL>
<LI><A NAME="tex2html133"
  HREF="usr_manual.html#SECTION00920000000000000000">8.2 Calling from Fortran</A>
<LI><A NAME="tex2html134"
  HREF="usr_manual.html#SECTION00930000000000000000">8.3 Bug Reporting</A>
</UL><BR>
<LI><A NAME="tex2html135"
  HREF="usr_manual.html#SECTION001000000000000000000">Bibliography</A>
<LI><A NAME="tex2html136"
  HREF="usr_manual.html#SECTION001100000000000000000">Index</A>
<LI><A NAME="tex2html137"
  HREF="usr_manual.html#SECTION001200000000000000000">About this document ...</A>
</UL>
<!--End of Table of Contents-->

<P>

<P>

<H1><A NAME="SECTION00200000000000000000"></A>
<A NAME="Introduction_and_Mailing_List_Information"></A><BR>
1. Introduction and Mailing List Information
</H1>

<P>
HYPRE is a software library for solving large, sparse linear
systems of equations on massively parallel computers.  The library was
created with the primary goal of providing users with advanced
parallel preconditioners.  Issues of robustness, ease of use,
flexibility, and interoperability also play an important role.

<P>
There are three HYPRE Mailing Lists that can be subscribed to through the HYPRE
web page, which is located at http://www.llnl.gov/CASC/hypre.  

<P>

<UL>
<LI><B>hypre-announce</B> (hypre-announce@lists.llnl.gov)
<BR>The development team uses this list to announce new general releases
 of HYPRE.  It cannot be posted to by users.
<BR> 

<P>
</LI>
<LI><B>hypre-beta-announce</B> (hypre-beta-announce@lists.llnl.gov)
<BR>The development team uses this list to announce new beta releases
 of HYPRE.  It cannot be posted to by users.
<BR> 

<P>
</LI>
<LI><B>hypre-users</B> (hypre-users@lists.llnl.gov)
<BR>This list is for HYPRE users to communicate with the development 
team and each other.  It can be posted to by any member of the list.

<P>
</LI>
</UL>

<P>

<H1><A NAME="SECTION00210000000000000000"></A>
<A NAME="Features"></A><BR>
1.1 Features
</H1>

<P>

<UL>
<LI><B>Scalable preconditioners provide efficient solution on today's
and tomorrow's systems:</B> HYPRE contains several families of
preconditioner algorithms focused on the scalable solution of very
large sparse linear systems. HYPRE includes ``grey-box'' algorithms
that use more than just the matrix to solve certain classes of
problems more efficiently than general-purpose libraries. This
includes algorithms such as structured multigrid.

<P>
</LI>
<LI><B>Suite of common iterative methods provides options for a spectrum
of problems:</B> HYPRE provides several of the most commonly used
Krylov-based iterative methods to be used in conjunction with its
scalable preconditioners. This includes methods for nonsymmetric
systems such as GMRES and methods for symmetric matrices such as
Conjugate Gradient.

<P>
</LI>
<LI><B>Intuitive grid-centric interfaces obviate need for complicated
data structures and provide access to advanced solvers:</B> HYPRE has
made a major step forward in usability from earlier generations of
sparse linear solver libraries in that users do not have to learn
complicated sparse matrix data structures.  Instead, HYPRE does the
work of building these data structures for the user through a variety
of interfaces, each appropriate to different classes of users.  These
include stencil-based structured/semi-structured interfaces most
appropriate for finite-difference applications; a finite-element based
unstructured interface; and a linear-algebra based interface.  Each
interface provides access to several solvers without the need to write
new interface code.

<P>
</LI>
<LI><B>User options accommodate beginners through experts:</B> HYPRE
allows a spectrum of expertise to be applied by users. The beginning
user can get up and running with a minimal amount of effort. More
expert users can take further control of the solution process through
various parameters.

<P>
</LI>
<LI><B>Configuration options to suit your computing system:</B> HYPRE
utilizes the GNU Autoconf package to allow simple and flexible
installation on a wide variety of computing systems.  Users can tailor
the installation to match their computing system. Options include
debug and optimized modes, the ability to change required libraries
such as MPI and BLAS, a sequential mode, and modes enabling threads
for certain solvers.  On most systems, however, HYPRE can be built
by simply typing <kbd>configure</kbd> followed by <kbd>make</kbd>.

<P>
</LI>
<LI><B>Interfaces in multiple languages provide greater flexibility for
applications:</B> HYPRE contains interfaces for both Fortran and C
users.

<P>
</LI>
</UL>

<P>

<H1><A NAME="SECTION00220000000000000000">
1.2 Assumptions and Limitations</A>
</H1>

<P>

<UL>
<LI><B>HYPRE is designed for large, sparse, linear systems on
parallel computers.</B>  Small linear systems, systems that are solvable
on a sequential computer, and dense systems are all better addressed
by other libraries that are designed specifically for them.

<P>
</LI>
<LI><B>To run in parallel, HYPRE requires an installation of MPI.</B>

<P>
</LI>
<LI><B>Configuration of HYPRE with threads requires an implementation
of OpenMP.</B>  Currently, only a subset of HYPRE is threaded.

<P>
</LI>
<LI><B>HYPRE currently does not support complex-valued systems.</B>

<P>
</LI>
</UL>

<P>

<H1><A NAME="SECTION00300000000000000000"></A>
<A NAME="Getting_Started"></A><BR>
2. Getting Started
</H1>

<P>
Before writing any code:

<P>

<OL>
<LI><B>Choose a conceptual interface (see Sections
<A HREF="usr_manual.html#What_are_conceptual_interfaces">2.2</A> and
<A HREF="usr_manual.html#Which_conceptual_interface_should_I_use">2.3</A>).</B>
Generally, the choice is fairly obvious.  A structured-grid interface
is clearly inappropriate for an unstructured-grid application.  It is
desirable to use a more specific interface if appropriate, e.g., the
linear-algebraic interface is usable from any type of grid but will
involve much more user work and prevent access to some
grid-type-specific preconditioners.

<P>
</LI>
<LI><B>Choose your desired solver strategy.</B>  For the typical user, this
will mean a single Krylov method and a single preconditioner.

<P>
</LI>
<LI><B>Look up matrix requirements for each solver and preconditioner.</B>
Each specific solver and preconditioner has requirements from the
input matrix.  This information is provided in several places: Chapter
<A HREF="usr_manual.html#Solvers_and_Preconditioners">7</A>, the HYPRE Reference Manual, and
the HYPRE header files.

<P>
</LI>
<LI><B>Choose a matrix class that is compatible with your solvers and
preconditioners and your conceptual interface.</B>  Note that some of the
interfaces currently only support one matrix class choice.

<P>
</LI>
</OL>
Once the previous decisions have been made, it is time to code your
application to call HYPRE:

<OL>
<LI><B>Build any necessary auxiliary structures for your chosen
conceptual interface.</B> This includes, e.g., the grid and stencil
structures for the structured-grid interface.

<P>
</LI>
<LI><B>Build the matrix, solution vector, and right-hand-side vector
through your chosen conceptual interface.</B>  Each conceptual interface
provides a series of calls for entering information about your problem
into HYPRE.

<P>
</LI>
<LI><B>Build solvers and preconditioners and set solver parameters
(optional).</B>  Some parameters like convergence tolerance are the same
across solvers, while others are solver specific.

<P>
</LI>
<LI><B>Call the solve function for the solver.</B>

<P>
</LI>
<LI><B>Retrieve desired information from solver.</B> Depending on your
application, there may be different things you may want to do with the
solution vector.  Also, performance information such as number of
iterations is typically available, though it may differ from solver to
solver.

<P>
</LI>
</OL>

<P>

<H1><A NAME="SECTION00310000000000000000"></A>
<A NAME="A_Simple_Example"></A><BR>
2.1 A Simple Example
</H1>

<P>
The following code serves as a simple example of the usage of
HYPRE.  In this example, the structured-grid interface
(discussed in Chapter&nbsp;<A HREF="usr_manual.html#Structured-Grid_System_Interface">3</A>) is used
to enter the problem into HYPRE, and the <code>PFMG</code> Multigrid
solver is used to solve the system.  Since the structured-grid
interface currently only supports one underlying matrix class, there
are no choices to make here.  If we were using the semi-structured
grid interface instead, then we would have to choose between the
<code>SStruct</code> and <code>ParCSR</code> matrix classes, depending on the
solver we want to use.

<P>
This example and all other examples in this manual are written in C,
but HYPRE also supports Fortran.  See Section
<A HREF="usr_manual.html#Calling_from_Fortran">8.2</A> for details.

<P>
<blockquote>
<PRE>
/*-----------------------------------------------------------
 * Set up the grid and stencil
 *-----------------------------------------------------------*/

HYPRE_StructGridCreate(MPI_COMM_WORLD, dim, &amp;grid);
HYPRE_StructGridSetExtents(grid, ilower, iupper);
...
HYPRE_StructGridAssemble(grid);
	
HYPRE_StructStencilCreate(dim, stencil_size, &amp;stencil);
HYPRE_StructStencilSetElement(stencil, 0, offset0);
...

/*-----------------------------------------------------------
 * Set up the matrix, right-hand side, and initial guess
 *-----------------------------------------------------------*/

HYPRE_StructMatrixCreate(MPI_COMM_WORLD, grid, stencil, &amp;A);
HYPRE_StructMatrixInitialize(A);
HYPRE_StructMatrixSetBoxValues(A, ilower, iupper, nelts, elts, Avalues);
...
HYPRE_StructMatrixAssemble(A);

HYPRE_StructVectorCreate(MPI_COMM_WORLD, grid, &amp;b);
HYPRE_StructVectorInitialize(b);
HYPRE_StructVectorSetBoxValues(b, ilower, iupper, bvalues);
...
HYPRE_StructVectorAssemble(b);

HYPRE_StructVectorCreate(MPI_COMM_WORLD, grid, &amp;x);
HYPRE_StructVectorInitialize(x);
HYPRE_StructVectorSetBoxValues(x, ilower, iupper, xvalues);
...
HYPRE_StructVectorAssemble(x);

/*-----------------------------------------------------------
 * Set up the solver
 *-----------------------------------------------------------*/

HYPRE_StructPFMGCreate(MPI_COMM_WORLD, &amp;solver);
HYPRE_StructPFMGSetMaxIter(solver, 50);     	 /* optional */
HYPRE_StructPFMGSetTol(solver, 1.0e-06);    	 /* optional */
HYPRE_StructPFMGSetup(solver, A, b, x);

/*-----------------------------------------------------------
 * Solve the linear system
 *-----------------------------------------------------------*/

HYPRE_StructPFMGSolve(solver, A, b, x);

/*-----------------------------------------------------------
 * Get solution info and free up memory
 *-----------------------------------------------------------*/

HYPRE_StructVectorGetBoxValues(x, ilower, iupper, xvalues);
...

HYPRE_StructPFMGDestroy(solver);
HYPRE_StructGridDestroy(grid);
HYPRE_StructStencilDestroy(stencil);
HYPRE_StructMatrixDestroy(A);
HYPRE_StructVectorDestroy(b);
HYPRE_StructVectorDestroy(x);
</PRE>
</blockquote>

<P>

<H1><A NAME="SECTION00320000000000000000"></A>
<A NAME="What_are_conceptual_interfaces"></A><BR>
2.2 What are conceptual interfaces?
</H1>

<P>

<DIV ALIGN="CENTER"><A NAME="fig-conceptual-interface"></A><A NAME="279"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
Graphic illustrating the notion of conceptual interfaces.
All of these elements are not necessarily in HYPRE.</CAPTION>
<TR><TD><DIV ALIGN="CENTER"><IMG
 WIDTH="572" HEIGHT="316" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="\includegraphics[width=5in]{concep_iface.eps}">
</DIV></TD></TR>
</TABLE>
</DIV>

<P>
The top row of Figure <A HREF="usr_manual.html#fig-conceptual-interface">2.1</A> illustrates a
number of conceptual interfaces.  Generally, the conceptual interfaces
are denoted by different types of computational grids, but other
application features might also be used, such as geometrical
information.  These conceptual interfaces are intended to represent
the way that applications developers naturally think of their linear
problem, and provide natural interfaces for them to pass the data that
defines their linear system into HYPRE.  Essentially, these
conceptual interfaces can be considered convenient utilities for
helping a user build a matrix data structure for HYPRE solvers and
preconditioners.  For example, applications that use structured grids
(such as in the left-most interface in the Figure
<A HREF="usr_manual.html#fig-conceptual-interface">2.1</A>) typically view their linear problems
in terms of stencils and grids.  On the other hand, applications that
use unstructured grids and finite elements typically view their linear
problems in terms of elements and element stiffness matrices.
Finally, the right-most interface is the standard linear-algebraic
(matrix rows/columns) way of viewing the linear problem.

<P>
The second row of Figure <A HREF="usr_manual.html#fig-conceptual-interface">2.1</A> is a set of
linear solver algorithms.  Each linear solver group requires different
information from the user through the conceptual interfaces.  So, the
geometric multigrid algorithm (GMG) listed in the left-most box, for
example, can only be used with the left-most conceptual interface.  On
the other hand, the ILU algorithm in the right-most box may be used
with any conceptual interface.

<P>
The third row of Figure <A HREF="usr_manual.html#fig-conceptual-interface">2.1</A> is a list of
data layouts or matrix/vector storage schemes.  The relationship
between linear solver and storage scheme is similar to that of
interface and linear solver.

<P>

<H1><A NAME="SECTION00330000000000000000"></A>
<A NAME="Which_conceptual_interface_should_I_use"></A><BR>
2.3 Which conceptual interface should I use?
</H1>

<P>
HYPRE currently supports four conceptual interfaces:

<P>

<UL>
<LI><B>Structured-Grid System Interface (<code>Struct</code>):</B> This interface
is appropriate for applications whose grids consist of unions of
logically rectangular grids with a fixed stencil pattern of nonzeros
at each grid point.  This interface supports only a single unknown per
grid point.
See Chapter <A HREF="usr_manual.html#Structured-Grid_System_Interface">3</A> for details.

<P>
</LI>
<LI><B>Semi-Structured-Grid System Interface (<code>SStruct</code>):</B> This
interface is appropriate for applications whose grids are mostly
structured, but with some unstructured features.  Examples include
block-structured grids, composite grids in structured adaptive mesh
refinement (AMR) applications, and overset grids.  This interface
supports multiple unknowns per cell.
See Chapter <A HREF="usr_manual.html#Semi-Structured-Grid_System_Interface">4</A> for details.

<P>
</LI>
<LI><B>Finite Element Interface (<code>FEI</code>):</B> This is appropriate for
users who form their linear systems from a finite element
discretization.  The interface mirrors typical finite element data
structures, including element stiffness matrices.  Though this
interface is provided in HYPRE, its definition was determined
elsewhere (www.z.ca.sandia.gov/fei).
See Chapter <A HREF="usr_manual.html#Finite_Element_Interface">5</A> for details.

<P>
</LI>
<LI><B>Linear-Algebraic System Interface (<code>IJ</code>):</B> This is the
traditional linear-algebraic interface.  It can be used as a last
resort by users for whom the other grid-based interfaces are not
appropriate.  It requires more work on the user's part, though still
less than building parallel sparse data structures.  General solvers
and preconditioners are available through this interface, but not
specialized solvers which need more information.  Our experience is
that users with legacy codes, in which they already have code for
building matrices in particular formats, find the IJ interface
relatively easy to use.
See Chapter <A HREF="usr_manual.html#Linear-Algebraic_System_Interface">6</A> for details.

<P>
</LI>
</UL>

<P>
Generally, a user should choose the most specific interface that
matches their application, because this will allow them to use
specialized and more efficient solvers and preconditioners without
losing access to more general solvers.

<P>

<H1><A NAME="SECTION00400000000000000000"></A>
<A NAME="Structured-Grid_System_Interface"></A><BR>
3. Structured-Grid System Interface (Struct)
</H1>

<P>
In order to get access to the most efficient and scalable solvers for
scalar structured-grid applications, users should use the
<code>Struct</code> interface described in this chapter.  This interface
will also provide access (this is not yet supported) to solvers in
HYPRE that were designed for unstructured-grid applications and
sparse linear systems in general.  These additional solvers are
usually provided via the unstructured-grid interface (<code>FEI</code>) or
the linear-algebraic interface (<code>IJ</code>) described in Chapters
<A HREF="usr_manual.html#Finite_Element_Interface">5</A> and <A HREF="usr_manual.html#Linear-Algebraic_System_Interface">6</A>.

<P>
Figure <A HREF="usr_manual.html#fig-fv-grid">3.1</A> gives an example of the type of grid
currently supported by the <code>Struct</code> interface.  The interface
uses a finite-difference or finite-volume style, and currently
supports only scalar PDEs (i.e., one unknown per gridpoint).

<DIV ALIGN="CENTER"><A NAME="fig-fv-grid"></A><A NAME="392"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 3.1:</STRONG>
An example 2D structured grid, distributed accross two processors.</CAPTION>
<TR><TD><DIV ALIGN="CENTER"><IMG
 WIDTH="459" HEIGHT="207" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="\includegraphics[width=4in]{fv_grid.eps}">
</DIV></TD></TR>
</TABLE>
</DIV>

There are four basic steps involved in setting up the linear system
to be solved:

<OL>
<LI>set up the grid,
</LI>
<LI>set up the stencil,
</LI>
<LI>set up the matrix,
</LI>
<LI>set up the right-hand-side vector.
</LI>
</OL>
To describe each of these steps in more detail, consider solving the
2D Laplacian problem
<BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
\left \{
\begin{array}{ll}
\nabla^2 u = f , & \mbox{in the domain}, \\
u = 0,           & \mbox{on the boundary}.
\end{array}
\right .
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="eqn-laplacian"></A><IMG
 WIDTH="235" HEIGHT="54" BORDER="0"
 SRC="img3.png"
 ALT="\begin{displaymath}
\left \{
\begin{array}{ll}
\nabla^2 u = f , &amp; \mbox{in the domain}, \\
u = 0, &amp; \mbox{on the boundary}.
\end{array}\right .
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(3.1)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
Assume (<A HREF="usr_manual.html#eqn-laplacian">3.1</A>) is discretized using standard 5-pt
finite-volumes on the uniform grid pictured in <A HREF="usr_manual.html#fig-fv-grid">3.1</A>, and
assume that the problem data is distributed across two processes as
depicted.

<P>

<H1><A NAME="SECTION00410000000000000000"></A>
<A NAME="Setting_Up_the_Struct_Grid"></A><BR>
3.1 Setting Up the Struct Grid
</H1>

<P>
The grid is described via a global <EM>index space</EM>, i.e., via
integer tuples (triples in 3D).  The integers may have any value,
negative or positive.  The global indexes allow HYPRE to discern
how data is related spatially, and how it is distributed across the
parallel machine.  Each process describes that portion of the grid
that it ``owns'', one <EM>box</EM> at a time.  For example, in the
figure, the global grid can be described in terms of three boxes, two
owned by process 0, and one owned by process 1.  A box is described in
terms of a lower and upper index.

<P>
On process 0, the following code will set up the grid shown in the
figure (the code for process 1 is similar).
<blockquote>
<PRE>
HYPRE_StructGrid  grid;
int               ilower[2][2] = {{-3, 1}, {0, 1}};
int               iupper[2][2] = {{-1, 2}, {2, 4}};

HYPRE_StructGridCreate(MPI_COMM_WORLD, 2, &amp;grid);

HYPRE_StructGridSetExtents(grid, ilower[0], iupper[0]);
HYPRE_StructGridSetExtents(grid, ilower[1], iupper[1]);

HYPRE_StructGridAssemble(grid);
</PRE>
</blockquote>
The <code>Create()</code> routine creates an empty 2D grid object that lives
on the <code>MPI_COMM_WORLD</code> communicator.  The <code>SetExtents()</code>
routine adds a new box to the grid.  The <code>Assemble()</code> routine is
a collective call (i.e., must be called on all processes from a common
synchronization point), and finalizes the grid assembly, making the
grid ``ready to use''.

<P>

<H1><A NAME="SECTION00420000000000000000"></A>
<A NAME="Setting_Up_the_Struct_Stencil"></A><BR>
3.2 Setting Up the Struct Stencil
</H1>

<P>
The geometry of the discretization stencil is described by an array of
integer tuples in 2D (triples in 3D), each representing a relative
offset (in index space) from some gridpoint on the grid.  For example,
the geometry of the 5-pt stencil for the example problem being
considered can be represented in the following way:
<BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
\left [
\begin{array}{ccc}
        & ( 0, 1) &         \\
(-1, 0) & ( 0, 0) & ( 1, 0) \\
        & ( 0,-1) &        
\end{array}
\right ]
\equiv
\left [
\begin{array}{ccc}
    & S_4 &     \\
S_1 & S_0 & S_2 \\
    & S_3 &    
\end{array}
\right ] .
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="eqn-stencil-description"></A><IMG
 WIDTH="361" HEIGHT="73" BORDER="0"
 SRC="img4.png"
 ALT="\begin{displaymath}
\left [
\begin{array}{ccc}
&amp; ( 0, 1) &amp; \\
(-1, 0) &amp; ( 0, 0...
... S_4 &amp; \\
S_1 &amp; S_0 &amp; S_2 \\
&amp; S_3 &amp;
\end{array}\right ] .
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(3.2)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
In (<A HREF="usr_manual.html#eqn-stencil-description">3.2</A>), the <IMG
 WIDTH="43" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img5.png"
 ALT="$(0,0)$"> entry represents the
``center'' coefficient, and is the 0th entry in the array (<IMG
 WIDTH="23" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$S_0$">).
The <IMG
 WIDTH="57" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img7.png"
 ALT="$(0,-1)$"> entry represents the ``south'' coefficient, and is the
3rd entry in the array (<IMG
 WIDTH="23" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$S_3$">).  And so on.

<P>
On process 0 or 1, the following code will set up the stencil in
(<A HREF="usr_manual.html#eqn-stencil-description">3.2</A>).  The stencil must be the same on all
processes.
<blockquote>
<PRE>
HYPRE_StructStencil  stencil;
int                  offsets[5][2] = {{0,0}, {-1,0}, {1,0}, {0,-1}, {0,1}};
int                  s;

HYPRE_StructStencilCreate(2, 5, &amp;stencil);

for (s = 0; s &lt; 5; s++)
{
   HYPRE_StructStencilSetElement(stencil, s, offsets[s]);
}
</PRE>
</blockquote>
The <code>Create()</code> routine creates an empty 2D, 5-pt stencil object.
The <code>SetElement()</code> routine defines the geometry of the stencil
and assigns the array numbers for each of the stencil entries.  None
of the calls are collective calls.

<P>

<H1><A NAME="SECTION00430000000000000000"></A>
<A NAME="Setting_Up_the_Struct_Matrix"></A><BR>
3.3 Setting Up the Struct Matrix
</H1>

<P>
The matrix is set up in terms of the grid and stencil objects
described in Sections
<A HREF="usr_manual.html#Setting_Up_the_Struct_Grid">3.1</A> and <A HREF="usr_manual.html#Setting_Up_the_Struct_Stencil">3.2</A>.
The coefficients associated with each stencil entry will typically
vary from gridpoint to gridpoint, but in the example problem being
considered, they are as follows over the entire grid (except at
boundaries; see below):
<BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
\left [
\begin{array}{ccc}
    & -1 &    \\
 -1 &  4 & -1 \\
    & -1 &    
\end{array}
\right ] .
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="eqn-stencil-laplacian"></A><IMG
 WIDTH="137" HEIGHT="73" BORDER="0"
 SRC="img9.png"
 ALT="\begin{displaymath}
\left [
\begin{array}{ccc}
&amp; -1 &amp; \\
-1 &amp; 4 &amp; -1 \\
&amp; -1 &amp;
\end{array}\right ] .
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(3.3)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
On process 0, the following code will set up matrix values associated
with the center (<IMG
 WIDTH="23" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$S_0$">) and south (<IMG
 WIDTH="23" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$S_3$">) stencil entries in
(<A HREF="usr_manual.html#eqn-stencil-description">3.2</A>) / (<A HREF="usr_manual.html#eqn-stencil-laplacian">3.3</A>)
(boundaries are ignored here temporarily).
<blockquote>
<PRE>
HYPRE_StructMatrix  A;
double              values[36];
int                 stencil_indices[2] = {0,3};
int                 i;

HYPRE_StructMatrixCreate(MPI_COMM_WORLD, grid, stencil, &amp;A);
HYPRE_StructMatrixInitialize(A);

for (i = 0; i &lt; 36; i += 2)
{
   values[i]   =  4.0;
   values[i+1] = -1.0;
}

HYPRE_StructMatrixSetBoxValues(A, ilower[0], iupper[0], 2,
                               stencil_indices, values);
HYPRE_StructMatrixSetBoxValues(A, ilower[1], iupper[1], 2,
                               stencil_indices, values);

/* set boundary conditions */
...

HYPRE_StructMatrixAssemble(A);
</PRE>
</blockquote>
The <code>Create()</code> routine creates an empty matrix object.  The
<code>Initialize()</code> routine indicates that the matrix coefficients
(or values) are ready to be set.  This routine may or may not involve
the allocation of memory for the coefficient data, depending on the
implementation.  The optional <code>Set</code> routines mentioned later in
this chapter and in the Reference Manual, should be called before this
step.  The <code>SetBoxValues()</code> routine sets the matrix coefficients
for some set of stencil entries over the gridpoints in some box.  Note
that the box need not correspond to any of the boxes used to create
the grid, but values should be set for all gridpoints that this
process ``owns''.  The <code>Assemble()</code> routine is a collective call,
and finalizes the matrix assembly, making the matrix ``ready to use''.

<P>
Matrix coefficients that reach outside of the boundary should be set
to zero.  For efficiency reasons, HYPRE does not do this
automatically.  The most natural time to insure this is when the
boundary conditions are being set, and this is most naturally done
after the coefficients on the grid's interior have been set.  For
example, during the implementation of the Dirichlet boundary condition
on the lower boundary of the grid in Figure <A HREF="usr_manual.html#fig-fv-grid">3.1</A>, the
``south'' coefficient must be set to zero.  To do this on process 0,
the following code could be used:
<blockquote>
<PRE>
int  ilower[2] = {-3, 1};
int  iupper[2] = { 2, 1};

/* create matrix and set interior coefficients */
...

/* implement boundary conditions */
...

for (i = 0; i &lt; 12; i++)
{
   values[i] =  0.0;
}

i = 3;
HYPRE_StructMatrixSetBoxValues(A, ilower, iupper, 1, &amp;i, values);

/* complete implementation of boundary conditions */
...
</PRE>
</blockquote>

<P>

<H1><A NAME="SECTION00440000000000000000"></A>
<A NAME="Setting_Up_the_Struct_Right-Hand-Side_Vector"></A><BR>
3.4 Setting Up the Struct Right-Hand-Side Vector
</H1>

<P>
The right-hand-side vector is set up similarly to the matrix set up
described in Section <A HREF="usr_manual.html#Setting_Up_the_Struct_Matrix">3.3</A> above.  The main
difference is that there is no stencil (note that a stencil currently
does appear in the interface, but this will eventually be removed).

<P>
On process 0, the following code will set up the right-hand-side
vector values.
<blockquote>
<PRE>
HYPRE_StructVector  b;
double              values[18];
int                 i;

HYPRE_StructVectorCreate(MPI_COMM_WORLD, grid, &amp;b);
HYPRE_StructVectorInitialize(b);

for (i = 0; i &lt; 18; i++)
{
   values[i]   =  0.0;
}

HYPRE_StructVectorSetBoxValues(b, ilower[0], iupper[0], values);
HYPRE_StructVectorSetBoxValues(b, ilower[1], iupper[1], values);

HYPRE_StructVectorAssemble(b);
</PRE>
</blockquote>

<P>
The <code>Create()</code> routine creates an empty vector object.  The
<code>Initialize()</code> routine indicates that the vector coefficients
(or values) are ready to be set.  This routine follows the same rules
as its corresponding <code>Matrix</code> routine.  The <code>SetBoxValues()</code>
routine sets the vector coefficients over the gridpoints in some box,
and again, follows the same rules as its corresponding <code>Matrix</code>
routine.  The <code>Assemble()</code> routine is a collective call, and
finalizes the vector assembly, making the vector ``ready to use''.

<P>

<H1><A NAME="SECTION00450000000000000000"></A>
<A NAME="Symmetric_Matrices"></A><BR>
3.5 Symmetric Matrices
</H1>

<P>
Some solvers and matrix storage schemes provide capabilities for
significantly reducing memory usage when the coefficient matrix is
symmetric.  In this situation, each off-diagonal coefficient appears
twice in the matrix, but only one copy needs to be stored.  The
<code>Struct</code> interface provides support for matrix and solver
implementations that use symmetric storage via the
<code>SetSymmetric()</code> routine.

<P>
To describe this in more detail, consider again the 5-pt finite-volume
discretization of (<A HREF="usr_manual.html#eqn-laplacian">3.1</A>) on the grid pictured in Figure
<A HREF="usr_manual.html#fig-fv-grid">3.1</A>.  Because the discretization is symmetric, only half
of the off-diagonal coefficients need to be stored.  To turn symmetric
storage on, the following line of code needs to be inserted somewhere
between the <code>Create()</code> and <code>Initialize()</code> calls.
<blockquote>
<PRE>
HYPRE_StructMatrixSetSymmetric(A, 1);
</PRE>
</blockquote>
Note that symmetric storage may or may not actually be used, depending
on the underlying storage scheme.  Currently in HYPRE, symmetric
storage is always used when indicated.

<P>
To most efficiently utilize the <code>Struct</code> interface for symmetric
matrices, notice that only half of the off-diagonal coefficients need
to be set.  To do this for the example being considered, we simply
need to redefine the 5-pt stencil of Section
<A HREF="usr_manual.html#Setting_Up_the_Struct_Stencil">3.2</A> to an ``appropriate'' 3-pt stencil, then
set matrix coefficients (as in Section <A HREF="usr_manual.html#Setting_Up_the_Struct_Matrix">3.3</A>)
for these three stencil elements <EM>only</EM>.  For example, we could
use the following stencil
<BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
\left [
\begin{array}{ccc}
 & ( 0, 1) &         \\
 & ( 0, 0) & ( 1, 0) \\
 &         &        
\end{array}
\right ]
\equiv
\left [
\begin{array}{ccc}
 & S_2 &     \\
 & S_0 & S_1 \\
 &     &    
\end{array}
\right ] .
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="eqn-symmetric-stencil"></A><IMG
 WIDTH="277" HEIGHT="73" BORDER="0"
 SRC="img10.png"
 ALT="\begin{displaymath}
\left [
\begin{array}{ccc}
&amp; ( 0, 1) &amp; \\
&amp; ( 0, 0) &amp; ( 1...
...ccc}
&amp; S_2 &amp; \\
&amp; S_0 &amp; S_1 \\
&amp; &amp;
\end{array}\right ] .
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(3.4)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
This 3-pt stencil provides enough information to recover the full 5-pt
stencil geometry and associated matrix coefficients.

<P>

<H1><A NAME="SECTION00500000000000000000"></A>
<A NAME="Semi-Structured-Grid_System_Interface"></A><BR>
4. Semi-Structured-Grid System Interface (SStruct)
</H1>

<P>
In order to get access to the most efficient and scalable solvers for
semi-structured-grid applications (applications with grids that are
mostly structured, but with some unstructured features), users should
use the <code>SStruct</code> interface described in this chapter.  This
interface also provides access to solvers in HYPRE that were
designed for unstructured-grid applications and sparse linear systems
in general.  These additional solvers are usually provided via the
unstructured-grid interface (<code>FEI</code>) or the linear-algebraic
interface (<code>IJ</code>) described in Chapters
<A HREF="usr_manual.html#Finite_Element_Interface">5</A> and <A HREF="usr_manual.html#Linear-Algebraic_System_Interface">6</A>.

<P>
Figure <A HREF="usr_manual.html#fig-block-structured-grid">4.1</A> gives an example of the type of
grid currently supported by the <code>SStruct</code> interface.  The grid is
composed of three ``parts''.  There is a single cell-centered variable
across the entire grid, except at the grid cell marked with a square,
which has one additional cell-centered variable.

<DIV ALIGN="CENTER"><A NAME="fig-block-structured-grid"></A><A NAME="581"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 4.1:</STRONG>
An example 2D block-structured grid, distributed accross three processes.</CAPTION>
<TR><TD><DIV ALIGN="CENTER"><IMG
 WIDTH="458" HEIGHT="418" ALIGN="BOTTOM" BORDER="0"
 SRC="img11.png"
 ALT="\includegraphics[width=4in]{block_structured.eps}">
</DIV></TD></TR>
</TABLE>
</DIV>

There are five basic steps involved in setting up the linear system to
be solved:

<OL>
<LI>set up the grid,
</LI>
<LI>set up the stencils,
</LI>
<LI>set up the graph,
</LI>
<LI>set up the matrix,
</LI>
<LI>set up the right-hand-side vector.
</LI>
</OL>
To describe each of these steps in more detail, consider solving the
2D Laplacian problem
<BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
\left \{
\begin{array}{ll}
\nabla^2 u = f , & \mbox{in the domain}, \\
u = 0,           & \mbox{on the boundary}.
\end{array}
\right .
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="sstruct:eqn-laplacian"></A><IMG
 WIDTH="235" HEIGHT="54" BORDER="0"
 SRC="img3.png"
 ALT="\begin{displaymath}
\left \{
\begin{array}{ll}
\nabla^2 u = f , &amp; \mbox{in the domain}, \\
u = 0, &amp; \mbox{on the boundary}.
\end{array}\right .
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(4.1)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
Assume (<A HREF="usr_manual.html#eqn-laplacian">3.1</A>) is discretized using standard 9-pt
finite-volumes on the grid pictured in
<A HREF="usr_manual.html#fig-block-structured-grid">4.1</A>, and assume that the problem data is
distributed across three processes as depicted.  In the figure, each
grid part is distributed onto a different process, but this need not
be the case; each grid part may also be distributed across several
processes.  Assume for simplicity and illustration that there is a
single coupling between the first and second variables in grid part 0
at index (1,2).  In general, this variable may also be coupled to
variables at neighboring indices.

<P>

<H1><A NAME="SECTION00510000000000000000"></A>
<A NAME="Setting_Up_the_SStruct_Grid"></A><BR>
4.1 Setting Up the SStruct Grid
</H1>

<P>
On process 0, the following code will set up the grid shown in the
figure (the code for processes 1 and 2 is similar).
<blockquote>
<PRE>
HYPRE_SStructGrid     grid;
int                   ilower[2][2] = {{-1, 0}, {1, 0}};
int                   iupper[2][2] = {{ 0, 3}, {2, 3}};
HYPRE_SStructVariable vars[1]      = {HYPRE_SSTRUCT_VARIABLE_CELL};

int                   addindex[2]  = {1,2};
HYPRE_SStructVariable addvars[1]   = {HYPRE_SSTRUCT_VARIABLE_CELL};

HYPRE_SStructGridCreate(MPI_COMM_WORLD, 2, 3, &amp;grid);

HYPRE_SStructGridSetExtents(grid, 0, ilower[0], iupper[0]);
HYPRE_SStructGridSetExtents(grid, 0, ilower[1], iupper[1]);

HYPRE_SStructGridSetVariables(grid, 0, 1, vars);
HYPRE_SStructGridAddVariables(grid, 0, addindex, 1, addvars);

HYPRE_SStructGridAssemble(grid);
</PRE>
</blockquote>
The <code>Create()</code> routine creates an empty 2D grid object that lives
on the <code>MPI_COMM_WORLD</code> communicator.  The <code>SetExtents()</code>
routine adds a new box to the grid.  The <code>SetVariables()</code> routine
sets the variables on a grid part, and the <code>AddVariables()</code>
routine adds variables to a grid part index (in the above example,
there are two cell-centered variables at index (1,2)).  The
<code>Assemble()</code> routine is a collective call (i.e., must be called
on all processes from a common synchronization point), and finalizes
the grid assembly, making the grid ``ready to use''.

<P>

<H1><A NAME="SECTION00520000000000000000"></A>
<A NAME="Setting_Up_the_SStruct_Stencil"></A><BR>
4.2 Setting Up the SStruct Stencil
</H1>

<P>
The geometry of the discretization stencil is described by an array of
integer tuples in 2D (triples in 3D), each representing a relative
offset (in index space) from some gridpoint on the grid.  For example,
the geometry of the 9-pt stencil for the example problem being
considered can be represented in the following way:
<BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
\left [
\begin{array}{ccc}
(-1, 1) & ( 0, 1) & ( 1, 1) \\
(-1, 0) & ( 0, 0) & ( 1, 0) \\
(-1,-1) & ( 0,-1) & ( 1,-1) 
\end{array}
\right ]
\equiv
\left [
\begin{array}{ccc}
S_7 & S_4 & S_8 \\
S_1 & S_0 & S_2 \\
S_5 & S_3 & S_6
\end{array}
\right ] .
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="sstruct:eqn-stencil-description"></A><IMG
 WIDTH="388" HEIGHT="73" BORDER="0"
 SRC="img12.png"
 ALT="\begin{displaymath}
\left [
\begin{array}{ccc}
(-1, 1) &amp; ( 0, 1) &amp; ( 1, 1) \\
(...
... \\
S_1 &amp; S_0 &amp; S_2 \\
S_5 &amp; S_3 &amp; S_6
\end{array}\right ] .
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(4.2)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
In (<A HREF="usr_manual.html#eqn-stencil-description">3.2</A>), the <IMG
 WIDTH="43" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img5.png"
 ALT="$(0,0)$"> entry represents the
``center'' coefficient, and is the 0th entry in the array (<IMG
 WIDTH="23" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$S_0$">).
The <IMG
 WIDTH="57" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img7.png"
 ALT="$(0,-1)$"> entry represents the ``south'' coefficient, and is the
3rd entry in the array (<IMG
 WIDTH="23" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$S_3$">).  And so on.

<P>
On process 0, 1, or 2, the following code will set up the stencil in
(<A HREF="usr_manual.html#eqn-stencil-description">3.2</A>).
<blockquote>
<PRE>
HYPRE_SStructStencil stencil;
int                  s;
int                  offsets[9][2] = {{0,0},
                                      {-1, 0}, { 1, 0}, { 0,-1}, { 0, 1}};
                                      {-1,-1}, { 1,-1}, {-1, 1}, { 1, 1}};

HYPRE_SStructStencilCreate(2, 9, &amp;stencil);

for (s = 0; s &lt; 9; s++)
   HYPRE_SStructStencilSetEntry(stencil, s, offsets[s], 0);
</PRE>
</blockquote>
The <code>Create()</code> routine creates an empty 2D, 9-pt stencil object.
The <code>SetEntry()</code> routine defines the geometry of the stencil, and
assigns the array numbers for each of the stencil entries.  None of
the calls are collective calls.

<P>

<H1><A NAME="SECTION00530000000000000000"></A>
<A NAME="Setting_Up_the_SStruct_Graph"></A><BR>
4.3 Setting Up the SStruct Graph
</H1>

<P>
The graph will represent the nonzero structure of the matrix in
Section <A HREF="usr_manual.html#Setting_Up_the_SStruct_Matrix">4.4</A> below.  It is defined in
terms of the grid and stencil objects described in Sections
<A HREF="usr_manual.html#Setting_Up_the_SStruct_Grid">4.1</A> and <A HREF="usr_manual.html#Setting_Up_the_SStruct_Stencil">4.2</A> above.

<P>
On process 0, the following code will set up the graph for the
example problem.
<blockquote>
<PRE>
HYPRE_SStructGraph graph;
int                addindex[9][2]   = {{ 2,0},{2,1},{2,2},{2,3},
                                       {-1,3},{0,3},{1,3},{2,3},
                                       { 1,2}};
int                addentries[9][2] = {{-1,0},{-1,1},{-1,2},{-1,3},
                                       { 9,9},{10,9},{11,9},{12,9},
                                       { 1,2}};

HYPRE_SStructGraphCreate(MPI_COMM_WORLD, grid, &amp;graph);

HYPRE_SStructGraphSetStencil(graph, 0, 0, stencil);

/* Add graph edge entries at grid part boundaries */
HYPRE_SStructGraphAddEntries(graph, 0, addindex[0], 0, 2, addentries[0], 0);
HYPRE_SStructGraphAddEntries(graph, 0, addindex[0], 0, 2, addentries[1], 0);
HYPRE_SStructGraphAddEntries(graph, 0, addindex[1], 0, 2, addentries[0], 0);
...

/* Add graph edge entries at index (1,2) */
HYPRE_SStructGraphAddEntries(graph, 0, addindex[8], 0, 0, addentries[8], 1);
HYPRE_SStructGraphAddEntries(graph, 0, addindex[8], 1, 0, addentries[8], 0);
</PRE>
</blockquote>

<P>

<H1><A NAME="SECTION00540000000000000000"></A>
<A NAME="Setting_Up_the_SStruct_Matrix"></A><BR>
4.4 Setting Up the SStruct Matrix
</H1>

<P>
The matrix is set up in terms of the graph object described in Section
<A HREF="usr_manual.html#Setting_Up_the_SStruct_Graph">4.3</A> above.  The coefficients associated
with each graph entry will typically vary from gridpoint to gridpoint,
but in the example problem being considered, they are as follows over
the entire grid (except at boundaries; see below):
<BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
\left [
\begin{array}{ccc}
 -1 & -1 & -1 \\
 -1 &  8 & -1 \\
 -1 & -1 & -1 
\end{array}
\right ] .
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="sstruct:eqn-stencil-laplacian"></A><IMG
 WIDTH="137" HEIGHT="73" BORDER="0"
 SRC="img13.png"
 ALT="\begin{displaymath}
\left [
\begin{array}{ccc}
-1 &amp; -1 &amp; -1 \\
-1 &amp; 8 &amp; -1 \\
-1 &amp; -1 &amp; -1
\end{array}\right ] .
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(4.3)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
On process 0, the following code will set up matrix values associated
with the center (<IMG
 WIDTH="23" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$S_0$">) and south (<IMG
 WIDTH="23" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$S_3$">) stencil entries in
(<A HREF="usr_manual.html#eqn-stencil-description">3.2</A>) / (<A HREF="usr_manual.html#eqn-stencil-laplacian">3.3</A>).
Matrix values associated with the non-stencil graph entries are also
set up.
<blockquote>
<PRE>
HYPRE_SStructMatrix  A;
double               values[32];
int                  sindices[2] = {0,3};
int                  gindices[4] = {9,10,11,0};
int                  i;

HYPRE_SStructMatrixCreate(MPI_COMM_WORLD, graph, &amp;A);
HYPRE_SStructMatrixInitialize(A);

for (i = 0; i &lt; 32; i += 2)
{
   values[i]   =  8.0;
   values[i+1] = -1.0;
}
HYPRE_SStructMatrixSetBoxValues(A, 0, ilower[0], iupper[0], 0,
                                2, sindices, values);

/* set values at non-stencil graph entries */
for (i = 0; i &lt; 3; i++)
{
   values[i] = -1.0;
}
HYPRE_SStructMatrixSetValues(A, 0, addindex[0], 0, 2, gindices, values);
HYPRE_SStructMatrixSetValues(A, 0, addindex[1], 0, 3, gindices, values);
HYPRE_SStructMatrixSetValues(A, 0, addindex[2], 0, 3, gindices, values);
...
HYPRE_SStructMatrixSetValues(A, 0, addindex[7], 0, 1, gindices, values);
HYPRE_SStructMatrixSetValues(A, 0, addindex[7], 1, 1, &amp;gindices[3], values);

/* zero out coefficients that reach outside of the domain or grid part */
...

/* set boundary conditions at domain boundaries, */
...

HYPRE_SStructMatrixAssemble(A);
</PRE>
</blockquote>

<P>

<H1><A NAME="SECTION00550000000000000000"></A>
<A NAME="Setting_Up_the_SStruct_Right-Hand-Side_Vector"></A><BR>
4.5 Setting Up the SStruct Right-Hand-Side Vector
</H1>

<P>
The right-hand-side vector is set up similarly to the matrix set up
described in Section <A HREF="usr_manual.html#Setting_Up_the_SStruct_Matrix">4.4</A> above.  The
main difference is that there is no graph.

<P>

<H1><A NAME="SECTION00600000000000000000"></A>
<A NAME="Finite_Element_Interface"></A><BR>
5. Finite Element Interface (FEI)
</H1>

<P>
The finite element interface (FEI) defines a linear solver interface 
for finite element applications.  For information on how to use this
interface, see [<A
 HREF="usr_manual.html#FEI-ref">4</A>].  
This chapter describes the iterative methods and 
preconditioners in the HYPRE implementation
of this interface.

<P>
Solving a linear system from a finite element problem consists of
four steps in the FEI:

<OL>
<LI>Initialize the structure of the finite-element data,
      including loading the element connectivity data
</LI>
<LI>Load the element or super-element stiffness matrices and forcing terms
</LI>
<LI>Set solver parameters and solve the linear system
</LI>
<LI>Retrieve the solution to the linear system
</LI>
</OL>

<P>
Parameters to the HYPRE solvers are specified by calling
<blockquote>
<PRE>
void FEI_parameters(int sysHandle, int numParams, char **paramStrings);
</PRE>
</blockquote>
where <TT>sysHandle</TT> is an identifier for the linear system being solved,
<TT>numParams</TT> is the number of parameter strings, and <TT>paramStrings</TT> is
an array of null-terminated strings with the format: 
``<EM>parameter_name value</EM>''.
For example, setting the preconditioner can be accomplished by:
<blockquote>
<PRE>
char **paramStrings[1];
paramStrings[0] = (char *) malloc(64*sizeof(char));
strcpy(paramStrings[0], "preconditioner parasails");
FEI_parameters(sysHandle, 1, paramStrings);
</PRE>
</blockquote>
All possible parameters are listed in Table <A HREF="usr_manual.html#table-fei-param">5.1</A>.

<P>
A linear system is then solved by calling 
<blockquote>
<PRE>
void FEI_iterateToSolve(int sysHandle);
</PRE>
</blockquote>

<P>

<H1><A NAME="SECTION00610000000000000000">
5.1 Iterative methods and preconditioners available</A>
</H1>

<P>

<H2><A NAME="SECTION00611000000000000000">
5.1.1 Iterative methods</A>
</H2>

<P>

<OL>
<LI>Krylov solvers (conjugate gradient, GMRES, TFQMR, BiCGSTAB)
</LI>
<LI>BoomerAMG (a parallel algebraic multigrid solver)
</LI>
<LI>SuperLU direct solver (sequential)
</LI>
<LI>SuperLU direct solver with iterative refinement (sequential)
</LI>
</OL>

<P>

<H2><A NAME="SECTION00612000000000000000">
5.1.2 Preconditioners</A>
</H2>

<P>

<OL>
<LI>diagonal
</LI>
<LI>parallel incomplete LU with threshold (PILUT)
</LI>
<LI>another parallel incomplete LU (Euclid)
</LI>
<LI>parallel algebraic multigrid (BoomerAMG)
</LI>
<LI>parallel sparse approximate inverse (ParaSails)
</LI>
</OL>

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="763"></A>
<TABLE>
<CAPTION><STRONG>Table 5.1:</STRONG>
Parameters.
</CAPTION>
<TR><TD>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Parameter Name</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>Parameter Values</TD>
</TR>
<TR><TD ALIGN="LEFT">solver</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324><code>cg</code>, <code>gmres</code> (default), <code>bicgstab</code>, <code>tfqmr</code>, <code>boomeramg</code>, <code>superlu</code>, <code>superlux</code></TD>
</TR>
<TR><TD ALIGN="LEFT">preconditioner</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324><code>diagonal</code> (default), <code>pilut</code>, <code>parasails</code>, <code>boomeramg</code>, <code>euclid</code></TD>
</TR>
<TR><TD ALIGN="LEFT">gmresDim</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>an integer specifying the value of <code>m</code> in restarted GMRES(m).
The default value is 50.</TD>
</TR>
<TR><TD ALIGN="LEFT">maxIterations</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>an integer specifying the maximum number of iterations permitted for
CG or GMRES.  The default value is 1000.</TD>
</TR>
<TR><TD ALIGN="LEFT">tolerance</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>a floating point number specifying the termination criterion for CG or
GMRES.  The default value is 1.0E-10.</TD>
</TR>
<TR><TD ALIGN="LEFT">pilutFillin</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>an integer specifying the maximum number of nonzeros kept in the
formation of incomplete L and U.  If this is not called, a value will
be selected based on the sparsity of the matrix.</TD>
</TR>
<TR><TD ALIGN="LEFT">pilutDropTol</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>a floating point number specifying the threshold to drop small entries
in L and U.  The default value is 0.0.</TD>
</TR>
<TR><TD ALIGN="LEFT">euclidNlevels</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>a non-negative integer specifying the desired sparsity of the incomplete
factors. The default value is 0.</TD>
</TR>
<TR><TD ALIGN="LEFT">euclidThreshold</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>a floating point number specifying the threshold used to sparsify the 
incomplete factors. The default value is 0.0.</TD>
</TR>
<TR><TD ALIGN="LEFT">superluOrdering</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324><code>natural</code> (default) or <code>mmd</code> (minimum degree ordering).  This
ordering is used to minimize the number of nonzeros generated in the
LU decomposition.  The default is natural ordering.</TD>
</TR>
<TR><TD ALIGN="LEFT">superluScale</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324><code>y</code> (yes; perform row and column scalings before decomposition) or
<code>n</code> (no; default).</TD>
</TR>
<TR><TD ALIGN="LEFT">amgCoarsenType</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324><code>falgout</code>, <code>ruge</code>, or <code>default</code> (CLJP) coarsening for BoomerAMG.</TD>
</TR>
<TR><TD ALIGN="LEFT">amgNumSweeps</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>an integer specifying the number of pre- and post-smoothing at each
level of BoomerAMG.  The default is one pre- and one post-smoothings.</TD>
</TR>
<TR><TD ALIGN="LEFT">amgRelaxType</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324><code>jacobi</code> (Damped Jacobi), <code>gs-slow</code> (sequential Gauss-Seidel),
<code>gs-fast</code> (Gauss-Seidel on interior nodes), <code>hybrid</code>, or
<code>direct</code>. The default is <code>hybrid</code>.</TD>
</TR>
<TR><TD ALIGN="LEFT">amgRelaxWeight</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>a floating point number between 0 and 1 specifying the damping factor
for BoomerAMG's damped Jacobi smoother.  The default value is 0.5.</TD>
</TR>
<TR><TD ALIGN="LEFT">amgStrongThreshold</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>a floating point number between 0 and 1 specifying the threshold used
to determine strong coupling in BoomerAMG's coasening.  The default
value is 0.25.</TD>
</TR>
<TR><TD ALIGN="LEFT">parasailsThreshold</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>a floating point number between 0 and 1 specifying the threshold used
to prune small entries in setting up the sparse approximate inverse.
The default value is 0.0.</TD>
</TR>
<TR><TD ALIGN="LEFT">parasailsNlevels</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>an integer larger than 0 specifying the desired sparsity of the
approximate inverse.  The default value is 1.</TD>
</TR>
<TR><TD ALIGN="LEFT">parasailsFilter</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>a floating point number between 0 and 1 defining the threshold used to
prune small entries in A. The default is 0.0.</TD>
</TR>
<TR><TD ALIGN="LEFT">parasailsLoadbal</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>a floating point number between 0 and 1 specifying how load balancing has 
to be done. The default is 0.0.</TD>
</TR>
<TR><TD ALIGN="LEFT">parasailsSymmetric</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>set ParaSails to take A as symmetric.</TD>
</TR>
<TR><TD ALIGN="LEFT">parasailsUnSymmetric</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>set ParaSails to take A as nonsymmetric (default).</TD>
</TR>
<TR><TD ALIGN="LEFT">parasailsReuse</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=324>set ParaSails to reuse the sparsity pattern of A.</TD>
</TR>
</TABLE>

<A NAME="table-fei-param"></A></TD></TR>
</TABLE>
</DIV><P></P><BR>

<P>

<H1><A NAME="SECTION00700000000000000000"></A>
<A NAME="Linear-Algebraic_System_Interface"></A><BR>
6. Linear-Algebraic System Interface (IJ)
</H1>

<P>
The <code>IJ</code> interface described in this chapter is the lowest common
denominator for specifying linear systems in HYPRE.  This interface
provides access to general sparse-matrix solvers in HYPRE, not
to the specialized solvers that require more problem information.

<P>

<H1><A NAME="SECTION00710000000000000000">
6.1 IJ Matrix Interface</A>
</H1>

<P>
As with the other interfaces in HYPRE, the <code>IJ</code> interface
expects to get data in distributed form because this is the only
scalable approach for assembling matrices on thousands of processes.
Matrices are assumed to be distributed by blocks of rows as follows:
<BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
\left[
\begin{array}{c}
~~~~~~~~~~ A_0 ~~~~~~~~~~ \\
A_1 \\
\vdots \\
A_{P-1}
\end{array}
\right]
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="164" HEIGHT="102" BORDER="0"
 SRC="img14.png"
 ALT="\begin{displaymath}
\left[
\begin{array}{c}
~~~~~~~~~~ A_0 ~~~~~~~~~~ \\
A_1 \\
\vdots \\
A_{P-1}
\end{array}\right]
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(6.1)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
In the above example, the matrix is distributed accross the <IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img15.png"
 ALT="$P$">
processes, <!-- MATH
 $0, 1, ..., P-1$
 -->
<IMG
 WIDTH="103" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img16.png"
 ALT="$0, 1, ..., P-1$"> by blocks of rows.  Each submatrix <IMG
 WIDTH="25" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img17.png"
 ALT="$A_p$">
is ``owned'' by a single process and its first and last row numbers
are given by the global indices <code>ilower</code> and <code>iupper</code> in the
<code>Create()</code> call below.

<P>
The following example code illustrates the basic usage of the
<code>IJ</code> interface for building matrices:
<blockquote>
<PRE>
MPI_Comm            comm;
HYPRE_IJMatrix      ij_matrix;
HYPRE_ParCSRMatrix  parcsr_matrix;
int                 ilower, iupper;
int                 jlower, jupper;
int                 nrows;
int                *ncols;
int                *rows;
int                *cols;
double             *values;

HYPRE_IJMatrixCreate(comm, ilower, iupper, jlower, jupper, &amp;ij_matrix);
HYPRE_IJMatrixSetObjectType(ij_matrix, HYPRE_PARCSR);
HYPRE_IJMatrixInitialize(ij_matrix);

/* set matrix coefficients */
HYPRE_IJMatrixSetValues(ij_matrix, nrows, ncols, rows, cols, values);
...
/* add-to matrix cofficients, if desired */
HYPRE_IJMatrixAddToValues(ij_matrix, nrows, ncols, rows, cols, values);
...

HYPRE_IJMatrixAssemble(ij_matrix);
HYPRE_IJMatrixGetObject(ij_matrix, (void **) &amp;parcsr_matrix);
</PRE>
</blockquote>
The <code>Create()</code> routine creates an empty matrix object that lives
on the <code>comm</code> communicator.  This is a collective call (i.e.,
must be called on all processes from a common synchronization point),
with each process passing its own row extents, <code>ilower</code> and
<code>iupper</code>.  The row partitioning must be contiguous, i.e.,
<code>iupper</code> for process <code>i</code> must equal <code>ilower</code><IMG
 WIDTH="27" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.png"
 ALT="$-1$"> for
process <code>i</code><IMG
 WIDTH="27" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.png"
 ALT="$+1$">.  Note that this allows matrices to have 0- or
1-based indexing.  The parameters <code>jlower</code> and <code>jupper</code>
define a column partitioning, and should match <code>ilower</code> and
<code>iupper</code> when solving square linear systems.  See the Reference
Manual for more information.

<P>
The <code>SetObjectType()</code> routine sets the underlying matrix object
type to <code>HYPRE_PARCSR</code> (this is the only object type currently
supported).  The <code>Initialize()</code> routine indicates that the matrix
coefficients (or values) are ready to be set.  This routine may or may
not involve the allocation of memory for the coefficient data,
depending on the implementation.  The optional <code>SetRowSizes()</code>
and <code>SetDiagOffdSizes()</code> routines
mentioned later in this chapter and in the Reference Manual, should be
called before this step.

<P>
The <code>SetValues()</code> routine sets matrix values for some number of
rows (<code>nrows</code>) and some number of columns in each row
(<code>ncols</code>).  The actual row and column numbers of the matrix
<code>values</code> to be set are given by <code>rows</code> and <code>cols</code>.
After the coefficients are set, they can be added to with an
<code>AddTo()</code> routine.  Each process should set only those matrix
values that it ``owns'' in the data distribution.

<P>
The <code>Assemble()</code> routine is a collective call, and finalizes the
matrix assembly, making the matrix ``ready to use''.  The
<code>GetObject()</code> routine retrieves the built matrix object so that
it can be passed on to HYPRE solvers that use the <code>ParCSR</code>
internal storage format.  Note that this is not an expensive routine;
the matrix already exists in <code>ParCSR</code> storage format, and the
routine simply returns a ``handle'' or pointer to it.  Although we
currently only support one underlying data storage format, in the
future several different formats may be supported.

<P>
One can preset the row sizes of the matrix in order to reduce the
execution time for the matrix specification.  One can specify the
total number of coefficients for each row, the number of coefficients
in the row that couple the diagonal unknown to (<code>Diag</code>) unknowns
in the same processor domain, and the number of coefficients in the
row that couple the diagonal unknown to (<code>Offd</code>) unknowns in
other processor domains:

<P>
<blockquote>
<PRE>
HYPRE_IJMatrixSetRowSizes(ij_matrix, sizes);
HYPRE_IJMatrixSetDiagOffdSizes(matrix, diag_sizes, offdiag_sizes);
</PRE>
</blockquote>

<P>
Once the matrix has been assembled, the sparsity pattern cannot be
altered without completely destroying the matrix object and starting
from scratch.  However, one can modify the matrix values of an already
assembled matrix.  To do this, first call the <code>Initialize()</code>
routine to re-initialize the matrix, then set or add-to values as
before, and call the <code>Assemble()</code> routine to re-assemble before
using the matrix.  Re-initialization and re-assembly are very cheap,
essentially a no-op in the current implementation of the code.

<P>

<H1><A NAME="SECTION00720000000000000000">
6.2 IJ Vector Interface</A>
</H1>

<P>
The following example code illustrates the basic usage of the
<code>IJ</code> interface for building vectors:

<P>
<blockquote>
<PRE>
MPI_Comm         comm;
HYPRE_IJVector   ij_vector;
HYPRE_ParVector  par_vector;
int              jlower, jupper;
int              nvalues;
int             *indices;
double          *values;

HYPRE_IJVectorCreate(comm, jlower, jupper, &amp;ij_vector);
HYPRE_IJVectorSetObjectType(ij_vector, HYPRE_PARCSR);
HYPRE_IJVectorInitialize(ij_vector);

/* set vector values */
HYPRE_IJVectorSetValues(ij_vector, nvalues, indices, values);
...

HYPRE_IJVectorAssemble(ij_vector);
HYPRE_IJVectorGetObject(ij_vector, (void **) &amp;par_vector);
</PRE>
</blockquote>
The <code>Create()</code> routine creates an empty vector object that lives
on the <code>comm</code> communicator.  This is a collective call, with each
process passing its own index extents, <code>jlower</code> and
<code>jupper</code>.  The names of these extent parameters begin with a
<code>j</code> because we typically think of matrix-vector multiplies as
the fundamental operation involving both matrices and vectors.  For
matrix-vector multiplies, the vector partitioning should match the
column partitioning of the matrix (which also uses the <code>j</code>
notation).  For linear system solves, these extents will typically
match the row partitioning of the matrix as well.

<P>
The <code>SetObjectType()</code> routine sets the underlying vector storage
type to <code>HYPRE_PARCSR</code> (this is the only storage type currently
supported).  The <code>Initialize()</code> routine indicates that the vector
coefficients (or values) are ready to be set.  This routine may or may
not involve the allocation of memory for the coefficient data,
depending on the implementation.

<P>
The <code>SetValues()</code> routine sets the vector <code>values</code> for some
number (<code>nvalues</code>) of <code>indices</code>.  Each process should set
only those vector values that it ``owns'' in the data distribution.

<P>
The <code>Assemble()</code> routine is a trivial collective call, and
finalizes the vector assembly, making the vector ``ready to use''.
The <code>GetObject()</code> routine retrieves the built vector object so
that it can be passed on to HYPRE solvers that use the
<code>ParVector</code> internal storage format.

<P>
Vector values can be modified in much the same way as with matrices by
first re-initializing the vector with the <code>Initialize()</code> routine.

<H1><A NAME="SECTION00800000000000000000"></A>
<A NAME="Solvers_and_Preconditioners"></A><BR>
7. Solvers and Preconditioners
</H1>

<P>
There are several solvers available in HYPRE via different
conceptual interfaces (see Table <A HREF="usr_manual.html#table-solver-availability">7.1</A>).
The procedure for setup and use of solvers and preconditioners is
largely the same. We will refer to them both as solvers in the sequel
except when noted.  In normal usage, the preconditioner is chosen and
constructed before the solver, and then handed to the solver as part
of the solver's setup.  In the following, we assume the most common
usage pattern in which a single linear system is set up and then
solved with a single righthand side. We comment later on
considerations for other usage patterns.

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="961"></A>
<TABLE>
<CAPTION><STRONG>Table:</STRONG>
Current solver availability via HYPRE conceptual interfaces.
</CAPTION>
<TR><TD>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="CENTER" COLSPAN=4>System Interfaces</TD>
</TR>
<TR><TD ALIGN="CENTER" COLSPAN=1>Solvers</TD>
<TD ALIGN="CENTER">Struct</TD>
<TD ALIGN="CENTER">SStruct</TD>
<TD ALIGN="CENTER">FEI</TD>
<TD ALIGN="CENTER">IJ</TD>
</TR>
<TR><TD ALIGN="LEFT">Jacobi</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">SMG</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">PFMG</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">BoomerAMG</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">X</TD>
</TR>
<TR><TD ALIGN="LEFT">ParaSails</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">X</TD>
</TR>
<TR><TD ALIGN="LEFT">Euclid</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">X</TD>
</TR>
<TR><TD ALIGN="LEFT">PILUT</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">X</TD>
</TR>
<TR><TD ALIGN="LEFT">PCG</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">X</TD>
</TR>
<TR><TD ALIGN="LEFT">GMRES</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">X</TD>
</TR>
</TABLE>

<A NAME="table-solver-availability"></A></TD></TR>
</TABLE>
</DIV><P></P><BR>

<P>

<H1><A NAME="SECTION00810000000000000000">
Setup:</A>
</H1>

<P>

<OL>
<LI><B>Pass to the solver the information defining the problem.</B> In the
typical user cycle, the user has passed this information into a matrix
through one of the conceptual interfaces prior to setting up the
solver. In this situation, the problem definition information is then
passed to the solver by passing the constructed matrix into the
solver. As described before, the matrix and solver must be compatible,
in that the matrix must provide the services needed by the
solver. Krylov solvers, for example, need only a matrix-vector
multiplication.  Most preconditioners, on the other hand, have
additional requirements such as access to the matrix coefficients.

<P>
</LI>
<LI><B>Choose parameters for the preconditioner and/or solver.</B>
Parameters are chosen through the <code>Set()</code> calls provided by the
solver.  As is true throughout HYPRE, all parameters have
reasonable defaults if not chosen.  Note that in HYPRE, convergence
criteria can be chosen after the preconditioner/solver has been setup.

<P>
</LI>
<LI><B>Pass the preconditioner to the solver.</B> For solvers that are not
preconditioned, this step is omitted.  The preconditioner is passed
through the <code>SetPreconditioner()</code> call.

<P>
</LI>
<LI><B>Set up the solver.</B> This is just the <code>Setup()</code> routine.

<P>
</LI>
</OL>

<P>
At this point, the solver/preconditioner is fully constructed and
ready for use.

<P>

<H1><A NAME="SECTION00820000000000000000">
Use:</A>
</H1>

<P>

<OL>
<LI><B>Set convergence criteria.</B>  Convergence can be controlled by the
number of iterations, as well as various tolerances such as relative
residual, preconditioned residual, etc.  Like all parameters,
reasonable defaults are used.  Users are free to change these, though
care must be taken.  For example, if an iterative method is used as a
preconditioner for a Krylov method, a constant number of iterations is
usually required.

<P>
</LI>
<LI><B>Solve the system.</B>  This is just the <code>Solve()</code> routine.

<P>
</LI>
</OL>
  
<H1><A NAME="SECTION00830000000000000000">
7.1 SMG</A>
</H1>

<P>
SMG is a parallel semicoarsening multigrid solver for the linear
systems arising from finite difference, finite volume, or finite
element discretizations of the diffusion equation,
<BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
\nabla \cdot ( D \nabla u ) + \sigma u = f
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="155" HEIGHT="31" BORDER="0"
 SRC="img20.png"
 ALT="\begin{displaymath}
\nabla \cdot ( D \nabla u ) + \sigma u = f
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(7.1)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
on logically rectangular grids.  The code solves both 2D and 3D
problems with discretization stencils of up to 9-point in 2D and up to
27-point in 3D.  See
[<A
 HREF="usr_manual.html#SSchaffer_1998a">10</A>,<A
 HREF="usr_manual.html#PNBrown_RDFalgout_JEJones_2000">2</A>,<A
 HREF="usr_manual.html#RDFalgout_JEJones_2000">5</A>]
for details on the algorithm and its parallel implementation/performance.

<P>
SMG is a particularly robust method.  The algorithm semicoarsens in
the z-direction and uses plane smoothing.  The xy plane-solves are
effected by one V-cycle of the 2D SMG algorithm, which semicoarsens in
the y-direction and uses line smoothing.

<P>
  
<H1><A NAME="SECTION00840000000000000000">
7.2 PFMG</A>
</H1>

<P>
PFMG is a parallel semicoarsening multigrid solver similar to SMG.
See [<A
 HREF="usr_manual.html#SFAshby_RDFalgout_1996">1</A>,<A
 HREF="usr_manual.html#RDFalgout_JEJones_2000">5</A>] for details
on the algorithm and its parallel implementation/performance.

<P>
The main difference between the two methods is in the smoother: PFMG
uses simple pointwise smoothing.  As a result, PFMG is not as robust
as SMG, but is much more efficient per V-cycle.

<P>
  
<H1><A NAME="SECTION00850000000000000000">
7.3 BoomerAMG</A>
</H1>

<P>
BoomerAMG is a parallel implementation of algebraic multigrid.
It can be used both as a solver or as a preconditioner.
The user can choose between various different parallel coarsening techniques
and relaxation schemes.
See [<A
 HREF="usr_manual.html#Henson_Yang:2000">6</A>] for a detailed description of the coarsening 
algorithms, the interpolation and nueemerical results.
The following coarsening techniques are available:

<UL>
<LI>the Cleary-Luby-Jones-Plassman (CLJP) coarsening,
</LI>
<LI>various variants of the classical Ruge-Stueben (RS) coarsening algorithm, and
</LI>
<LI>the Falgout coarsening which is a combination of CLJP and the
classical RS coarsening algorithm.
</LI>
</UL>
The following relaxation techniques are available:

<UL>
<LI>weighted Jacobi relaxation,
</LI>
<LI>a hybrid Gauss-Seidel / Jacobi relaxation scheme, 
</LI>
<LI>a symmetric hybrid Gauss-Seidel / Jacobi relaxation scheme, and
</LI>
<LI>sequential Gauss-Seidel relaxation.
</LI>
</UL>

<P>

<H2><A NAME="SECTION00851000000000000000">
7.3.1 Synopsis</A>
</H2>

<P>
The solver is set up and run using the following routines,
where A is the matrix, b the right hand side and x the solution vector
of the linear system to be solved:

<P>
<blockquote>
<PRE>
#include "HYPRE_parcsr_ls.h"

int HYPRE_BoomerAMGCreate(HYPRE_Solver *solver); 

&lt;set certain parameters if desired &gt;

int HYPRE_BoomerAMGSetup(HYPRE_Solver solver, HYPRE_ParCSRMatrix A,
  HYPRE_ParVector b, HYPRE_ParVector x);
int HYPRE_BoomerAMGSolve(HYPRE_Solver solver, HYPRE_ParCSRMatrix A,
  HYPRE_ParVector b, HYPRE_ParVector x);
int HYPRE_BoomerAMGDestroy(HYPRE_Solver solver);
</PRE>
</blockquote>

<P>

<H2><A NAME="SECTION00852000000000000000">
7.3.2 Interface functions</A>
</H2>

<P>
Parameters for setting up the code are specified using the following routines:

<P>

<H3><A NAME="SECTION00852100000000000000">
HYPRE_BoomerAMGSetMaxLevels</A>
</H3>
<blockquote>
<PRE>
int HYPRE_BoomerAMGSetMaxLevels( HYPRE_Solver solver, int max_levels);
</PRE>
</blockquote>
max_levels defines the maximal number of multigrid levels allowed.
The default is 25.

<P>

<H3><A NAME="SECTION00852200000000000000">
HYPRE_BoomerAMGSetMaxIter</A>
</H3>
<blockquote>
<PRE>
int HYPRE_BoomerAMGSetMaxIter( HYPRE_Solver solver, int max_iter);
</PRE>
</blockquote>
max_iter defines the maximal number of iterations allowed.
The default is 20.

<P>

<H3><A NAME="SECTION00852300000000000000">
HYPRE_BoomerAMGSetTol</A>
</H3>
<blockquote>
<PRE>
int HYPRE_BoomerAMGSetTol( HYPRE_Solver solver, double tol);
</PRE>
</blockquote>
tol defines the tolerance needed for the stopping criterion
<!-- MATH
 $\| b ~ - ~ Ax^{(n)} \|_2 / \| b \|_2 \leq$
 -->
<IMG
 WIDTH="172" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="img21.png"
 ALT="$\Vert b ~ - ~ Ax^{(n)} \Vert _2 / \Vert b \Vert _2 \leq $"> tol.
The default for tol is <IMG
 WIDTH="40" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.png"
 ALT="$10 ^{-7}$">.

<P>

<H3><A NAME="SECTION00852400000000000000">
HYPRE_BoomerAMGSetStrongThreshold</A>
</H3>
<blockquote>
<PRE>
int HYPRE_BoomerAMGSetStrongThreshold( HYPRE_Solver solver,
	double strong_threshold);
</PRE>
</blockquote>
A point <IMG
 WIDTH="10" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img23.png"
 ALT="$i$"> is strongly connected to <IMG
 WIDTH="13" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img24.png"
 ALT="$j$">, if <!-- MATH
 $-a_{i,j} \geq \theta 
\max_{j \neq i} \-a_{ij}$
 -->
<IMG
 WIDTH="156" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img25.png"
 ALT="$-a_{i,j} \geq \theta
\max_{j \neq i} \-a_{ij}$">, where the strong threshold <IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img26.png"
 ALT="$\theta$"> is a value
between 0 and 1. Weak connections are usually ignored when determining
the next lower level. Consequently, choosing a larger strong threshold
leads in general to smaller coarse grids, but worse convergence rates.
The default value for <IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img26.png"
 ALT="$\theta$">
is 0.25, which appears to be a good choice for 2-dimensional
problems. A better choice for 3-dimensional problems appears to be 0.5. However,
the choice of the strength threshold is problem dependent and therefore
there could be better choices than the two suggested ones.

<P>

<H3><A NAME="SECTION00852500000000000000">
HYPRE_BoomerAMGSetMaxRowSum</A>
</H3>
<blockquote>
<PRE>
int HYPRE_BoomerAMGSetMaxRowSum( HYPRE_Solver solver, double max_row_sum);
</PRE>
</blockquote>
This feature leads to a more efficient treatment of very
diagonally dominant portions of the matrix.
If the absolute row sum of row i weighted by the diagonal
is greater than max_row_sum all dependencies of variable i are set
to be weak. 
This feature can be switched off by setting max_row_sum to 1.0.
The default is 0.9.

<P>

<H3><A NAME="SECTION00852600000000000000">
HYPRE_BoomerAMGSetCoarsenType</A>
</H3>
<blockquote>
<PRE>
int HYPRE_BoomerAMGSetCoarsenType( HYPRE_Solver solver, int coarsen_type  );
</PRE>
</blockquote>
coarsen_type defines the coarsening used. The following options 
are possible:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">0</TD>
<TD ALIGN="LEFT">CLJP-coarsening</TD>
</TR>
<TR><TD ALIGN="LEFT">1</TD>
<TD ALIGN="LEFT">Ruge-Stueben coarsening without boundary treatment</TD>
</TR>
<TR><TD ALIGN="LEFT">3</TD>
<TD ALIGN="LEFT">Ruge-Stueben coarsening with a 3rd 'second' pass on the boundaries</TD>
</TR>
<TR><TD ALIGN="LEFT">6</TD>
<TD ALIGN="LEFT">Falgout coarsening (default)</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION00852700000000000000">
HYPRE_BoomerAMGSetMeasureType</A>
</H3>
<blockquote>
<PRE>
int HYPRE_BoomerAMGSetMeasureType( HYPRE_Solver solver, int measure_type  );
</PRE>
</blockquote>
measure_type defines 
whether local (measure_type = 0, default) or global measures 
(measure_type = 1) are used within the coarsening 
algorithm. This feature is ignored for the CLJP and the Falgout coarsening.

<P>

<H3><A NAME="SECTION00852800000000000000">
HYPRE_BoomerAMGSetNumGridSweeps</A>
</H3>
<blockquote>
<PRE>
int HYPRE_BoomerAMGSetNumGridSweeps( HYPRE_Solver solver, int* num_grid_sweeps );
</PRE>
</blockquote>
num_grid_sweeps[k] defines the number of sweeps over the grid on the fine 
grid (k=0), the down cycle (k=1), the up cycle (k=2) and the coarse grid (k=3).

<P>

<H3><A NAME="SECTION00852900000000000000">
HYPRE_BoomerAMGSetGridRelaxType</A>
</H3>
<blockquote>
<PRE>
int HYPRE_BoomerAMGSetGridRelaxType( HYPRE_Solver solver, int* grid_relax_type );
</PRE>
</blockquote>
grid_relax_type[k] defines the relaxation used on the fine 
grid (k=0), the down cycle (k=1), the up cycle (k=2) and the coarse grid (k=3).
The following options are possible for grid_relax_type[k]:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">0</TD>
<TD ALIGN="LEFT">weighted Jacobi</TD>
</TR>
<TR><TD ALIGN="LEFT">1</TD>
<TD ALIGN="LEFT">sequential Gauss-Seidel (very slow!)</TD>
</TR>
<TR><TD ALIGN="LEFT">3</TD>
<TD ALIGN="LEFT">Gauss-Seidel / Jacobi hybrid method (default)</TD>
</TR>
<TR><TD ALIGN="LEFT">6</TD>
<TD ALIGN="LEFT">symmetric Gauss-Seidel / Jacobi hybrid method</TD>
</TR>
<TR><TD ALIGN="LEFT">9</TD>
<TD ALIGN="LEFT">Gaussian elimination (only for the coarsest level (k=3), not recommended</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">if the system on the coarsest level is large)</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION008521000000000000000">
HYPRE_BoomerAMGSetGridRelaxPoints</A>
</H3>
<blockquote>
<PRE>
int HYPRE_BoomerAMGSetGridRelaxPoints( HYPRE_Solver solver, 
	int** grid_relax_points);
</PRE>
</blockquote>
grid_relax_points[i][j] defines which points are to be relaxed during
the (j+1)-th sweep on the fine 
grid (i=0), the down cycle (i=1), the up cycle (i=2) and the coarse grid (i=3),
e.g. if grid_relax_points[1][0] is -1, all points marked -1 (which are in
general fine points) are relaxed on the first sweep of the down cycle.
Note: grid_relax_points[3][j] needs to be 0 always, since the concept of 
coarse and fine points does not exist on the coarsest grid. If the user
sets it to another value, it will be automatically set to 0 and a warning
printed, unless the direct solver is used.

<P>

<H3><A NAME="SECTION008521100000000000000">
HYPRE_BoomerAMGSetRelaxWeight</A>
</H3>
<blockquote>
<PRE>
int HYPRE_BoomerAMGSetRelaxWeight( HYPRE_Solver solver, double* relax_weight);
</PRE>
</blockquote>
defines the relaxation weights used on each level, if weighted Jacobi is used
as relaxation method. The default relaxation weight is 1.0 on each level.

<P>

<H3><A NAME="SECTION008521200000000000000">
HYPRE_BoomerAMGSetPrintLevel</A>
</H3>
<blockquote>
<PRE>
int HYPRE_BoomerAMGSetPrintLevel( HYPRE_Solver solver, int print_level);
</PRE>
</blockquote>
where ioutdat determines whether statistics information is generated and 
printed. The information is printed to standard output.
The following options are possible:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">0</TD>
<TD ALIGN="LEFT">no output (default)</TD>
</TR>
<TR><TD ALIGN="LEFT">1</TD>
<TD ALIGN="LEFT">matrix statistics (includes information on interpolation operators and</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">matrices generated on each level)</TD>
</TR>
<TR><TD ALIGN="LEFT">2</TD>
<TD ALIGN="LEFT">cycle statistics (includes residuals generated during solve phase)</TD>
</TR>
<TR><TD ALIGN="LEFT">3</TD>
<TD ALIGN="LEFT">matrix and cycle statistics</TD>
</TR>
</TABLE>

<P>
  
<H1><A NAME="SECTION00860000000000000000">
7.4 ParaSails</A>
</H1>

<P>
ParaSails is a parallel implementation of a sparse approximate inverse
preconditioner, using <EM>a priori</EM> sparsity patterns and least-squares
(Frobenius norm) minimization.  Symmetric positive definite (SPD) problems
are handled using a factored SPD sparse approximate inverse.  General
(nonsymmetric and/or indefinite) problems are handled with an
unfactored sparse approximate inverse.  It is also possible to
precondition nonsymmetric but definite matrices with a factored, SPD
preconditioner.

<P>
ParaSails uses <EM>a priori</EM> sparsity patterns that are patterns of powers
of sparsified matrices.  ParaSails also uses a post-filtering technique
to reduce the cost of applying the preconditioner.  
In advanced usage not described here, the pattern of the
preconditioner can also be reused to generate preconditioners for different
matrices in a sequence of linear solves.

<P>
For more details about the ParaSails algorithm, see [<A
 HREF="usr_manual.html#Chow:1999:APS">3</A>].

<P>

<H2><A NAME="SECTION00861000000000000000">
7.4.1 Synopsis</A>
</H2>

<P>
<blockquote>
<PRE>
#include "HYPRE_parcsr_ls.h"

int HYPRE_ParaSailsCreate(MPI_Comm comm, HYPRE_Solver *solver, 
  int symmetry);
int HYPRE_ParaSailsSetParams(HYPRE_Solver solver, 
  double thresh, int nlevel, double filter);
int HYPRE_ParaSailsSetup(HYPRE_Solver solver, HYPRE_ParCSRMatrix A,
  HYPRE_ParVector b, HYPRE_ParVector x);
int HYPRE_ParaSailsSolve(HYPRE_Solver solver, HYPRE_ParCSRMatrix A,
  HYPRE_ParVector b, HYPRE_ParVector x);
int HYPRE_ParaSailsStats(HYPRE_Solver solver);
int HYPRE_ParaSailsDestroy(HYPRE_Solver solver);
</PRE>
</blockquote>

<P>
The accuracy and cost of ParaSails are parameterized by the real <EM>thresh</EM>
and integer <EM>nlevels</EM> parameters,
<!-- MATH
 $0 \le {\it thresh} \le 1$
 -->
<IMG
 WIDTH="115" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img27.png"
 ALT="$0 \le {\it thresh} \le 1$">, <!-- MATH
 $0 \le {\it nlevels}$
 -->
<IMG
 WIDTH="88" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img28.png"
 ALT="$0 \le {\it nlevels}$">.
Lower values of <EM>thresh</EM>
and higher values of <EM>nlevels</EM> lead to more accurate, but more expensive
preconditioners.  More accurate preconditioners are also more expensive
per iteration.  The default values are <!-- MATH
 ${\it thresh} = 0.1$
 -->
<IMG
 WIDTH="96" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img29.png"
 ALT="${\it thresh} = 0.1$">
and <!-- MATH
 ${\it nlevels} = 1$
 -->
<IMG
 WIDTH="88" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img30.png"
 ALT="${\it nlevels} = 1$">.  The parameters are set using
<TT>HYPRE_ParaSailsSetParams</TT>.

<P>
Mathematically, given a symmetric matrix <IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img31.png"
 ALT="$A$">, the pattern of the
approximate inverse is the pattern of <IMG
 WIDTH="30" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img32.png"
 ALT="$\tilde{A}^m$"> where <IMG
 WIDTH="17" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img33.png"
 ALT="$\tilde{A}$">
is a matrix that has been sparsified from <IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img31.png"
 ALT="$A$">.  The sparsification
is performed by dropping all entries in a symmetrically diagonally scaled <IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img31.png"
 ALT="$A$">
whose values are less than <EM>thresh</EM> in magnitude.  The parameter
<EM>nlevel</EM> is equivalent to <IMG
 WIDTH="50" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$m+1$">.
Filtering is a post-thresholding procedure.
For more details about the algorithm, see [<A
 HREF="usr_manual.html#Chow:1999:APS">3</A>].

<P>
The storage required for the ParaSails preconditioner depends on
the parameters <EM>thresh</EM> and <EM>nlevels</EM>.  The default parameters
often produce a preconditioner that can be stored in less than the
space required to store the original matrix.
ParaSails does not need a large amount of intermediate storage in
order to construct the preconditioner.

<P>

<H2><A NAME="SECTION00862000000000000000">
7.4.2 Interface functions</A>
</H2>

<P>
A ParaSails solver <TT>solver</TT> is returned with 
<blockquote>
<PRE>
int HYPRE_ParaSailsCreate(MPI_Comm comm, HYPRE_Solver *solver,
  int symmetry);
</PRE>
</blockquote>
where <TT>comm</TT> is the MPI communicator.

<P>
The value of <TT>symmetry</TT> has the following meanings, to indicate
the symmetry and definiteness of the problem, and to specify the 
type of preconditioner to construct:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">value</TD>
<TD ALIGN="LEFT">meaning</TD>
</TR>
<TR><TD ALIGN="CENTER">0</TD>
<TD ALIGN="LEFT">nonsymmetric and/or indefinite problem, and nonsymmetric preconditioner</TD>
</TR>
<TR><TD ALIGN="CENTER">1</TD>
<TD ALIGN="LEFT">SPD problem, and SPD (factored) preconditioner</TD>
</TR>
<TR><TD ALIGN="CENTER">2</TD>
<TD ALIGN="LEFT">nonsymmetric, definite problem, and SPD (factored) preconditioner</TD>
</TR>
</TABLE>
</DIV>
For more information about the final case, see section <A HREF="usr_manual.html#nearly">7.4.3</A>.

<P>
Parameters for setting up the preconditioner are specified using
<blockquote>
<PRE>
int HYPRE_ParaSailsSetParams(HYPRE_Solver solver, 
  double thresh, int nlevel, double filter);
</PRE>
</blockquote>

<P>
The parameters are used to specify the sparsity pattern and filtering value
(see above), and are described with suggested values as follows:

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">parameter</TD>
<TD ALIGN="CENTER">type</TD>
<TD ALIGN="CENTER">range</TD>
<TD ALIGN="CENTER">sug. values</TD>
<TD ALIGN="CENTER">default</TD>
<TD ALIGN="LEFT">meaning</TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>nlevel</TT></TD>
<TD ALIGN="CENTER">integer</TD>
<TD ALIGN="CENTER"><!-- MATH
 ${\tt nlevel} \ge 0$
 -->
<IMG
 WIDTH="91" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="${\tt nlevel} \ge 0$"></TD>
<TD ALIGN="CENTER">0, 1, 2</TD>
<TD ALIGN="CENTER">1</TD>
<TD ALIGN="LEFT"><!-- MATH
 $m={\tt nlevel}+1$
 -->
<IMG
 WIDTH="128" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img36.png"
 ALT="$m={\tt nlevel}+1$"></TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>thresh</TT></TD>
<TD ALIGN="CENTER">real</TD>
<TD ALIGN="CENTER"><!-- MATH
 ${\tt thresh} \ge 0$
 -->
<IMG
 WIDTH="91" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img37.png"
 ALT="${\tt thresh} \ge 0$"></TD>
<TD ALIGN="CENTER">0, 0.1, 0.01</TD>
<TD ALIGN="CENTER">0.1</TD>
<TD ALIGN="LEFT"><EM>thresh</EM> <IMG
 WIDTH="18" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img38.png"
 ALT="$=$"> <TT>thresh</TT></TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER"><!-- MATH
 ${\tt thresh}  <  0$
 -->
<IMG
 WIDTH="91" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.png"
 ALT="${\tt thresh} &lt; 0$"></TD>
<TD ALIGN="CENTER">-0.75, -0.90</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT"><EM>thresh</EM> selected automatically</TD>
</TR>
<TR><TD ALIGN="CENTER"><TT>filter</TT></TD>
<TD ALIGN="CENTER">real</TD>
<TD ALIGN="CENTER"><!-- MATH
 ${\tt filter} \ge 0$
 -->
<IMG
 WIDTH="91" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img40.png"
 ALT="${\tt filter} \ge 0$"></TD>
<TD ALIGN="CENTER">0, 0.05, 0.001</TD>
<TD ALIGN="CENTER">0.05</TD>
<TD ALIGN="LEFT">filter value <IMG
 WIDTH="18" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img38.png"
 ALT="$=$"> <TT>filter</TT></TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER"><!-- MATH
 ${\tt filter}  <  0$
 -->
<IMG
 WIDTH="91" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="${\tt filter} &lt; 0$"></TD>
<TD ALIGN="CENTER">-0.90</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">filter value selected automatically</TD>
</TR>
</TABLE>
</DIV>

<P>
When <!-- MATH
 ${\tt thresh} < 0$
 -->
<IMG
 WIDTH="91" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.png"
 ALT="${\tt thresh} &lt; 0$">, then a threshold is selected such that 
<IMG
 WIDTH="73" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$-{\tt thresh}$"> represents the fraction of the nonzero elements
that are dropped.  For example, if <!-- MATH
 ${\tt thresh} = -0.9$
 -->
<IMG
 WIDTH="118" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img43.png"
 ALT="${\tt thresh} = -0.9$"> then
<IMG
 WIDTH="17" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img33.png"
 ALT="$\tilde{A}$"> will contain approximately ten percent of the nonzeros
in <IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img31.png"
 ALT="$A$">.

<P>
When <!-- MATH
 ${\tt filter} < 0$
 -->
<IMG
 WIDTH="91" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="${\tt filter} &lt; 0$">, then a filter value is selected such that 
<IMG
 WIDTH="73" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.png"
 ALT="$-{\tt filter}$"> represents the fraction of the nonzero elements
that are dropped.  For example, if <!-- MATH
 ${\tt filter} = -0.9$
 -->
<IMG
 WIDTH="118" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img45.png"
 ALT="${\tt filter} = -0.9$"> then
approximately 90 percent of the entries in the computed approximate 
inverse are dropped.

<P>

<H2><A NAME="SECTION00863000000000000000"></A>
<A NAME="nearly"></A><BR>
7.4.3 Preconditioning nearly symmetric matrices
</H2>
A nonsymmetric, but definite and nearly symmetric matrix <IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img31.png"
 ALT="$A$"> 
may be preconditioned
with a symmetric preconditioner <IMG
 WIDTH="23" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img46.png"
 ALT="$M$">.  Using a symmetric preconditioner
has a few advantages, such as guaranteeing positive
definiteness of the preconditioner, as well as being less expensive
to construct.

<P>
The nonsymmetric matrix <IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img31.png"
 ALT="$A$"> must be definite,
i.e., <IMG
 WIDTH="93" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img47.png"
 ALT="$(A+A^T)/2$"> is SPD, and the <EM>a priori</EM> sparsity pattern to be used
must be symmetric.  The latter may be guaranteed by 1) 
constructing the sparsity pattern with a symmetric matrix, or 2) if the
matrix is structurally symmetric (has symmetric pattern), then
thresholding to construct the pattern is not used (i.e.,
zero value of the <TT>thresh</TT> parameter is used).

<P>
  
<H1><A NAME="SECTION00870000000000000000">
7.5 Euclid</A>
</H1>

<P>
The Euclid library is a scalable implementation of the 
Parallel ILU algorithm that was presented at SC99&nbsp;[<A
 HREF="usr_manual.html#hysom:sc99">7</A>],
and published in expanded form in the 
SIAM Journal on Scientific Computing&nbsp;[<A
 HREF="usr_manual.html#hysomSIAM">8</A>].
By <EM>scalable</EM> we mean that the factorization (setup)
and application (triangular solve) timings remain nearly constant
when the global problem size is scaled in proportion to the number of 
processors.
As with all ILU preconditioning methods, the number of iterations
is expected to increase with global problem size.

<P>
Experimental results have shown that PILU preconditioning is in general
more effective than Block Jacobi preconditioning 
for minimizing total solution time.
For scaled problems, the relative advantage appears to increase 
as the number of processors is scaled upwards.
Euclid may also be used to good advantage as a smoother within 
multigrid methods.

<P>

<H2><A NAME="SECTION00871000000000000000">
7.5.1 Synopsis</A>
</H2>

<P>
Euclid is best thought of as an ``extensible ILU preconditioning
framework.''
<EM>Extensible</EM> means that Euclid can (and eventually will, time and
contributing agencies permitting) support many variants of ILU(<IMG
 WIDTH="14" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img48.png"
 ALT="$k$">)
and ILUT preconditioning.
(The current release includes Block Jacobi ILU(<IMG
 WIDTH="14" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img48.png"
 ALT="$k$">) and
Parallel ILU(<IMG
 WIDTH="14" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img48.png"
 ALT="$k$">) methods.)
Due to this extensibility, and also because Euclid was developed 
independently of the HYPRE project, the methods by which one
passes runtime parameters to Euclid preconditioners
differ in some respects from the HYPRE norm.
While users can directly set options within their code,
options can also be passed to Euclid preconditioners via
command line switches and/or small text-based configuration files.
The latter strategies have the advantage that users will not need to
alter their codes as Euclid's capabilities are extended.

<P>
The following fragment illustrates the minimum coding required to invoke Euclid preconditioning within HYPRE application contexts.
The next subsection provides examples of the various ways in which
Euclid's options can be set. 
The final subsection lists the options,
and provides guidance as to the settings that (in our experience) 
will likely prove effective for minimizing execution time.

<P>
<blockquote>
<PRE>
#include "HYPRE_parcsr_ls.h"

HYPRE_Solver eu;
HYPRE_Solver pcg_solver;
HYPRE_ParVector b, x;
HYPRE_ParCSRMatrix A;

//Instantiate the preconditioner.
HYPRE_EuclidCreate(comm, &amp;eu);

//Optionally use the following two calls to set runtime options.
// 1. pass options from command line or string array.
HYPRE_EuclidSetParams(eu, argc, argv);

// 2. pass options from a configuration file.
HYPRE_EuclidSetParamsFromFile(eu, "filename");

//Set Euclid as the preconditioning method for some
//other solver, using the function calls HYPRE_EuclidSetup
//and HYPRE_EuclidSolve.  We assume that the pcg_solver
//has been properly initialized.
HYPRE_PCGSetPrecond(pcg_solver,
                    (HYPRE_PtrToSolverFcn) HYPRE_EuclidSolve,
                    (HYPRE_PtrToSolverFcn) HYPRE_EuclidSetup,
                    eu);

//Solve the system by calling the Setup and Solve methods for, 
//in this case, the HYPRE_PCG solver.  We assume that A, b, and x
//have been properly initialized.
HYPRE_PCGSetup(pcg_solver, (HYPRE_Matrix)A, (HYPRE_Vector)b, (HYPRE_Vector)x);
HYPRE_PCGSolve(pcg_solver, (HYPRE_Matrix)parcsr_A, (HYPRE_Vector)b, (HYPRE_Vector)x);

//Destroy the Euclid preconditioning object.
HYPRE_EuclidDestroy(eu);
</PRE>
</blockquote>

<P>

<H2><A NAME="SECTION00872000000000000000">
7.5.2 Setting options: examples</A>
</H2>

<P>
For expositional purposes, assume you wish to set the ILU(<IMG
 WIDTH="14" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img48.png"
 ALT="$k$">)
factorization level to the value <IMG
 WIDTH="46" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.png"
 ALT="$k = 3$">.
There are several methods of accomplishing this.
Internal to Euclid, options are stored in a simple database that
contains (name, value) pairs.
Various of Euclid's internal (private) functions query this
database to determine, at runtime, what action the user
has requested.
If you enter the option ``<B>-eu_stats 1''</B>, a report will
be printed when Euclid's destructor is called; this
report lists (among other statistics) the options that
were in effect during the factorization phase.

<P>
<B>Method 1.</B>
By default, Euclid always looks for a file titled
``database'' in the working directory. 
If it finds such a file, it opens it and attempts to parse it as
a configuration file.
Configuration files should be formatted as follows. 

<P>
<BR>
<BR>
<TT>&gt;cat database</TT> 
<BR><TT>#this is an optional comment</TT> 
<BR><TT>-level 3</TT>
<BR>
<BR>

<P>
Any line in a configuration file that contains a ``<TT>#</TT>''
character in the first column is ignored.
All other lines should begin with an option <EM>name</EM>, followed by
one or more blanks, followed by the option <EM>value</EM>.
Note that option names always begin with a ``-'' character.
If you include an option name that is not recognized by Euclid,
no harm should ensue.

<P>
<B>Method 2.</B>
To pass options on the command line, call
<blockquote>
<PRE>
HYPRE_EuclidSetParams(HYPRE_Solver solver, int argc, char *argv[]);
</PRE>
</blockquote>
where <TT>argc</TT> and <TT>argv</TT> carry the usual connotation:
<TT>main(int argc, char *argv[])</TT>.
If your HYPRE application is called <TT>phoo</TT>, you can
then pass options on the command line per the following example.

<P>
<blockquote>
<PRE>
mpirun -np 2 phoo -level 3
</PRE>
</blockquote>

<P>
Since Euclid looks for the ``database'' file when 
<TT>HYPRE_EuclidCreate</TT> is called, and parses the command line 
when <TT>HYPRE_EuclidSetParams</TT> is called,
option values passed on the command line will override 
any similar settings that may be contained in the ``database'' file.
Also, if same option name appears more than once on the command 
line, the final appearance determines the setting.

<P>
Some options, such as ``<TT>-bj</TT>'' (see next subsection) are boolean.
Euclid always treats these options as the value ``1'' (true)
or ``0'' (false).  
When passing boolean options from the command line
the value may be committed, in which case it assumed to be ``1.''
Note, however, that when boolean options are contained in a
configuration file, either the ``1'' or ``0'' must
stated explicitly.

<P>
<B>Method 3.</B>
There are two ways in which you can read in options from a file
whose name is other than ``database.''
First, you can call <TT>HYPRE_EuclidSetParamsFromFile</TT>
to specify a configuration filename.
Second, if you have passed the command line arguments as 
described above in Method 2, 
you can then specify the configuration filename on the command
line using the <B>-db_filename filename</B> option, e.g.,

<P>
<blockquote>
<PRE>
mpirun -np 2 phoo -db_filename ../myConfigFile
</PRE>
</blockquote>

<P>

<H2><A NAME="SECTION00873000000000000000">
7.5.3 Options summary</A>
</H2>

<P>
<DL>
<DT><STRONG>-level <!-- MATH
 $\langle int \rangle$
 -->
<IMG
 WIDTH="41" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$\langle int \rangle$"></STRONG></DT>
<DD>Factorization level for ILU(<IMG
 WIDTH="14" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img48.png"
 ALT="$k$">).  
           Default: 1.
           Guidance: for 2D convection-diffusion and similar problems, 
           fastest solution time is typically obtained with levels 4 through
           8.  For 3D problems fastest solution time is typically 
           obtained with level 1.

<P>
</DD>
<DT><STRONG>-bj</STRONG></DT>
<DD>Use Block Jacobi ILU preconditioning instead of PILU.
           Default: 0 (false). Guidance: if subdomains contain
           relatively few nodes (less than 1,000), or the problem is
           not well partitioned, Block Jacobi ILU 
           may give faster solution time than PILU.
</DD>
<DT><STRONG>-eu_stats</STRONG></DT>
<DD>When Euclid's destructor is called a summary of
                 runtime settings and timing information is printed
                 to stdout.  Default: 0 (false).
                 The timing marks in the report are the maximum over 
                 all processors in the MPI communicator.
</DD>
<DT><STRONG>-eu_mem</STRONG></DT>
<DD>When Euclid's destructor is called a summary of
               Euclid's memory usage is printed to stdout.
               Default: 0 (false).
               The statistics are for the processor whose rank 
               in MPI_COMM_WORLD is 0.
</DD>
<DT><STRONG>-printTestData</STRONG></DT>
<DD>This option is used in our autotest procedures,
                 and should not normally be invoked by users.
</DD>
</DL>

<P>
The following options are partially implemented, but not
yet fully functional (i.e, don't use them until further notice).

<P>
<DL>
<DT><STRONG>-sparseA <!-- MATH
 $\langle float \rangle$
 -->
<IMG
 WIDTH="58" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img51.png"
 ALT="$\langle float \rangle$"></STRONG></DT>
<DD>Drop-tolerance for ILU(<IMG
 WIDTH="14" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img48.png"
 ALT="$k$">) factorization.
                        Default: 0 (no dropping).
                        Entries are treated as zero if their absolute
                        value is less than (sparseA * max), where ``max''
                        is the largest absolute value of any entry in the
                        row. Guidance: try this in conjunction with 
                        -rowScale.  CAUTION: If the coefficient matrix <IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img31.png"
 ALT="$A$"> is 
                        symmetric, this
                        setting is likely to cause the filled matrix,
                        <IMG
 WIDTH="119" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img52.png"
 ALT="$F = L+U-I$">, to be unsymmetric.
                        This setting has no effect when ILUT factorization
                        is selected.
</DD>
<DT><STRONG>-rowScale</STRONG></DT>
<DD>Scale values prior to factorization such that the
                 largest value in any row is +1 or -1.
                 Default: 0 (false).
                 CAUTION: If the coefficient matrix <IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img31.png"
 ALT="$A$"> is symmetric, this 
                 setting is likely to cause the filled matrix,
                 <IMG
 WIDTH="119" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img52.png"
 ALT="$F = L+U-I$">, to be unsymmetric.
                 Guidance: if the matrix is poorly scaled, turning on
                 row scaling may help convergence.
</DD>
<DT><STRONG>-ilut <!-- MATH
 $\langle float \rangle$
 -->
<IMG
 WIDTH="58" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img51.png"
 ALT="$\langle float \rangle$"></STRONG></DT>
<DD>Use ILUT factorization instead
                 of the default, ILU(<IMG
 WIDTH="14" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img48.png"
 ALT="$k$">).  Here, <!-- MATH
 $\langle float \rangle$
 -->
<IMG
 WIDTH="58" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img51.png"
 ALT="$\langle float \rangle$">
                 is the drop tolerance, which is relative to the largest 
                 absolute value of any entry in the row being factored.
                 CAUTION: If the coefficient matrix <IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img31.png"
 ALT="$A$"> is symmetric, this 
                 setting is likely to cause the filled matrix,
                 <IMG
 WIDTH="119" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img52.png"
 ALT="$F = L+U-I$">, to be unsymmetric.
</DD>
<DT><STRONG>-maxNzPerRow  <!-- MATH
 $\langle int \rangle$
 -->
<IMG
 WIDTH="41" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$\langle int \rangle$"></STRONG></DT>
<DD>This sets the maximum number
                 of nonzeros that is permitted in any row of <IMG
 WIDTH="18" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img53.png"
 ALT="$F$">, in
                 addition to the number that would result from an ILU(0)
                 factorization.  A negative value indicates infinity (no limit).
                 This setting is effective for both ILU(<IMG
 WIDTH="14" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img48.png"
 ALT="$k$">)
                 and ILUT factorization methods.
                 Default: infinity, for ILU(<IMG
 WIDTH="14" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img48.png"
 ALT="$k$">); 5, for ILUT.
</DD>
</DL>
  
<H1><A NAME="SECTION00880000000000000000"></A>
<A NAME="PILUT"></A><BR>
7.6 <I>PILUT</I>: Parallel Incomplete Factorization
</H1>

<P>
<I>PILUT</I> is a parallel preconditioner based on Saad's dual-threshold incomplete
factorization algorithm. The original version of <I>PILUT</I> was done by
Karypis and Kumar [<A
 HREF="usr_manual.html#KK1998">9</A>] in terms of the Cray SHMEM library. The code
was subsequently modified by the HYPRE team: SHMEM was replaced by
MPI; some algorithmic changes were made; and it was software
engineered to be interoperable with several matrix implementations,
including HYPRE's ParCSR format, PETSc's matrices, and ISIS++
RowMatrix. The algorithm produces an approximate factorization <IMG
 WIDTH="30" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img54.png"
 ALT="$ L U$">,
with the preconditioner <IMG
 WIDTH="23" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img46.png"
 ALT="$M$"> defined by <IMG
 WIDTH="72" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img55.png"
 ALT="$ M = L U $">.

<P>
<B>Note:</B> <I>PILUT</I> produces a nonsymmetric preconditioner even when the
original matrix is symmetric. Thus, it is generally inappropriate for
preconditioning symmetric methods such as Conjugate Gradient.

<P>

<H2><A NAME="SECTION00881000000000000000">
Parameters:</A>
</H2>

<P>

<UL>
<LI><code>SetMaxNonzerosPerRow( int LFIL ); (Default: 20)</code>
Set the maximum number of nonzeros to be retained in each row of <IMG
 WIDTH="16" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img56.png"
 ALT="$L$"> and <IMG
 WIDTH="18" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img57.png"
 ALT="$U$">.
This parameter can be used to control the amount of memory that <IMG
 WIDTH="16" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img56.png"
 ALT="$L$"> and <IMG
 WIDTH="18" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img57.png"
 ALT="$U$">
occupy. Generally, the larger the value of <code>LFIL</code>, the longer it takes to
calculate the preconditioner and to apply the preconditioner and the larger
the storage requirements, but this trades
off versus a higher quality preconditioner that reduces the number of
iterations.

<P>
</LI>
<LI><code>SetDropTolerance( double tol ); (Default: 0.0001)</code>
Set the tolerance (relative to the 2-norm of the row) below which entries in L
and U are automatically dropped. <I>PILUT</I> first drops entries based on the drop
tolerance, and then retains the largest LFIL elements in each row that remain.
Smaller values of <code>tol</code> lead to more accurate preconditioners, but can
also lead to increases in the time to calculate the preconditioner.

<P>
</LI>
</UL>

<H1><A NAME="SECTION00900000000000000000">
8. Additional Information</A>
</H1>

<P>

<H1><A NAME="SECTION00910000000000000000">
8.1 Building the Library</A>
</H1>

<P>
Usually, HYPRE can be built by simply typing <kbd>./configure</kbd>
followed by <kbd>make</kbd> in the top-level source directory.
HYPRE uses GNU Autoconf, Automake, and libtool so the building 
of the HYPRE library should be familiar to you if you've built GNU
based packages before.

<P>

<H2><A NAME="SECTION00911000000000000000">
8.1.1 Getting the Library</A>
</H2>

<P>
The HYPRE distribution available through the Lawrence Livermore 
National Laboratory HYPRE web page at
<A NAME="tex2html6"
  HREF="http://www.llnl.gov/CASC/hypre/">http://www.llnl.gov/CASC/hypre/</A>
from the Software distribution page. 
The HYPRE Software distribution page will contain the tarballs for the 2
latest general, beta distributions, as well as documentation of HYPRE. 
You may also subscribe to the HYPRE software release announcement mailing 
lists form the HYPRE web page.

<P>

<H2><A NAME="SECTION00912000000000000000">
8.1.2 Library configuration</A>
</H2>

<P>
After unpacking the HYPRE tarball, the distribution will be in a 
subdirectory of the form, hypre-VERSION (e.g., hypre-1.8.4, with a
"b" appended if the release is a beta).<TT><BR>$ <B>gzip -cd hypre-1.8.4b.tar.gz | tar -xf -</B><BR>$ <B>cd hypre-1.8.4b</B><BR>$ <B>ls</B><BR></TT><PRE>
CHANGELOG                 INSTALL                   docs
COPYRIGHT_and_DISCLAIMER  README                    src
</PRE><TT>
$ <B>cd src</B><BR>$ <B>ls</B><BR></TT><PRE>
FEI_mv              blas                matrix_matrix       struct_ls
HYPRE.h             config              nopoe               struct_mv
IJ_mv               configure           parcsr_es           tarch
Makefile.am         distributed_ls      parcsr_ls           test
Makefile.in         distributed_matrix  parcsr_mv           utilities
aclocal.m4          krylov              seq_mv
babel               lapack              sstruct_ls
babel-runtime       lib                 sstruct_mv
</PRE>

<P>
The HYPRE distribution subdirectory will contain files and directories 
similar to the above directory listing.

<P>
To automatically generate machine specific makefiles, type
<kbd>./configure</kbd> in the top level `src' directory.  The <code>configure</code>
script is a portable script generated by GNU Autoconf.  It runs a
series of tests to determine characteristics of the machine on which
it is running, and it uses the results of the these tests to produce
the machine specific makefiles, called `Makefile', from template files
called `Makefile.in' in each directory.  Once the makefiles are
produced you can run make as you would with any other makefile.

<P>
The configure script primarily does the following things:

<UL>
<LI>selects a compiler
</LI>
<LI>provides either optimization or debugging options for the compiler
</LI>
<LI>finds the headers and libraries for MPI
</LI>
</UL>

<P>
The configure script makes these decisions based on a hierarchical
check.  First, it attempts to identify the machine on which it is
running as a specific supported machine.  Next it will try to identify
the architecture as a supported architecture.  If both of these fail,
generic default decisions are made by the script.  However, the script
does have some command-line options that can give you control over the
choices it will make.  You can type <kbd>configure -help</kbd> to see the
list of all of the command-line options to configure. This is the best
resource for information on configure options.  The `INSTALL' file
in the top-level directory contains a little more information on
installing software using configure. 

<P>
Configure automatically generates a file <code>HYPRE_config.h</code> that
includes all the header files found to be necessary by configure.
This file may be used to see how a compiled version of the library was
configured and may also be included by the user in his/her own code.

<P>
HYPRE libraries are built from the top-level source directory 
by simply typing:<TT><BR>$ <B>./configure</B><BR>$ <B>make install</B><BR><BR></TT>
Note that by default HYPRE libraries will be
installed in a subdirectory hypre/lib, and the include files in
hypre/include (i.e., -prefix=`pwd`/hypre). This differs from the standard
GNU install which uses /usr/local/lib, and /usr/local/include. After
testing (below) configure can be rerun with the -prefix=/usr/local
option, followed by make install, to get the GNU behavior.

<P>

<H2><A NAME="SECTION00913000000000000000">
8.1.3 Testing the Library</A>
</H2> 

<P>
After the make install step above, a few sample
drivers can be used to test the build. cd test make The test drivers ij,
ij_es, ij_mv, new_ij, struct, and sstruct will be built, and should 
be runable from the command line. <TT><BR>$ <B>./configure</B><BR>$ <B>make test</B><BR>$ <B>cd test</B><BR>$ <B>./ij</B><BR>$ <B>./ij_es</B><BR>$ <B>./ij_mv</B><BR>$ <B>./sstruct</B><BR>$ <B>./struct</B><BR><BR></TT>
To build the (stand-alone) fei driver the following 
steps are needed, starting from the top-level source directory: <TT><BR>$ <B>make nofei</B><BR>$ <B>cd test</B><BR>$ <B>make fei++</B><BR>$ <B>./fei</B><BR><BR></TT>

<P>

<H2><A NAME="SECTION00914000000000000000">
8.1.4 Linking to the Library</A>
</H2>

<P>
A program linking with HYPRE must be compiled with
<kbd>-I$PREFIX/include</kbd> and linked with
<kbd>-L$PREFIX/lib -l</kbd><I>hypre library name</I>... 
<kbd>-l</kbd><I>hypre library name</I>..., where <kbd>$PREFIX</kbd> is the
directory where HYPRE is installed, specified by the configure
option <kbd>-prefix=PREFIX</kbd>.  Additionally, any other
libraries to which HYPRE is linked must also be linked to by the
users application.  For example, the BLAS library or PETSc library are
often (but not always) linked in by HYPRE and would also need to be
linked in by the users application.

<P>
It may be useful to reference the <code>Makefile</code> in the <code>test</code>
subdirectory.  This makefile is designed to build test applications
that link with and call HYPRE.  All include and linking flags that
are used by HYPRE and needed by these test applications get
exported to this file by the <code>configure</code> script.

<P>

<H2><A NAME="SECTION00915000000000000000">
8.1.5 Configure Options</A>
</H2>

<P>
Configure does it best to try and determine the
compile options needed to build HYPRE. However the defaults that
configure chooses can not meet everyones needs. Configure will display
all of its available options by typing ./configure -help. A few of the
more useful options include: <TT><BR>$ <B>./configure -enable-shared=yes</B>, will build both 
shared and static libraries.<BR>$ <B>./configure -enable-debug -without-MPI</B>, will compile 
a serial version and debugging.<BR>$ <B>./configure -with-babel</B>, will build the babel interface 
libraries<BR>$ <B>./configure -prefix=$HOME</B>, will install HYPRE in 
to $HOME<BR></TT>
To build 64-bit static libraries on AIX (Note: configure will need to
execute compiled code for its test, so configure needs to be run so
that the default AIX poe scheduling is disabled), use the following: <TT><BR>$ <B>./nopoe ./configure CC=mpcc CXX=mpCC F77=mpxlf <IMG
 WIDTH="13" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img58.png"
 ALT="$\backslash$"></B><BR><B>CFLAGS="-q64 -qmaxmem=8192 -DHYPRE_COMM_SIMPLE -O3 
-qstrict"<IMG
 WIDTH="13" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img58.png"
 ALT="$\backslash$"></B><BR><B>CXXFLAGS="-q64 -qmaxmem=8192 -DHYPRE_COMM_SIMPLE -O3 
-qstrict"<IMG
 WIDTH="13" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img58.png"
 ALT="$\backslash$"></B><BR><B>F77FLAGS="-q64 -O3 -qstrict"<IMG
 WIDTH="13" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img58.png"
 ALT="$\backslash$"></B><BR><B>LDFLAGS="-q64" AR="ar -X64"</B><BR><B>make -i install</B><BR></TT>
To support a read-only source tree, and build everything in a 
directory, build (VPATH):<TT><BR>$ <B>mkdir build</B><BR>$ <B>cd build</B><BR>$ <B>../configure</B><BR>$ <B>make test</B><BR></TT>

<P>

<H2><A NAME="SECTION00916000000000000000">
8.1.6 Make Targets</A>
</H2>

<P><PRE>
all                     Make all the top-level targets, the default.
clean                   Undo what ever make does.
mostlyclean             Like clean, but leaves libraries.
Maintainer-clean        Delete everything than can be rebuilt.
distclean               Undo what ever configure does.
install                 Copy (install) executables/libraries.
install-strip           Strip the installed files.
uninstall               Undo what every make install does.
TAGS                    Update the tags table.
test                    Build, install libraries, then build test drivers.
dist                    Create a distribution file of the sources files.
check                   Perform self-test (if any).
installcheck            Build and test an install.
distcheck               Build and test a distribution.
</PRE>

<P>

<H2><A NAME="SECTION00917000000000000000">
8.1.7 Hints</A>
</H2>

<P>
Use MPI wrappers for the C, C++, and Fortran compilers (e.g.,
mpicc, mpicxx, mpif77).  This will cause the least amount of 
confusion for configure and allow you to conveniently tune the 
compiler flags and libraries to your particular system. If MPI 
is enabled, mpicc will be the preferred compiler for C, while 
mpiCC or mpicxx will be used for C++, and mpif77 for Fortran.

<P>
If when running <kbd>./configure</kbd> on AIX you get the error:<PRE>
checking for C compiler default output file name... a.out
checking whether the C compiler works... configure: error: cannot run C compiled programs.
If you meant to cross compile, use `--host'.
See `config.log' for more details.
</PRE>
Rerun configure using <kbd>./nopoe ./configure</kbd>.

<P>

<H1><A NAME="SECTION00920000000000000000"></A>
<A NAME="Calling_from_Fortran"></A><BR>
8.2 Calling from Fortran
</H1>

<P>
Although HYPRE is written in C, a Fortran interface is provided.
The Fortran interface is very similar to the C interface, and can be
determined from the C interface by a few simple conversion rules.
These conversion rules are described below.

<P>
Let us start out with a simple example.  Consider the following
HYPRE prototype:
<blockquote>
<PRE>
int HYPRE_IJMatrixSetValues(HYPRE_IJMatrix  matrix,
                            int  nrows, int  *ncols,
                            const int *rows, const int  *cols,
                            const double  *values);
</PRE>
</blockquote>
The corresponding Fortran code for calling this routine is as follows:
<blockquote>
<PRE>
      integer*8         matrix, 
      integer           nrows, ncols(MAX_NCOLS)
      integer           rows(MAX_ROWS), cols(MAX_COLS)
      double precision  values(MAX_COLS)
      integer           ierr

      call HYPRE_IJMatrixSetValues(matrix, nrows, ncols, rows, cols,
     &amp;                             values, ierr)
</PRE>
</blockquote>
The Fortran subroutine name is the same, unless the name is longer
than 31 characters.  In these situations, the name is condensed to 31
characters, usually by simple truncation.  For now, users should look
at the Fortran drivers in the <code>test</code> directory for the correct
condensed names.  In the future, this aspect of the interface conversion
will be made consistent and straightforward.

<P>
The Fortran subroutine argument list is always the same as the
corresponding C routine, except that the error return code <code>ierr</code>
is always last.  Conversion from C parameter types to Fortran argument
type is summarized in Table <A HREF="usr_manual.html#table-fortran-interface-types">8.1</A>.
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="1824"></A>
<TABLE>
<CAPTION><STRONG>Table 8.1:</STRONG>
Conversion from C parameters to Fortran arguments
</CAPTION>
<TR><TD>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">C parameter</TD>
<TD ALIGN="LEFT">Fortran argument</TD>
</TR>
<TR><TD ALIGN="LEFT"><code>int i</code></TD>
<TD ALIGN="LEFT"><code>integer i</code></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>double d</code></TD>
<TD ALIGN="LEFT"><code>double precision d</code></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>int *array</code></TD>
<TD ALIGN="LEFT"><code>integer array(*)</code></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>double *array</code></TD>
<TD ALIGN="LEFT"><code>double precision array(*)</code></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>char *string</code></TD>
<TD ALIGN="LEFT"><code>character string(*)</code></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>HYPRE_Type object</code></TD>
<TD ALIGN="LEFT"><code>integer*8 object</code></TD>
</TR>
<TR><TD ALIGN="LEFT"><code>HYPRE_Type *object</code></TD>
<TD ALIGN="LEFT"><code>integer*8 object</code></TD>
</TR>
</TABLE>

<A NAME="table-fortran-interface-types"></A></TD></TR>
</TABLE>
</DIV><P></P><BR>
Arrays arguments in HYPRE are always of type <code>(int *)</code> or
<code>(double *)</code>, and the corresponding Fortran types are simply
<code>integer</code> or <code>double precision</code> arrays.  Note that the
Fortran arrays may be indexed in any manner.  For example, an integer
array of length <code>N</code> may be declared in fortran as either of the
following:
<blockquote>
<PRE>
      integer  array(N)
      integer  array(0:N-1)
</PRE>
</blockquote>

<P>
HYPRE objects can usually be declared as in the table because
<code>integer*8</code> usually corresponds to the length of a pointer.
However, there may be some machines where this is not the case
(although we are not aware of any at this time).  On such machines,
the Fortran type for a HYPRE object should be an <code>integer</code> of
the appropriate length.

<P>

<H1><A NAME="SECTION00930000000000000000">
8.3 Bug Reporting</A>
</H1>

<P>
HYPRE has an automated bug reporting mechanism in place that may be used 
as a resource for submitting bugs, desired features, and documentation
problems, as well as querying the status of previous reports.  Access
<A NAME="tex2html8"
  HREF="http://www-casc.llnl.gov/bugs">http://www-casc.llnl.gov/bugs</A>
for full bug tracking details or to submit or query a bug report.
When using the CASC bug reporting site for the first time, click on
``Open a new Bugzilla account'' under the ``User login account
management'' heading.

<P>

<P>

<H2><A NAME="SECTION001000000000000000000">
Bibliography</A>
</H2><DL COMPACT><DD><P></P><DT><A NAME="SFAshby_RDFalgout_1996">1</A>
<DD>
S.&nbsp;F. Ashby and R.&nbsp;D. Falgout.
<BR>A parallel multigrid preconditioned conjugate gradient algorithm for
  groundwater flow simulations.
<BR><EM>Nuclear Science and Engineering</EM>, 124(1):145-159, September
  1996.
<BR>Also available as LLNL Technical Report UCRL-JC-122359.

<P></P><DT><A NAME="PNBrown_RDFalgout_JEJones_2000">2</A>
<DD>
P.&nbsp;N. Brown, R.&nbsp;D. Falgout, and J.&nbsp;E. Jones.
<BR>Semicoarsening multigrid on distributed memory machines.
<BR><EM>SIAM J. Sci. Comput.</EM>, 21(5):1823-1834, 2000.
<BR>Special issue on the Fifth Copper Mountain Conference on Iterative
  Methods. Also available as LLNL technical report UCRL-JC-130720.

<P></P><DT><A NAME="Chow:1999:APS">3</A>
<DD>
E.&nbsp;Chow.
<BR>A priori sparsity patterns for parallel sparse approximate inverse
  preconditioners.
<BR><EM>SIAM J. Sci. Comput.</EM>, 21:1804-1822, 2000.

<P></P><DT><A NAME="FEI-ref">4</A>
<DD>
R.&nbsp;L.&nbsp;Clay et&nbsp;al.
<BR>An annotated reference guide to the Finite Element Interface
  (FEI) specification, Version 1.0.
<BR>Technical Report SAND99-8229, Sandia National Laboratories,
  Livermore, CA, 1999.

<P></P><DT><A NAME="RDFalgout_JEJones_2000">5</A>
<DD>
R.&nbsp;D. Falgout and J.&nbsp;E. Jones.
<BR>Multigrid on massively parallel architectures.
<BR>In E.&nbsp;Dick, K.&nbsp;Riemslagh, and J.&nbsp;Vierendeels, editors, <EM>Multigrid
  Methods VI</EM>, volume&nbsp;14 of <EM>Lecture Notes in Computational Science and
  Engineering</EM>, pages 101-107, Berlin, 2000. Springer.
<BR>Proc. of the Sixth European Multigrid Conference held in Gent,
  Belgium, September 27-30, 1999. Also available as LLNL technical report
  UCRL-JC-133948.

<P></P><DT><A NAME="Henson_Yang:2000">6</A>
<DD>
V.&nbsp;E. Henson and U.&nbsp;M. Yang.
<BR>BoomerAMG: a parallel algebraic multigrid solver and
  preconditioner.
<BR><EM>Applied Numerical Mathematics</EM>.
<BR>, to appear. Also available as LLNL technical report UCRL-JC-141495.

<P></P><DT><A NAME="hysom:sc99">7</A>
<DD>
D.&nbsp;Hysom and A.&nbsp;Pothen.
<BR>Efficient parallel computation of ILU(k) preconditioners.
<BR>SC99, ACM, November 1999.
<BR>published on CDROM, ISBN #1-58113-091-0, ACM Order #415990,
  IEEE Computer Society Press Order # RS00197.

<P></P><DT><A NAME="hysomSIAM">8</A>
<DD>
D.&nbsp;Hysom and A.&nbsp;Pothen.
<BR>A scalable parallel algorithm for incomplete factor preconditioning.
<BR><EM>SIAM J. Sci. Comput.</EM>, 22(6):2194-2215, 2001.

<P></P><DT><A NAME="KK1998">9</A>
<DD>
G.&nbsp;Karpis and V.&nbsp;Kumar.
<BR>Parallel threshold-based ILU factorization.
<BR>Technical Report 061, University of Minnesota, Department of Computer
  Science/Army HPC Research Center, Minneapolis, MN 5455, 1998.

<P></P><DT><A NAME="SSchaffer_1998a">10</A>
<DD>
S.&nbsp;Schaffer.
<BR>A semi-coarsening multigrid method for elliptic partial differential
  equations with highly discontinuous and anisotropic coefficients.
<BR><EM>SIAM J. Sci. Comput.</EM>, 20(1):228-242, 1998.
</DL>

<P>
<BR>

<H2><A NAME="SECTION001100000000000000000">
Index</A>
</H2><DL COMPACT>
<DD>
</DL>

<P>

<H1><A NAME="SECTION001200000000000000000">
About this document ...</A>
</H1>
 <P>
This document was generated using the
<A HREF="http://www.latex2html.org/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 2002 (1.62)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
<A HREF="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos Drakos</A>, 
Computer Based Learning Unit, University of Leeds.
<BR>Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-split 2 -show_section_numbers -bottom_navigation -dir HYPRE_usr_manual usr_manual.tex</TT>
<P>
The translation was initiated by Ellen M. Hill on 2005-02-25<BR><HR>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"></A>

<UL>
<LI><A NAME="tex2html9"
  HREF="usr_manual.html#SECTION00100000000000000000">Contents</A>
<LI><A NAME="tex2html10"
  HREF="usr_manual.html#SECTION00200000000000000000">1. Introduction and Mailing List Information</A>
<UL>
<LI><A NAME="tex2html11"
  HREF="usr_manual.html#SECTION00210000000000000000">1.1 Features</A>
<LI><A NAME="tex2html12"
  HREF="usr_manual.html#SECTION00220000000000000000">1.2 Assumptions and Limitations</A>
</UL><BR>
<LI><A NAME="tex2html13"
  HREF="usr_manual.html#SECTION00300000000000000000">2. Getting Started</A>
<UL>
<LI><A NAME="tex2html14"
  HREF="usr_manual.html#SECTION00310000000000000000">2.1 A Simple Example</A>
<LI><A NAME="tex2html15"
  HREF="usr_manual.html#SECTION00320000000000000000">2.2 What are conceptual interfaces?</A>
<LI><A NAME="tex2html16"
  HREF="usr_manual.html#SECTION00330000000000000000">2.3 Which conceptual interface should I use?</A>
</UL><BR>
<LI><A NAME="tex2html17"
  HREF="usr_manual.html#SECTION00400000000000000000">3. Structured-Grid System Interface (Struct)</A>
<UL>
<LI><A NAME="tex2html18"
  HREF="usr_manual.html#SECTION00410000000000000000">3.1 Setting Up the Struct Grid</A>
<LI><A NAME="tex2html19"
  HREF="usr_manual.html#SECTION00420000000000000000">3.2 Setting Up the Struct Stencil</A>
<LI><A NAME="tex2html20"
  HREF="usr_manual.html#SECTION00430000000000000000">3.3 Setting Up the Struct Matrix</A>
<LI><A NAME="tex2html21"
  HREF="usr_manual.html#SECTION00440000000000000000">3.4 Setting Up the Struct Right-Hand-Side Vector</A>
<LI><A NAME="tex2html22"
  HREF="usr_manual.html#SECTION00450000000000000000">3.5 Symmetric Matrices</A>
</UL><BR>
<LI><A NAME="tex2html23"
  HREF="usr_manual.html#SECTION00500000000000000000">4. Semi-Structured-Grid System Interface (SStruct)</A>
<UL>
<LI><A NAME="tex2html24"
  HREF="usr_manual.html#SECTION00510000000000000000">4.1 Setting Up the SStruct Grid</A>
<LI><A NAME="tex2html25"
  HREF="usr_manual.html#SECTION00520000000000000000">4.2 Setting Up the SStruct Stencil</A>
<LI><A NAME="tex2html26"
  HREF="usr_manual.html#SECTION00530000000000000000">4.3 Setting Up the SStruct Graph</A>
<LI><A NAME="tex2html27"
  HREF="usr_manual.html#SECTION00540000000000000000">4.4 Setting Up the SStruct Matrix</A>
<LI><A NAME="tex2html28"
  HREF="usr_manual.html#SECTION00550000000000000000">4.5 Setting Up the SStruct Right-Hand-Side Vector</A>
</UL><BR>
<LI><A NAME="tex2html29"
  HREF="usr_manual.html#SECTION00600000000000000000">5. Finite Element Interface (FEI)</A>
<UL>
<LI><A NAME="tex2html30"
  HREF="usr_manual.html#SECTION00610000000000000000">5.1 Iterative methods and preconditioners available</A>
<UL>
<LI><A NAME="tex2html31"
  HREF="usr_manual.html#SECTION00611000000000000000">5.1.1 Iterative methods</A>
<LI><A NAME="tex2html32"
  HREF="usr_manual.html#SECTION00612000000000000000">5.1.2 Preconditioners</A>
</UL>
</UL><BR>
<LI><A NAME="tex2html33"
  HREF="usr_manual.html#SECTION00700000000000000000">6. Linear-Algebraic System Interface (IJ)</A>
<UL>
<LI><A NAME="tex2html34"
  HREF="usr_manual.html#SECTION00710000000000000000">6.1 IJ Matrix Interface</A>
<LI><A NAME="tex2html35"
  HREF="usr_manual.html#SECTION00720000000000000000">6.2 IJ Vector Interface</A>
</UL><BR>
<LI><A NAME="tex2html36"
  HREF="usr_manual.html#SECTION00800000000000000000">7. Solvers and Preconditioners</A>
<UL>
<LI><A NAME="tex2html37"
  HREF="usr_manual.html#SECTION00810000000000000000">Setup:</A>
<LI><A NAME="tex2html38"
  HREF="usr_manual.html#SECTION00820000000000000000">Use:</A>
<LI><A NAME="tex2html39"
  HREF="usr_manual.html#SECTION00830000000000000000">7.1 SMG</A>
<LI><A NAME="tex2html40"
  HREF="usr_manual.html#SECTION00840000000000000000">7.2 PFMG</A>
<LI><A NAME="tex2html41"
  HREF="usr_manual.html#SECTION00850000000000000000">7.3 BoomerAMG</A>
<UL>
<LI><A NAME="tex2html42"
  HREF="usr_manual.html#SECTION00851000000000000000">7.3.1 Synopsis</A>
<LI><A NAME="tex2html43"
  HREF="usr_manual.html#SECTION00852000000000000000">7.3.2 Interface functions</A>
<UL>
<LI><A NAME="tex2html44"
  HREF="usr_manual.html#SECTION00852100000000000000">HYPRE_BoomerAMGSetMaxLevels</A>
<LI><A NAME="tex2html45"
  HREF="usr_manual.html#SECTION00852200000000000000">HYPRE_BoomerAMGSetMaxIter</A>
<LI><A NAME="tex2html46"
  HREF="usr_manual.html#SECTION00852300000000000000">HYPRE_BoomerAMGSetTol</A>
<LI><A NAME="tex2html47"
  HREF="usr_manual.html#SECTION00852400000000000000">HYPRE_BoomerAMGSetStrongThreshold</A>
<LI><A NAME="tex2html48"
  HREF="usr_manual.html#SECTION00852500000000000000">HYPRE_BoomerAMGSetMaxRowSum</A>
<LI><A NAME="tex2html49"
  HREF="usr_manual.html#SECTION00852600000000000000">HYPRE_BoomerAMGSetCoarsenType</A>
<LI><A NAME="tex2html50"
  HREF="usr_manual.html#SECTION00852700000000000000">HYPRE_BoomerAMGSetMeasureType</A>
<LI><A NAME="tex2html51"
  HREF="usr_manual.html#SECTION00852800000000000000">HYPRE_BoomerAMGSetNumGridSweeps</A>
<LI><A NAME="tex2html52"
  HREF="usr_manual.html#SECTION00852900000000000000">HYPRE_BoomerAMGSetGridRelaxType</A>
<LI><A NAME="tex2html53"
  HREF="usr_manual.html#SECTION008521000000000000000">HYPRE_BoomerAMGSetGridRelaxPoints</A>
<LI><A NAME="tex2html54"
  HREF="usr_manual.html#SECTION008521100000000000000">HYPRE_BoomerAMGSetRelaxWeight</A>
<LI><A NAME="tex2html55"
  HREF="usr_manual.html#SECTION008521200000000000000">HYPRE_BoomerAMGSetPrintLevel</A>
</UL>
</UL>
<LI><A NAME="tex2html56"
  HREF="usr_manual.html#SECTION00860000000000000000">7.4 ParaSails</A>
<UL>
<LI><A NAME="tex2html57"
  HREF="usr_manual.html#SECTION00861000000000000000">7.4.1 Synopsis</A>
<LI><A NAME="tex2html58"
  HREF="usr_manual.html#SECTION00862000000000000000">7.4.2 Interface functions</A>
<LI><A NAME="tex2html59"
  HREF="usr_manual.html#SECTION00863000000000000000">7.4.3 Preconditioning nearly symmetric matrices</A>
</UL>
<LI><A NAME="tex2html60"
  HREF="usr_manual.html#SECTION00870000000000000000">7.5 Euclid</A>
<UL>
<LI><A NAME="tex2html61"
  HREF="usr_manual.html#SECTION00871000000000000000">7.5.1 Synopsis</A>
<LI><A NAME="tex2html62"
  HREF="usr_manual.html#SECTION00872000000000000000">7.5.2 Setting options: examples</A>
<LI><A NAME="tex2html63"
  HREF="usr_manual.html#SECTION00873000000000000000">7.5.3 Options summary</A>
</UL>
<LI><A NAME="tex2html64"
  HREF="usr_manual.html#SECTION00880000000000000000">7.6 <I>PILUT</I>: Parallel Incomplete Factorization</A>
<UL>
<LI><A NAME="tex2html65"
  HREF="usr_manual.html#SECTION00881000000000000000">Parameters:</A>
</UL>
</UL><BR>
<LI><A NAME="tex2html66"
  HREF="usr_manual.html#SECTION00900000000000000000">8. Additional Information</A>
<UL>
<LI><A NAME="tex2html67"
  HREF="usr_manual.html#SECTION00910000000000000000">8.1 Building the Library</A>
<UL>
<LI><A NAME="tex2html68"
  HREF="usr_manual.html#SECTION00911000000000000000">8.1.1 Getting the Library</A>
<LI><A NAME="tex2html69"
  HREF="usr_manual.html#SECTION00912000000000000000">8.1.2 Library configuration</A>
<LI><A NAME="tex2html70"
  HREF="usr_manual.html#SECTION00913000000000000000">8.1.3 Testing the Library</A>
<LI><A NAME="tex2html71"
  HREF="usr_manual.html#SECTION00914000000000000000">8.1.4 Linking to the Library</A>
<LI><A NAME="tex2html72"
  HREF="usr_manual.html#SECTION00915000000000000000">8.1.5 Configure Options</A>
<LI><A NAME="tex2html73"
  HREF="usr_manual.html#SECTION00916000000000000000">8.1.6 Make Targets</A>
<LI><A NAME="tex2html74"
  HREF="usr_manual.html#SECTION00917000000000000000">8.1.7 Hints</A>
</UL>
<LI><A NAME="tex2html75"
  HREF="usr_manual.html#SECTION00920000000000000000">8.2 Calling from Fortran</A>
<LI><A NAME="tex2html76"
  HREF="usr_manual.html#SECTION00930000000000000000">8.3 Bug Reporting</A>
</UL><BR>
<LI><A NAME="tex2html77"
  HREF="usr_manual.html#SECTION001000000000000000000">Bibliography</A>
<LI><A NAME="tex2html78"
  HREF="usr_manual.html#SECTION001100000000000000000">Index</A>
<LI><A NAME="tex2html79"
  HREF="usr_manual.html#SECTION001200000000000000000">About this document ...</A>
</UL>
<!--End of Table of Child-Links-->
<HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="file:/usr/share/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev_g.png">   
<BR>
<!--End of Navigation Panel-->
<ADDRESS>
Ellen M. Hill
2005-02-25
</ADDRESS>
</BODY>
</HTML>
