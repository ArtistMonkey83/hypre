                   
/*
 * File:        SIDL_cxx.hh
 * Copyright:   (c) 2001-2002 The Regents of the University of California
 * Release:     $Name: V1-9-0b $
 * Revision:    @(#) $Revision: 1.4 $
 * Date:        $Date: 2003/04/07 21:44:31 $
 * Description: Babel/C++ base classes 
 * AUTOMATICALLY GENERATED BY genSIDLcxx.py
 *
 */

#ifndef included_SIDL_cxx_hh
#define included_SIDL_cxx_hh

#ifndef __cplusplus
#error C++ headerfile: not meant for C compilers
#endif


// get babel configuration information
#include "babel_config.h"
#include <stdlib.h>

// need free()
#include <stddef.h>

// need exception
#include <exception>

// define the IOR pointer type.
struct SIDL_BaseClass__object;
//#include "SIDL_BaseClass_IOR.h"

// include complex<T>
#ifndef HAVE_COMPLEX
#  error C++ bindings assume complex<T> is available
#else
#  ifdef HAVE_COMPLEX_MATH_IN_NAMESPACE_STD
#    include <complex>
#  else
#    include <complex.h>
#  endif
#endif

// include C++ strings
#include <string>

// include SIDL_BaseClass__object
#ifndef included_SIDL_BaseClass_IOR_h
#include "SIDL_BaseClass_IOR.h"
#endif
#ifndef included_SIDL_h
#include "SIDL.h"
#endif
#ifndef included_SIDL_header_h
#include "SIDL_header.h"
#endif
#ifdef SIDL
/* AIX /usr/include/sys/proc.h has #define SIDL 4 (groan) */
#undef SIDL 
#endif

#ifndef included_SIDL_interface_IOR_h
#include "SIDL_interface_IOR.h"
#endif

#ifndef included_SIDL_BaseInterface_h
#include "SIDL_BaseInterface.h"
#endif

namespace SIDL { 


  // redefine types inside SIDL namespace
  // typedef bool bool;
  // typedef char char;
  // typedef ::int32_t int;
  // typedef ::int64_t long;
  // typedef float float;
  // typedef double double;
  typedef ::std::complex<float> fcomplex;
  typedef ::std::complex<double> dcomplex;
  typedef ::std::string string;
  typedef void * opaque;

  // This class is particular to C++ Stub Bindings.
  class NullIORException : public ::std::exception {
  private:
    ::std::string msg;

  public:
    NullIORException( const char * c ): msg(c) { }
    NullIORException( ::std::string s ): msg(s) { }
    virtual const char *what() const throw() { 
      return msg.c_str();
    }
#if defined(__GNUG__) && (__GNUG__ < 3)
    virtual ~NullIORException() { }
#else
    virtual ~NullIORException() throw() { }
#endif
  };

  // introduce StubBase into the SIDL namespace
  // StubBase is the abstract base class for all C++ stubs.
  class StubBase {
  public:
    virtual void* _cast(const char* type) const = 0;
    virtual ~StubBase() {}
  };

  // This is the root template that handles 
  // the guts of everything for SIDL Arrays
  template< typename array_ior_t, 
    typename item_ior_t, 
    typename item_cxx_wrapper_t > 
  class array_mixin { 
  protected:
    array_ior_t *d_array;
  public:
    // default constructor
    array_mixin() : d_array(0) {}

    // default destructor
    virtual ~array_mixin() {}

    // conversion from ior to C++ class
    array_mixin(array_ior_t* src ) : d_array(src) { 
      if ( d_array != 0 ) { 
	addRef();
      }
    }

    void addRef() throw ( NullIORException ) {
      if ( d_array == 0 ) {
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array_mixin<>::addRef()'"
        ));
      }
      SIDL_interface__array_addRef(
        reinterpret_cast<struct SIDL_interface__array *>(d_array) );
    }

    void deleteRef() throw ( NullIORException ) {
      if ( d_array == 0 ) {
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array_mixin<>::deleteRef()'"
        ));
      }
      SIDL_interface__array_deleteRef(
        reinterpret_cast<struct SIDL_interface__array *>(d_array) );
      d_array = 0;
    }
    
    // borrow
    void borrow( item_ior_t * first_element, int32_t dimen,
      const int32_t lower[], const int32_t upper[], const int32_t stride[]) {
      d_array = reinterpret_cast<array_ior_t*>(
	SIDL_interface__array_borrow(first_element, dimen, lower,
				     upper, stride));
    }

    // isColumnOrder
    bool isColumnOrder() const {
      return SIDL_interface__array_isColumnOrder(
        reinterpret_cast<const struct SIDL_interface__array *>(d_array)) == TRUE;
    }

    // isRowOrder
    bool isRowOrder() const {
      return SIDL_interface__array_isRowOrder(
        reinterpret_cast<const struct SIDL_interface__array *>(d_array)) == TRUE;
    }

    // get dimension
    int32_t dimen() const { 
      return SIDL_interface__array_dimen
	(reinterpret_cast<const struct SIDL_interface__array *>(d_array));
    }
    
    // get lower bound along particular dimension
    int32_t lower( int32_t d ) const {
      return SIDL_interface__array_lower
	(reinterpret_cast<const struct SIDL_interface__array *>(d_array), d);
    } 
    
    // get upper bound along particular dimension
    int32_t upper( int32_t d ) const {
      return SIDL_interface__array_upper
	(reinterpret_cast<const struct SIDL_interface__array *>(d_array), d);
    }
    
    // get stride along particular dimension
    int32_t stride( int32_t d ) const {
      return SIDL_interface__array_stride
	(reinterpret_cast<const struct SIDL_interface__array *>(d_array), d);
    }
    
    // get a const pointer to the actual array ior 
    const array_ior_t* _get_ior() const { return d_array; }

    // get a non-const pointer to the actual array ior
    array_ior_t* _get_ior() { return d_array;}

    // check if no pointer to array
    bool _is_nil() const {
      return (d_array==0);
    }

    // check if no pointer to array
    bool _not_nil() const {
      return (d_array!=0);
    }

    // check if no pointer to array
    bool operator !() const {
      return (d_array==0);
    }

    // set the actual array ior
    void _set_ior( array_ior_t * s) { d_array=s; }

    // get
    item_cxx_wrapper_t get(int32_t i) {
      SIDL_BaseInterface sbi =
        SIDL_interface__array_get1
        (reinterpret_cast<const struct SIDL_interface__array *>(d_array), i);
      item_cxx_wrapper_t icwt(reinterpret_cast<item_ior_t>(sbi));
      if (sbi) {
        SIDL_BaseInterface_deleteRef(sbi);
      }
      return icwt;
    }

    // get
    item_cxx_wrapper_t get(int32_t i, int32_t j) {
      SIDL_BaseInterface sbi =
        SIDL_interface__array_get2
        (reinterpret_cast<const struct SIDL_interface__array *>(d_array), i, j);
      item_cxx_wrapper_t icwt(reinterpret_cast<item_ior_t>(sbi));
      if (sbi) {
        SIDL_BaseInterface_deleteRef(sbi);
      }
      return icwt;
    }

    // get
    item_cxx_wrapper_t get(int32_t i, int32_t j, int32_t k) {
      SIDL_BaseInterface sbi =
        SIDL_interface__array_get3
        (reinterpret_cast<const struct SIDL_interface__array *>(d_array), i, j, k);
      item_cxx_wrapper_t icwt(reinterpret_cast<item_ior_t>(sbi));
      if (sbi) {
        SIDL_BaseInterface_deleteRef(sbi);
      }
      return icwt;
    }

    // get
    item_cxx_wrapper_t get(int32_t i, int32_t j, int32_t k, int32_t l) {
      SIDL_BaseInterface sbi =
        SIDL_interface__array_get4
        (reinterpret_cast<const struct SIDL_interface__array *>(d_array), i, j, k, l);
      item_cxx_wrapper_t icwt(reinterpret_cast<item_ior_t>(sbi));
      if (sbi) {
        SIDL_BaseInterface_deleteRef(sbi);
      }
      return icwt;
    }


    // get
    item_cxx_wrapper_t get(const int32_t ind[]) {
      SIDL_BaseInterface sbi =
        SIDL_interface__array_get
        (reinterpret_cast<const struct SIDL_interface__array *>(d_array), ind);
      item_cxx_wrapper_t icwt(reinterpret_cast<item_ior_t>(sbi));
      if (sbi) {
        SIDL_BaseInterface_deleteRef(sbi);
      }
      return icwt;
    }

    // set
    void set(int32_t i, item_cxx_wrapper_t element) {
      SIDL_interface__array_set1
	(reinterpret_cast<struct SIDL_interface__array *>(d_array), i, 
	 reinterpret_cast<struct SIDL_BaseInterface__object *>(
	 element._get_ior()));
    }
    
    // set
    void set(int32_t i, int32_t j, item_cxx_wrapper_t element) {
      SIDL_interface__array_set2
	(reinterpret_cast<struct SIDL_interface__array *>(d_array), i, j,
	 reinterpret_cast<struct SIDL_BaseInterface__object *>(
	 element._get_ior()));
    }
    
    // set
    void set(int32_t i, int32_t j, int32_t k, item_cxx_wrapper_t element) {
      SIDL_interface__array_set3
	(reinterpret_cast<struct SIDL_interface__array *>(d_array), i, j, k,
	 reinterpret_cast<struct SIDL_BaseInterface__object *>(
	 element._get_ior()));
    }
    
    // set
    void set(int32_t i, int32_t j, int32_t k, int32_t l, item_cxx_wrapper_t element) {
      SIDL_interface__array_set4
	(reinterpret_cast<struct SIDL_interface__array *>(d_array), i, j, k, l,
	 reinterpret_cast<struct SIDL_BaseInterface__object *>(
	 element._get_ior()));
    }
    
    // set
    void set(const int32_t ind[], item_cxx_wrapper_t element) {
      SIDL_interface__array_set
        (reinterpret_cast<struct SIDL_interface__array *>(d_array), ind, 
         reinterpret_cast<struct SIDL_BaseInterface__object *>(
         element._get_ior()));
    }
  };

  // This is a bogus template that doesn't do much.
  // But we specialize off of this to the more complicated
  // forms above.
  template< typename T > 
  class array : public array_mixin< SIDL_int__array, int32_t, int32_t > { 
  };

  // Now the template classes for built-in types.
  template<> 
  class array< bool > :
      public array_mixin< struct SIDL_bool__array, SIDL_bool, bool > { 
  public:
    // default constructor 
    array() : array_mixin< struct SIDL_bool__array, SIDL_bool, bool >() {} 

    // default destructor
    virtual ~array() {
      if ( d_array ) {
        SIDL_bool__array_deleteRef( d_array );
      }
    }

    // copy constructor
    array( const array< bool >& original ) { 
      d_array = original.d_array;
      if ( d_array ) { addRef(); }
    }

    // assignment operator
    array< bool >& operator=( const array< bool >& rhs ) { 
      if ( d_array != rhs.d_array ) { 
	if ( d_array ) { deleteRef(); }
	d_array=rhs.d_array;
	if ( d_array ) { addRef(); }
      }
      return *this;
    }

    // conversion from ior to C++ class
    // (constructor/casting operator)
    array( SIDL_bool__array* src ) : array_mixin< struct SIDL_bool__array, SIDL_bool, bool >(src) {}


    void addRef() throw ( NullIORException ) {
      if ( d_array == 0 ) { 
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< bool >::addRef()'"
        ));
      }
      SIDL_bool__array_addRef( d_array );
    }

    void deleteRef() throw ( NullIORException ) {
      if ( d_array == 0 ) {
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< bool >::deleteRef()'"
        ));
      }
      SIDL_bool__array_deleteRef( d_array );
      d_array = 0;
    }
       
    // static constructor: createRow
    static array< bool >
    createRow(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< bool > retval;
      retval._set_ior(SIDL_bool__array_createRow(dimen, lower, upper) );
      return retval;
    }
    
    static array< bool >
    createCol(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< bool > retval;
      retval._set_ior( SIDL_bool__array_createCol(dimen, lower, upper) );
      return retval;
    }
    
    static array< bool >
    create1d(int32_t len) {
      array< bool > retval;
      retval._set_ior(SIDL_bool__array_create1d( len ) );
      return retval;
    }

    static array< bool >
    create2dCol(int32_t m, int32_t n ) {
      array< bool > retval;
      retval._set_ior( SIDL_bool__array_create2dCol(m,n) );
      return retval;
    }

    static array< bool >
    create2dRow(int32_t m, int32_t n ) {
      array< bool > retval;
      retval._set_ior( SIDL_bool__array_create2dRow(m,n) );
      return retval;
    }

    array< bool >
    slice( int32_t dimen,
           const int32_t newElem[],
           const int32_t *srcStart = 0,
           const int32_t *srcStride = 0,
           const int32_t *newStart = 0) {
      array< bool > retval;
      retval._set_ior(  SIDL_bool__array_slice( d_array, dimen, newElem,
                                           srcStart, srcStride, newStart ) );
      return retval;
    }
    
    // borrow
    void borrow( SIDL_bool * first_element, int32_t dimen,
      const int32_t lower[], const int32_t upper[], const int32_t stride[]) {
      d_array = SIDL_bool__array_borrow(first_element, dimen, lower,
					upper, stride);
    }

    const SIDL_bool* first() const {
      return const_cast<const SIDL_bool*>(SIDL_bool__array_first( _get_ior() ) );
    }

    SIDL_bool* first() {
      return SIDL_bool__array_first( _get_ior() );
    }
    void copy( const array< bool >& src ) {
      SIDL_bool__array_copy( src._get_ior(), _get_ior() );
    }

    // smartCopy
    void smartCopy( ) {
       struct SIDL_bool__array* p = SIDL_bool__array_smartCopy( _get_ior() );
       if ( _not_nil() ) { deleteRef(); }
       _set_ior( p );
    }
    
    // ensure
    void ensure( int32_t dimen, int ordering ) {
      struct SIDL_bool__array* p = SIDL_bool__array_ensure( _get_ior(), dimen, ordering );
      if ( _not_nil() ) { deleteRef(); }
      _set_ior( p );
    }

    // isColumnOrder
    bool isColumnOrder() const {
      return SIDL_bool__array_isColumnOrder( d_array ) == TRUE;
    }

    // isRowOrder
    bool isRowOrder() const {
      return SIDL_bool__array_isRowOrder( d_array ) == TRUE;
    }

    // get dimension
    int32_t dimen() const { 
      return SIDL_bool__array_dimen(
	reinterpret_cast<const struct SIDL_bool__array *>(d_array));
    }
    
    // get lower bound along particular dimension
    int32_t lower( int32_t d ) const {
      return SIDL_bool__array_lower(
	reinterpret_cast<const struct SIDL_bool__array *>(d_array), d);
    } 
    
    // get upper bound along particular dimension
    int32_t upper( int32_t d ) const {
      return SIDL_bool__array_upper(
	reinterpret_cast<const struct SIDL_bool__array *>(d_array), d);
    }
    
    // get stride along particular dimension
    int32_t stride( int32_t d ) const {
      return SIDL_bool__array_stride(
	reinterpret_cast<const struct SIDL_bool__array *>(d_array), d);
    }

    // get
    bool get(int32_t i) {
      return SIDL_bool__array_get1(d_array,i) == TRUE;
    }

    // get
    bool get(int32_t i, int32_t j) {
      return SIDL_bool__array_get2(d_array,i,j) == TRUE;
    }

    // get
    bool get(int32_t i, int32_t j, int32_t k) {
      return SIDL_bool__array_get3(d_array,i,j,k) == TRUE;
    }

    // get
    bool get(int32_t i, int32_t j, int32_t k, int32_t l) {
      return SIDL_bool__array_get4(d_array,i,j,k,l) == TRUE;
    }

    // get
    bool get(const int32_t ind[]) {
      return SIDL_bool__array_get(d_array, ind) == TRUE;
    }

    // set
    void set(int32_t i, bool element) {
      SIDL_bool _local_element = ( element ) ? TRUE : FALSE;
      SIDL_bool__array_set1(d_array,i,_local_element);
    } 

    // set
    void set(int32_t i, int32_t j, bool element) {
      SIDL_bool _local_element = ( element ) ? TRUE : FALSE;
      SIDL_bool__array_set2(d_array,i,j,_local_element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, bool element) {
      SIDL_bool _local_element = ( element ) ? TRUE : FALSE;
      SIDL_bool__array_set3(d_array,i,j,k,_local_element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, int32_t l, bool element) {
      SIDL_bool _local_element = ( element ) ? TRUE : FALSE;
      SIDL_bool__array_set4(d_array,i,j,k,l,_local_element);
    }

    void set(int32_t ind[], bool element ) {
      SIDL_bool _local_element = ( element ) ? TRUE : FALSE;
      SIDL_bool__array_set(d_array,ind,_local_element);
    }
  };

  // Now the template classes for built-in types.
  template<> 
  class array< char > :
      public array_mixin< struct SIDL_char__array, char, char > { 
  public:
    // default constructor 
    array() : array_mixin< struct SIDL_char__array, char, char >() {} 

    // default destructor
    virtual ~array() {
      if ( d_array ) {
        SIDL_char__array_deleteRef( d_array );
      }
    }

    // copy constructor
    array( const array< char >& original ) { 
      d_array = original.d_array;
      if ( d_array ) { addRef(); }
    }

    // assignment operator
    array< char >& operator=( const array< char >& rhs ) { 
      if ( d_array != rhs.d_array ) { 
	if ( d_array ) { deleteRef(); }
	d_array=rhs.d_array;
	if ( d_array ) { addRef(); }
      }
      return *this;
    }

    // conversion from ior to C++ class
    // (constructor/casting operator)
    array( SIDL_char__array* src ) : array_mixin< struct SIDL_char__array, char, char >(src) {}


    void addRef() throw ( NullIORException ) {
      if ( d_array == 0 ) { 
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< char >::addRef()'"
        ));
      }
      SIDL_char__array_addRef( d_array );
    }

    void deleteRef() throw ( NullIORException ) {
      if ( d_array == 0 ) {
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< char >::deleteRef()'"
        ));
      }
      SIDL_char__array_deleteRef( d_array );
      d_array = 0;
    }
       
    // static constructor: createRow
    static array< char >
    createRow(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< char > retval;
      retval._set_ior(SIDL_char__array_createRow(dimen, lower, upper) );
      return retval;
    }
    
    static array< char >
    createCol(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< char > retval;
      retval._set_ior( SIDL_char__array_createCol(dimen, lower, upper) );
      return retval;
    }
    
    static array< char >
    create1d(int32_t len) {
      array< char > retval;
      retval._set_ior(SIDL_char__array_create1d( len ) );
      return retval;
    }

    static array< char >
    create2dCol(int32_t m, int32_t n ) {
      array< char > retval;
      retval._set_ior( SIDL_char__array_create2dCol(m,n) );
      return retval;
    }

    static array< char >
    create2dRow(int32_t m, int32_t n ) {
      array< char > retval;
      retval._set_ior( SIDL_char__array_create2dRow(m,n) );
      return retval;
    }

    array< char >
    slice( int32_t dimen,
           const int32_t newElem[],
           const int32_t *srcStart = 0,
           const int32_t *srcStride = 0,
           const int32_t *newStart = 0) {
      array< char > retval;
      retval._set_ior(  SIDL_char__array_slice( d_array, dimen, newElem,
                                           srcStart, srcStride, newStart ) );
      return retval;
    }
    
    // borrow
    void borrow( char * first_element, int32_t dimen,
      const int32_t lower[], const int32_t upper[], const int32_t stride[]) {
      d_array = SIDL_char__array_borrow(first_element, dimen, lower,
					upper, stride);
    }

    const char* first() const {
      return const_cast<const char*>(SIDL_char__array_first( _get_ior() ) );
    }

    char* first() {
      return SIDL_char__array_first( _get_ior() );
    }
    void copy( const array< char >& src ) {
      SIDL_char__array_copy( src._get_ior(), _get_ior() );
    }

    // smartCopy
    void smartCopy( ) {
       struct SIDL_char__array* p = SIDL_char__array_smartCopy( _get_ior() );
       if ( _not_nil() ) { deleteRef(); }
       _set_ior( p );
    }
    
    // ensure
    void ensure( int32_t dimen, int ordering ) {
      struct SIDL_char__array* p = SIDL_char__array_ensure( _get_ior(), dimen, ordering );
      if ( _not_nil() ) { deleteRef(); }
      _set_ior( p );
    }

    // isColumnOrder
    bool isColumnOrder() const {
      return SIDL_char__array_isColumnOrder( d_array ) == TRUE;
    }

    // isRowOrder
    bool isRowOrder() const {
      return SIDL_char__array_isRowOrder( d_array ) == TRUE;
    }

    // get dimension
    int32_t dimen() const { 
      return SIDL_char__array_dimen(
	reinterpret_cast<const struct SIDL_char__array *>(d_array));
    }
    
    // get lower bound along particular dimension
    int32_t lower( int32_t d ) const {
      return SIDL_char__array_lower(
	reinterpret_cast<const struct SIDL_char__array *>(d_array), d);
    } 
    
    // get upper bound along particular dimension
    int32_t upper( int32_t d ) const {
      return SIDL_char__array_upper(
	reinterpret_cast<const struct SIDL_char__array *>(d_array), d);
    }
    
    // get stride along particular dimension
    int32_t stride( int32_t d ) const {
      return SIDL_char__array_stride(
	reinterpret_cast<const struct SIDL_char__array *>(d_array), d);
    }

    // get
    char get(int32_t i) {
      return SIDL_char__array_get1(d_array,i);
    }

    // get
    char get(int32_t i, int32_t j) {
      return SIDL_char__array_get2(d_array,i,j);
    }

    // get
    char get(int32_t i, int32_t j, int32_t k) {
      return SIDL_char__array_get3(d_array,i,j,k);
    }

    // get
    char get(int32_t i, int32_t j, int32_t k, int32_t l) {
      return SIDL_char__array_get4(d_array,i,j,k,l);
    }

    // get
    char get(const int32_t ind[]) {
      return SIDL_char__array_get(d_array, ind);
    }

    // set
    void set(int32_t i, char element) {
      SIDL_char__array_set1(d_array,i,element);
    } 

    // set
    void set(int32_t i, int32_t j, char element) {
      SIDL_char__array_set2(d_array,i,j,element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, char element) {
      SIDL_char__array_set3(d_array,i,j,k,element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, int32_t l, char element) {
      SIDL_char__array_set4(d_array,i,j,k,l,element);
    }

    void set(int32_t ind[], char element ) {
      SIDL_char__array_set(d_array,ind,element);
    }
  };

  // Now the template classes for built-in types.
  template<> 
  class array< int32_t > :
      public array_mixin< struct SIDL_int__array, int32_t, int32_t > { 
  public:
    // default constructor 
    array() : array_mixin< struct SIDL_int__array, int32_t, int32_t >() {} 

    // default destructor
    virtual ~array() {
      if ( d_array ) {
        SIDL_int__array_deleteRef( d_array );
      }
    }

    // copy constructor
    array( const array< int32_t >& original ) { 
      d_array = original.d_array;
      if ( d_array ) { addRef(); }
    }

    // assignment operator
    array< int32_t >& operator=( const array< int32_t >& rhs ) { 
      if ( d_array != rhs.d_array ) { 
	if ( d_array ) { deleteRef(); }
	d_array=rhs.d_array;
	if ( d_array ) { addRef(); }
      }
      return *this;
    }

    // conversion from ior to C++ class
    // (constructor/casting operator)
    array( SIDL_int__array* src ) : array_mixin< struct SIDL_int__array, int32_t, int32_t >(src) {}


    void addRef() throw ( NullIORException ) {
      if ( d_array == 0 ) { 
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< int32_t >::addRef()'"
        ));
      }
      SIDL_int__array_addRef( d_array );
    }

    void deleteRef() throw ( NullIORException ) {
      if ( d_array == 0 ) {
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< int32_t >::deleteRef()'"
        ));
      }
      SIDL_int__array_deleteRef( d_array );
      d_array = 0;
    }
       
    // static constructor: createRow
    static array< int32_t >
    createRow(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< int32_t > retval;
      retval._set_ior(SIDL_int__array_createRow(dimen, lower, upper) );
      return retval;
    }
    
    static array< int32_t >
    createCol(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< int32_t > retval;
      retval._set_ior( SIDL_int__array_createCol(dimen, lower, upper) );
      return retval;
    }
    
    static array< int32_t >
    create1d(int32_t len) {
      array< int32_t > retval;
      retval._set_ior(SIDL_int__array_create1d( len ) );
      return retval;
    }

    static array< int32_t >
    create2dCol(int32_t m, int32_t n ) {
      array< int32_t > retval;
      retval._set_ior( SIDL_int__array_create2dCol(m,n) );
      return retval;
    }

    static array< int32_t >
    create2dRow(int32_t m, int32_t n ) {
      array< int32_t > retval;
      retval._set_ior( SIDL_int__array_create2dRow(m,n) );
      return retval;
    }

    array< int32_t >
    slice( int32_t dimen,
           const int32_t newElem[],
           const int32_t *srcStart = 0,
           const int32_t *srcStride = 0,
           const int32_t *newStart = 0) {
      array< int32_t > retval;
      retval._set_ior(  SIDL_int__array_slice( d_array, dimen, newElem,
                                           srcStart, srcStride, newStart ) );
      return retval;
    }
    
    // borrow
    void borrow( int32_t * first_element, int32_t dimen,
      const int32_t lower[], const int32_t upper[], const int32_t stride[]) {
      d_array = SIDL_int__array_borrow(first_element, dimen, lower,
					upper, stride);
    }

    const int32_t* first() const {
      return const_cast<const int32_t*>(SIDL_int__array_first( _get_ior() ) );
    }

    int32_t* first() {
      return SIDL_int__array_first( _get_ior() );
    }
    void copy( const array< int32_t >& src ) {
      SIDL_int__array_copy( src._get_ior(), _get_ior() );
    }

    // smartCopy
    void smartCopy( ) {
       struct SIDL_int__array* p = SIDL_int__array_smartCopy( _get_ior() );
       if ( _not_nil() ) { deleteRef(); }
       _set_ior( p );
    }
    
    // ensure
    void ensure( int32_t dimen, int ordering ) {
      struct SIDL_int__array* p = SIDL_int__array_ensure( _get_ior(), dimen, ordering );
      if ( _not_nil() ) { deleteRef(); }
      _set_ior( p );
    }

    // isColumnOrder
    bool isColumnOrder() const {
      return SIDL_int__array_isColumnOrder( d_array ) == TRUE;
    }

    // isRowOrder
    bool isRowOrder() const {
      return SIDL_int__array_isRowOrder( d_array ) == TRUE;
    }

    // get dimension
    int32_t dimen() const { 
      return SIDL_int__array_dimen(
	reinterpret_cast<const struct SIDL_int__array *>(d_array));
    }
    
    // get lower bound along particular dimension
    int32_t lower( int32_t d ) const {
      return SIDL_int__array_lower(
	reinterpret_cast<const struct SIDL_int__array *>(d_array), d);
    } 
    
    // get upper bound along particular dimension
    int32_t upper( int32_t d ) const {
      return SIDL_int__array_upper(
	reinterpret_cast<const struct SIDL_int__array *>(d_array), d);
    }
    
    // get stride along particular dimension
    int32_t stride( int32_t d ) const {
      return SIDL_int__array_stride(
	reinterpret_cast<const struct SIDL_int__array *>(d_array), d);
    }

    // get
    int32_t get(int32_t i) {
      return SIDL_int__array_get1(d_array,i);
    }

    // get
    int32_t get(int32_t i, int32_t j) {
      return SIDL_int__array_get2(d_array,i,j);
    }

    // get
    int32_t get(int32_t i, int32_t j, int32_t k) {
      return SIDL_int__array_get3(d_array,i,j,k);
    }

    // get
    int32_t get(int32_t i, int32_t j, int32_t k, int32_t l) {
      return SIDL_int__array_get4(d_array,i,j,k,l);
    }

    // get
    int32_t get(const int32_t ind[]) {
      return SIDL_int__array_get(d_array, ind);
    }

    // set
    void set(int32_t i, int32_t element) {
      SIDL_int__array_set1(d_array,i,element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t element) {
      SIDL_int__array_set2(d_array,i,j,element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, int32_t element) {
      SIDL_int__array_set3(d_array,i,j,k,element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, int32_t l, int32_t element) {
      SIDL_int__array_set4(d_array,i,j,k,l,element);
    }

    void set(int32_t ind[], int32_t element ) {
      SIDL_int__array_set(d_array,ind,element);
    }
  };

  // Now the template classes for built-in types.
  template<> 
  class array< int64_t > :
      public array_mixin< struct SIDL_long__array, int64_t, int64_t > { 
  public:
    // default constructor 
    array() : array_mixin< struct SIDL_long__array, int64_t, int64_t >() {} 

    // default destructor
    virtual ~array() {
      if ( d_array ) {
        SIDL_long__array_deleteRef( d_array );
      }
    }

    // copy constructor
    array( const array< int64_t >& original ) { 
      d_array = original.d_array;
      if ( d_array ) { addRef(); }
    }

    // assignment operator
    array< int64_t >& operator=( const array< int64_t >& rhs ) { 
      if ( d_array != rhs.d_array ) { 
	if ( d_array ) { deleteRef(); }
	d_array=rhs.d_array;
	if ( d_array ) { addRef(); }
      }
      return *this;
    }

    // conversion from ior to C++ class
    // (constructor/casting operator)
    array( SIDL_long__array* src ) : array_mixin< struct SIDL_long__array, int64_t, int64_t >(src) {}


    void addRef() throw ( NullIORException ) {
      if ( d_array == 0 ) { 
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< int64_t >::addRef()'"
        ));
      }
      SIDL_long__array_addRef( d_array );
    }

    void deleteRef() throw ( NullIORException ) {
      if ( d_array == 0 ) {
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< int64_t >::deleteRef()'"
        ));
      }
      SIDL_long__array_deleteRef( d_array );
      d_array = 0;
    }
       
    // static constructor: createRow
    static array< int64_t >
    createRow(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< int64_t > retval;
      retval._set_ior(SIDL_long__array_createRow(dimen, lower, upper) );
      return retval;
    }
    
    static array< int64_t >
    createCol(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< int64_t > retval;
      retval._set_ior( SIDL_long__array_createCol(dimen, lower, upper) );
      return retval;
    }
    
    static array< int64_t >
    create1d(int32_t len) {
      array< int64_t > retval;
      retval._set_ior(SIDL_long__array_create1d( len ) );
      return retval;
    }

    static array< int64_t >
    create2dCol(int32_t m, int32_t n ) {
      array< int64_t > retval;
      retval._set_ior( SIDL_long__array_create2dCol(m,n) );
      return retval;
    }

    static array< int64_t >
    create2dRow(int32_t m, int32_t n ) {
      array< int64_t > retval;
      retval._set_ior( SIDL_long__array_create2dRow(m,n) );
      return retval;
    }

    array< int64_t >
    slice( int32_t dimen,
           const int32_t newElem[],
           const int32_t *srcStart = 0,
           const int32_t *srcStride = 0,
           const int32_t *newStart = 0) {
      array< int64_t > retval;
      retval._set_ior(  SIDL_long__array_slice( d_array, dimen, newElem,
                                           srcStart, srcStride, newStart ) );
      return retval;
    }
    
    // borrow
    void borrow( int64_t * first_element, int32_t dimen,
      const int32_t lower[], const int32_t upper[], const int32_t stride[]) {
      d_array = SIDL_long__array_borrow(first_element, dimen, lower,
					upper, stride);
    }

    const int64_t* first() const {
      return const_cast<const int64_t*>(SIDL_long__array_first( _get_ior() ) );
    }

    int64_t* first() {
      return SIDL_long__array_first( _get_ior() );
    }
    void copy( const array< int64_t >& src ) {
      SIDL_long__array_copy( src._get_ior(), _get_ior() );
    }

    // smartCopy
    void smartCopy( ) {
       struct SIDL_long__array* p = SIDL_long__array_smartCopy( _get_ior() );
       if ( _not_nil() ) { deleteRef(); }
       _set_ior( p );
    }
    
    // ensure
    void ensure( int32_t dimen, int ordering ) {
      struct SIDL_long__array* p = SIDL_long__array_ensure( _get_ior(), dimen, ordering );
      if ( _not_nil() ) { deleteRef(); }
      _set_ior( p );
    }

    // isColumnOrder
    bool isColumnOrder() const {
      return SIDL_long__array_isColumnOrder( d_array ) == TRUE;
    }

    // isRowOrder
    bool isRowOrder() const {
      return SIDL_long__array_isRowOrder( d_array ) == TRUE;
    }

    // get dimension
    int32_t dimen() const { 
      return SIDL_long__array_dimen(
	reinterpret_cast<const struct SIDL_long__array *>(d_array));
    }
    
    // get lower bound along particular dimension
    int32_t lower( int32_t d ) const {
      return SIDL_long__array_lower(
	reinterpret_cast<const struct SIDL_long__array *>(d_array), d);
    } 
    
    // get upper bound along particular dimension
    int32_t upper( int32_t d ) const {
      return SIDL_long__array_upper(
	reinterpret_cast<const struct SIDL_long__array *>(d_array), d);
    }
    
    // get stride along particular dimension
    int32_t stride( int32_t d ) const {
      return SIDL_long__array_stride(
	reinterpret_cast<const struct SIDL_long__array *>(d_array), d);
    }

    // get
    int64_t get(int32_t i) {
      return SIDL_long__array_get1(d_array,i);
    }

    // get
    int64_t get(int32_t i, int32_t j) {
      return SIDL_long__array_get2(d_array,i,j);
    }

    // get
    int64_t get(int32_t i, int32_t j, int32_t k) {
      return SIDL_long__array_get3(d_array,i,j,k);
    }

    // get
    int64_t get(int32_t i, int32_t j, int32_t k, int32_t l) {
      return SIDL_long__array_get4(d_array,i,j,k,l);
    }

    // get
    int64_t get(const int32_t ind[]) {
      return SIDL_long__array_get(d_array, ind);
    }

    // set
    void set(int32_t i, int64_t element) {
      SIDL_long__array_set1(d_array,i,element);
    } 

    // set
    void set(int32_t i, int32_t j, int64_t element) {
      SIDL_long__array_set2(d_array,i,j,element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, int64_t element) {
      SIDL_long__array_set3(d_array,i,j,k,element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, int32_t l, int64_t element) {
      SIDL_long__array_set4(d_array,i,j,k,l,element);
    }

    void set(int32_t ind[], int64_t element ) {
      SIDL_long__array_set(d_array,ind,element);
    }
  };

  // Now the template classes for built-in types.
  template<> 
  class array< float > :
      public array_mixin< struct SIDL_float__array, float, float > { 
  public:
    // default constructor 
    array() : array_mixin< struct SIDL_float__array, float, float >() {} 

    // default destructor
    virtual ~array() {
      if ( d_array ) {
        SIDL_float__array_deleteRef( d_array );
      }
    }

    // copy constructor
    array( const array< float >& original ) { 
      d_array = original.d_array;
      if ( d_array ) { addRef(); }
    }

    // assignment operator
    array< float >& operator=( const array< float >& rhs ) { 
      if ( d_array != rhs.d_array ) { 
	if ( d_array ) { deleteRef(); }
	d_array=rhs.d_array;
	if ( d_array ) { addRef(); }
      }
      return *this;
    }

    // conversion from ior to C++ class
    // (constructor/casting operator)
    array( SIDL_float__array* src ) : array_mixin< struct SIDL_float__array, float, float >(src) {}


    void addRef() throw ( NullIORException ) {
      if ( d_array == 0 ) { 
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< float >::addRef()'"
        ));
      }
      SIDL_float__array_addRef( d_array );
    }

    void deleteRef() throw ( NullIORException ) {
      if ( d_array == 0 ) {
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< float >::deleteRef()'"
        ));
      }
      SIDL_float__array_deleteRef( d_array );
      d_array = 0;
    }
       
    // static constructor: createRow
    static array< float >
    createRow(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< float > retval;
      retval._set_ior(SIDL_float__array_createRow(dimen, lower, upper) );
      return retval;
    }
    
    static array< float >
    createCol(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< float > retval;
      retval._set_ior( SIDL_float__array_createCol(dimen, lower, upper) );
      return retval;
    }
    
    static array< float >
    create1d(int32_t len) {
      array< float > retval;
      retval._set_ior(SIDL_float__array_create1d( len ) );
      return retval;
    }

    static array< float >
    create2dCol(int32_t m, int32_t n ) {
      array< float > retval;
      retval._set_ior( SIDL_float__array_create2dCol(m,n) );
      return retval;
    }

    static array< float >
    create2dRow(int32_t m, int32_t n ) {
      array< float > retval;
      retval._set_ior( SIDL_float__array_create2dRow(m,n) );
      return retval;
    }

    array< float >
    slice( int32_t dimen,
           const int32_t newElem[],
           const int32_t *srcStart = 0,
           const int32_t *srcStride = 0,
           const int32_t *newStart = 0) {
      array< float > retval;
      retval._set_ior(  SIDL_float__array_slice( d_array, dimen, newElem,
                                           srcStart, srcStride, newStart ) );
      return retval;
    }
    
    // borrow
    void borrow( float * first_element, int32_t dimen,
      const int32_t lower[], const int32_t upper[], const int32_t stride[]) {
      d_array = SIDL_float__array_borrow(first_element, dimen, lower,
					upper, stride);
    }

    const float* first() const {
      return const_cast<const float*>(SIDL_float__array_first( _get_ior() ) );
    }

    float* first() {
      return SIDL_float__array_first( _get_ior() );
    }
    void copy( const array< float >& src ) {
      SIDL_float__array_copy( src._get_ior(), _get_ior() );
    }

    // smartCopy
    void smartCopy( ) {
       struct SIDL_float__array* p = SIDL_float__array_smartCopy( _get_ior() );
       if ( _not_nil() ) { deleteRef(); }
       _set_ior( p );
    }
    
    // ensure
    void ensure( int32_t dimen, int ordering ) {
      struct SIDL_float__array* p = SIDL_float__array_ensure( _get_ior(), dimen, ordering );
      if ( _not_nil() ) { deleteRef(); }
      _set_ior( p );
    }

    // isColumnOrder
    bool isColumnOrder() const {
      return SIDL_float__array_isColumnOrder( d_array ) == TRUE;
    }

    // isRowOrder
    bool isRowOrder() const {
      return SIDL_float__array_isRowOrder( d_array ) == TRUE;
    }

    // get dimension
    int32_t dimen() const { 
      return SIDL_float__array_dimen(
	reinterpret_cast<const struct SIDL_float__array *>(d_array));
    }
    
    // get lower bound along particular dimension
    int32_t lower( int32_t d ) const {
      return SIDL_float__array_lower(
	reinterpret_cast<const struct SIDL_float__array *>(d_array), d);
    } 
    
    // get upper bound along particular dimension
    int32_t upper( int32_t d ) const {
      return SIDL_float__array_upper(
	reinterpret_cast<const struct SIDL_float__array *>(d_array), d);
    }
    
    // get stride along particular dimension
    int32_t stride( int32_t d ) const {
      return SIDL_float__array_stride(
	reinterpret_cast<const struct SIDL_float__array *>(d_array), d);
    }

    // get
    float get(int32_t i) {
      return SIDL_float__array_get1(d_array,i);
    }

    // get
    float get(int32_t i, int32_t j) {
      return SIDL_float__array_get2(d_array,i,j);
    }

    // get
    float get(int32_t i, int32_t j, int32_t k) {
      return SIDL_float__array_get3(d_array,i,j,k);
    }

    // get
    float get(int32_t i, int32_t j, int32_t k, int32_t l) {
      return SIDL_float__array_get4(d_array,i,j,k,l);
    }

    // get
    float get(const int32_t ind[]) {
      return SIDL_float__array_get(d_array, ind);
    }

    // set
    void set(int32_t i, float element) {
      SIDL_float__array_set1(d_array,i,element);
    } 

    // set
    void set(int32_t i, int32_t j, float element) {
      SIDL_float__array_set2(d_array,i,j,element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, float element) {
      SIDL_float__array_set3(d_array,i,j,k,element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, int32_t l, float element) {
      SIDL_float__array_set4(d_array,i,j,k,l,element);
    }

    void set(int32_t ind[], float element ) {
      SIDL_float__array_set(d_array,ind,element);
    }
  };

  // Now the template classes for built-in types.
  template<> 
  class array< double > :
      public array_mixin< struct SIDL_double__array, double, double > { 
  public:
    // default constructor 
    array() : array_mixin< struct SIDL_double__array, double, double >() {} 

    // default destructor
    virtual ~array() {
      if ( d_array ) {
        SIDL_double__array_deleteRef( d_array );
      }
    }

    // copy constructor
    array( const array< double >& original ) { 
      d_array = original.d_array;
      if ( d_array ) { addRef(); }
    }

    // assignment operator
    array< double >& operator=( const array< double >& rhs ) { 
      if ( d_array != rhs.d_array ) { 
	if ( d_array ) { deleteRef(); }
	d_array=rhs.d_array;
	if ( d_array ) { addRef(); }
      }
      return *this;
    }

    // conversion from ior to C++ class
    // (constructor/casting operator)
    array( SIDL_double__array* src ) : array_mixin< struct SIDL_double__array, double, double >(src) {}


    void addRef() throw ( NullIORException ) {
      if ( d_array == 0 ) { 
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< double >::addRef()'"
        ));
      }
      SIDL_double__array_addRef( d_array );
    }

    void deleteRef() throw ( NullIORException ) {
      if ( d_array == 0 ) {
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< double >::deleteRef()'"
        ));
      }
      SIDL_double__array_deleteRef( d_array );
      d_array = 0;
    }
       
    // static constructor: createRow
    static array< double >
    createRow(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< double > retval;
      retval._set_ior(SIDL_double__array_createRow(dimen, lower, upper) );
      return retval;
    }
    
    static array< double >
    createCol(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< double > retval;
      retval._set_ior( SIDL_double__array_createCol(dimen, lower, upper) );
      return retval;
    }
    
    static array< double >
    create1d(int32_t len) {
      array< double > retval;
      retval._set_ior(SIDL_double__array_create1d( len ) );
      return retval;
    }

    static array< double >
    create2dCol(int32_t m, int32_t n ) {
      array< double > retval;
      retval._set_ior( SIDL_double__array_create2dCol(m,n) );
      return retval;
    }

    static array< double >
    create2dRow(int32_t m, int32_t n ) {
      array< double > retval;
      retval._set_ior( SIDL_double__array_create2dRow(m,n) );
      return retval;
    }

    array< double >
    slice( int32_t dimen,
           const int32_t newElem[],
           const int32_t *srcStart = 0,
           const int32_t *srcStride = 0,
           const int32_t *newStart = 0) {
      array< double > retval;
      retval._set_ior(  SIDL_double__array_slice( d_array, dimen, newElem,
                                           srcStart, srcStride, newStart ) );
      return retval;
    }
    
    // borrow
    void borrow( double * first_element, int32_t dimen,
      const int32_t lower[], const int32_t upper[], const int32_t stride[]) {
      d_array = SIDL_double__array_borrow(first_element, dimen, lower,
					upper, stride);
    }

    const double* first() const {
      return const_cast<const double*>(SIDL_double__array_first( _get_ior() ) );
    }

    double* first() {
      return SIDL_double__array_first( _get_ior() );
    }
    void copy( const array< double >& src ) {
      SIDL_double__array_copy( src._get_ior(), _get_ior() );
    }

    // smartCopy
    void smartCopy( ) {
       struct SIDL_double__array* p = SIDL_double__array_smartCopy( _get_ior() );
       if ( _not_nil() ) { deleteRef(); }
       _set_ior( p );
    }
    
    // ensure
    void ensure( int32_t dimen, int ordering ) {
      struct SIDL_double__array* p = SIDL_double__array_ensure( _get_ior(), dimen, ordering );
      if ( _not_nil() ) { deleteRef(); }
      _set_ior( p );
    }

    // isColumnOrder
    bool isColumnOrder() const {
      return SIDL_double__array_isColumnOrder( d_array ) == TRUE;
    }

    // isRowOrder
    bool isRowOrder() const {
      return SIDL_double__array_isRowOrder( d_array ) == TRUE;
    }

    // get dimension
    int32_t dimen() const { 
      return SIDL_double__array_dimen(
	reinterpret_cast<const struct SIDL_double__array *>(d_array));
    }
    
    // get lower bound along particular dimension
    int32_t lower( int32_t d ) const {
      return SIDL_double__array_lower(
	reinterpret_cast<const struct SIDL_double__array *>(d_array), d);
    } 
    
    // get upper bound along particular dimension
    int32_t upper( int32_t d ) const {
      return SIDL_double__array_upper(
	reinterpret_cast<const struct SIDL_double__array *>(d_array), d);
    }
    
    // get stride along particular dimension
    int32_t stride( int32_t d ) const {
      return SIDL_double__array_stride(
	reinterpret_cast<const struct SIDL_double__array *>(d_array), d);
    }

    // get
    double get(int32_t i) {
      return SIDL_double__array_get1(d_array,i);
    }

    // get
    double get(int32_t i, int32_t j) {
      return SIDL_double__array_get2(d_array,i,j);
    }

    // get
    double get(int32_t i, int32_t j, int32_t k) {
      return SIDL_double__array_get3(d_array,i,j,k);
    }

    // get
    double get(int32_t i, int32_t j, int32_t k, int32_t l) {
      return SIDL_double__array_get4(d_array,i,j,k,l);
    }

    // get
    double get(const int32_t ind[]) {
      return SIDL_double__array_get(d_array, ind);
    }

    // set
    void set(int32_t i, double element) {
      SIDL_double__array_set1(d_array,i,element);
    } 

    // set
    void set(int32_t i, int32_t j, double element) {
      SIDL_double__array_set2(d_array,i,j,element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, double element) {
      SIDL_double__array_set3(d_array,i,j,k,element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, int32_t l, double element) {
      SIDL_double__array_set4(d_array,i,j,k,l,element);
    }

    void set(int32_t ind[], double element ) {
      SIDL_double__array_set(d_array,ind,element);
    }
  };

  // Now the template classes for built-in types.
  template<> 
  class array< fcomplex > :
      public array_mixin< struct SIDL_fcomplex__array, struct SIDL_fcomplex, fcomplex > { 
  public:
    // default constructor 
    array() : array_mixin< struct SIDL_fcomplex__array, struct SIDL_fcomplex, fcomplex >() {} 

    // default destructor
    virtual ~array() {
      if ( d_array ) {
        SIDL_fcomplex__array_deleteRef( d_array );
      }
    }

    // copy constructor
    array( const array< fcomplex >& original ) { 
      d_array = original.d_array;
      if ( d_array ) { addRef(); }
    }

    // assignment operator
    array< fcomplex >& operator=( const array< fcomplex >& rhs ) { 
      if ( d_array != rhs.d_array ) { 
	if ( d_array ) { deleteRef(); }
	d_array=rhs.d_array;
	if ( d_array ) { addRef(); }
      }
      return *this;
    }

    // conversion from ior to C++ class
    // (constructor/casting operator)
    array( SIDL_fcomplex__array* src ) : array_mixin< struct SIDL_fcomplex__array, struct SIDL_fcomplex, fcomplex >(src) {}


    void addRef() throw ( NullIORException ) {
      if ( d_array == 0 ) { 
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< fcomplex >::addRef()'"
        ));
      }
      SIDL_fcomplex__array_addRef( d_array );
    }

    void deleteRef() throw ( NullIORException ) {
      if ( d_array == 0 ) {
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< fcomplex >::deleteRef()'"
        ));
      }
      SIDL_fcomplex__array_deleteRef( d_array );
      d_array = 0;
    }
       
    // static constructor: createRow
    static array< fcomplex >
    createRow(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< fcomplex > retval;
      retval._set_ior(SIDL_fcomplex__array_createRow(dimen, lower, upper) );
      return retval;
    }
    
    static array< fcomplex >
    createCol(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< fcomplex > retval;
      retval._set_ior( SIDL_fcomplex__array_createCol(dimen, lower, upper) );
      return retval;
    }
    
    static array< fcomplex >
    create1d(int32_t len) {
      array< fcomplex > retval;
      retval._set_ior(SIDL_fcomplex__array_create1d( len ) );
      return retval;
    }

    static array< fcomplex >
    create2dCol(int32_t m, int32_t n ) {
      array< fcomplex > retval;
      retval._set_ior( SIDL_fcomplex__array_create2dCol(m,n) );
      return retval;
    }

    static array< fcomplex >
    create2dRow(int32_t m, int32_t n ) {
      array< fcomplex > retval;
      retval._set_ior( SIDL_fcomplex__array_create2dRow(m,n) );
      return retval;
    }

    array< fcomplex >
    slice( int32_t dimen,
           const int32_t newElem[],
           const int32_t *srcStart = 0,
           const int32_t *srcStride = 0,
           const int32_t *newStart = 0) {
      array< fcomplex > retval;
      retval._set_ior(  SIDL_fcomplex__array_slice( d_array, dimen, newElem,
                                           srcStart, srcStride, newStart ) );
      return retval;
    }
    
    // borrow
    void borrow( struct SIDL_fcomplex * first_element, int32_t dimen,
      const int32_t lower[], const int32_t upper[], const int32_t stride[]) {
      d_array = SIDL_fcomplex__array_borrow(first_element, dimen, lower,
					upper, stride);
    }

    const struct SIDL_fcomplex* first() const {
      return const_cast<const struct SIDL_fcomplex*>(SIDL_fcomplex__array_first( _get_ior() ) );
    }

    struct SIDL_fcomplex* first() {
      return SIDL_fcomplex__array_first( _get_ior() );
    }
    void copy( const array< fcomplex >& src ) {
      SIDL_fcomplex__array_copy( src._get_ior(), _get_ior() );
    }

    // smartCopy
    void smartCopy( ) {
       struct SIDL_fcomplex__array* p = SIDL_fcomplex__array_smartCopy( _get_ior() );
       if ( _not_nil() ) { deleteRef(); }
       _set_ior( p );
    }
    
    // ensure
    void ensure( int32_t dimen, int ordering ) {
      struct SIDL_fcomplex__array* p = SIDL_fcomplex__array_ensure( _get_ior(), dimen, ordering );
      if ( _not_nil() ) { deleteRef(); }
      _set_ior( p );
    }

    // isColumnOrder
    bool isColumnOrder() const {
      return SIDL_fcomplex__array_isColumnOrder( d_array ) == TRUE;
    }

    // isRowOrder
    bool isRowOrder() const {
      return SIDL_fcomplex__array_isRowOrder( d_array ) == TRUE;
    }

    // get dimension
    int32_t dimen() const { 
      return SIDL_fcomplex__array_dimen(
	reinterpret_cast<const struct SIDL_fcomplex__array *>(d_array));
    }
    
    // get lower bound along particular dimension
    int32_t lower( int32_t d ) const {
      return SIDL_fcomplex__array_lower(
	reinterpret_cast<const struct SIDL_fcomplex__array *>(d_array), d);
    } 
    
    // get upper bound along particular dimension
    int32_t upper( int32_t d ) const {
      return SIDL_fcomplex__array_upper(
	reinterpret_cast<const struct SIDL_fcomplex__array *>(d_array), d);
    }
    
    // get stride along particular dimension
    int32_t stride( int32_t d ) const {
      return SIDL_fcomplex__array_stride(
	reinterpret_cast<const struct SIDL_fcomplex__array *>(d_array), d);
    }

    // get
    fcomplex get(int32_t i) {
      SIDL_fcomplex _local_result =
         SIDL_fcomplex__array_get1(d_array,i);
      return reinterpret_cast<fcomplex&>(_local_result);
    }

    // get
    fcomplex get(int32_t i, int32_t j) {
      SIDL_fcomplex _local_result =
         SIDL_fcomplex__array_get2(d_array,i,j);
      return reinterpret_cast<fcomplex&>(_local_result);
    }

    // get
    fcomplex get(int32_t i, int32_t j, int32_t k) {
      SIDL_fcomplex _local_result =
         SIDL_fcomplex__array_get3(d_array,i,j,k);
      return reinterpret_cast<fcomplex&>(_local_result);
    }

    // get
    fcomplex get(int32_t i, int32_t j, int32_t k, int32_t l) {
      SIDL_fcomplex _local_result =
         SIDL_fcomplex__array_get4(d_array,i,j,k,l);
      return reinterpret_cast<fcomplex&>(_local_result);
    }

    // get
    fcomplex get(const int32_t ind[]) {
      SIDL_fcomplex _local_result =
         SIDL_fcomplex__array_get(d_array, ind);
      return reinterpret_cast<fcomplex&>(_local_result);
    }

    // set
    void set(int32_t i, fcomplex element) {
      SIDL_fcomplex _local_element = { element.real(), element.imag() };
      SIDL_fcomplex__array_set1(d_array,i,_local_element);
    } 

    // set
    void set(int32_t i, int32_t j, fcomplex element) {
      SIDL_fcomplex _local_element = { element.real(), element.imag() };
      SIDL_fcomplex__array_set2(d_array,i,j,_local_element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, fcomplex element) {
      SIDL_fcomplex _local_element = { element.real(), element.imag() };
      SIDL_fcomplex__array_set3(d_array,i,j,k,_local_element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, int32_t l, fcomplex element) {
      SIDL_fcomplex _local_element = { element.real(), element.imag() };
      SIDL_fcomplex__array_set4(d_array,i,j,k,l,_local_element);
    }

    void set(int32_t ind[], fcomplex element ) {
      SIDL_fcomplex _local_element = { element.real(), element.imag() };
      SIDL_fcomplex__array_set(d_array,ind,_local_element);
    }
  };

  // Now the template classes for built-in types.
  template<> 
  class array< dcomplex > :
      public array_mixin< struct SIDL_dcomplex__array, struct SIDL_dcomplex, dcomplex > { 
  public:
    // default constructor 
    array() : array_mixin< struct SIDL_dcomplex__array, struct SIDL_dcomplex, dcomplex >() {} 

    // default destructor
    virtual ~array() {
      if ( d_array ) {
        SIDL_dcomplex__array_deleteRef( d_array );
      }
    }

    // copy constructor
    array( const array< dcomplex >& original ) { 
      d_array = original.d_array;
      if ( d_array ) { addRef(); }
    }

    // assignment operator
    array< dcomplex >& operator=( const array< dcomplex >& rhs ) { 
      if ( d_array != rhs.d_array ) { 
	if ( d_array ) { deleteRef(); }
	d_array=rhs.d_array;
	if ( d_array ) { addRef(); }
      }
      return *this;
    }

    // conversion from ior to C++ class
    // (constructor/casting operator)
    array( SIDL_dcomplex__array* src ) : array_mixin< struct SIDL_dcomplex__array, struct SIDL_dcomplex, dcomplex >(src) {}


    void addRef() throw ( NullIORException ) {
      if ( d_array == 0 ) { 
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< dcomplex >::addRef()'"
        ));
      }
      SIDL_dcomplex__array_addRef( d_array );
    }

    void deleteRef() throw ( NullIORException ) {
      if ( d_array == 0 ) {
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< dcomplex >::deleteRef()'"
        ));
      }
      SIDL_dcomplex__array_deleteRef( d_array );
      d_array = 0;
    }
       
    // static constructor: createRow
    static array< dcomplex >
    createRow(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< dcomplex > retval;
      retval._set_ior(SIDL_dcomplex__array_createRow(dimen, lower, upper) );
      return retval;
    }
    
    static array< dcomplex >
    createCol(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< dcomplex > retval;
      retval._set_ior( SIDL_dcomplex__array_createCol(dimen, lower, upper) );
      return retval;
    }
    
    static array< dcomplex >
    create1d(int32_t len) {
      array< dcomplex > retval;
      retval._set_ior(SIDL_dcomplex__array_create1d( len ) );
      return retval;
    }

    static array< dcomplex >
    create2dCol(int32_t m, int32_t n ) {
      array< dcomplex > retval;
      retval._set_ior( SIDL_dcomplex__array_create2dCol(m,n) );
      return retval;
    }

    static array< dcomplex >
    create2dRow(int32_t m, int32_t n ) {
      array< dcomplex > retval;
      retval._set_ior( SIDL_dcomplex__array_create2dRow(m,n) );
      return retval;
    }

    array< dcomplex >
    slice( int32_t dimen,
           const int32_t newElem[],
           const int32_t *srcStart = 0,
           const int32_t *srcStride = 0,
           const int32_t *newStart = 0) {
      array< dcomplex > retval;
      retval._set_ior(  SIDL_dcomplex__array_slice( d_array, dimen, newElem,
                                           srcStart, srcStride, newStart ) );
      return retval;
    }
    
    // borrow
    void borrow( struct SIDL_dcomplex * first_element, int32_t dimen,
      const int32_t lower[], const int32_t upper[], const int32_t stride[]) {
      d_array = SIDL_dcomplex__array_borrow(first_element, dimen, lower,
					upper, stride);
    }

    const struct SIDL_dcomplex* first() const {
      return const_cast<const struct SIDL_dcomplex*>(SIDL_dcomplex__array_first( _get_ior() ) );
    }

    struct SIDL_dcomplex* first() {
      return SIDL_dcomplex__array_first( _get_ior() );
    }
    void copy( const array< dcomplex >& src ) {
      SIDL_dcomplex__array_copy( src._get_ior(), _get_ior() );
    }

    // smartCopy
    void smartCopy( ) {
       struct SIDL_dcomplex__array* p = SIDL_dcomplex__array_smartCopy( _get_ior() );
       if ( _not_nil() ) { deleteRef(); }
       _set_ior( p );
    }
    
    // ensure
    void ensure( int32_t dimen, int ordering ) {
      struct SIDL_dcomplex__array* p = SIDL_dcomplex__array_ensure( _get_ior(), dimen, ordering );
      if ( _not_nil() ) { deleteRef(); }
      _set_ior( p );
    }

    // isColumnOrder
    bool isColumnOrder() const {
      return SIDL_dcomplex__array_isColumnOrder( d_array ) == TRUE;
    }

    // isRowOrder
    bool isRowOrder() const {
      return SIDL_dcomplex__array_isRowOrder( d_array ) == TRUE;
    }

    // get dimension
    int32_t dimen() const { 
      return SIDL_dcomplex__array_dimen(
	reinterpret_cast<const struct SIDL_dcomplex__array *>(d_array));
    }
    
    // get lower bound along particular dimension
    int32_t lower( int32_t d ) const {
      return SIDL_dcomplex__array_lower(
	reinterpret_cast<const struct SIDL_dcomplex__array *>(d_array), d);
    } 
    
    // get upper bound along particular dimension
    int32_t upper( int32_t d ) const {
      return SIDL_dcomplex__array_upper(
	reinterpret_cast<const struct SIDL_dcomplex__array *>(d_array), d);
    }
    
    // get stride along particular dimension
    int32_t stride( int32_t d ) const {
      return SIDL_dcomplex__array_stride(
	reinterpret_cast<const struct SIDL_dcomplex__array *>(d_array), d);
    }

    // get
    dcomplex get(int32_t i) {
      SIDL_dcomplex _local_result =
         SIDL_dcomplex__array_get1(d_array,i);
      return reinterpret_cast<dcomplex&>(_local_result);
    }

    // get
    dcomplex get(int32_t i, int32_t j) {
      SIDL_dcomplex _local_result =
         SIDL_dcomplex__array_get2(d_array,i,j);
      return reinterpret_cast<dcomplex&>(_local_result);
    }

    // get
    dcomplex get(int32_t i, int32_t j, int32_t k) {
      SIDL_dcomplex _local_result =
         SIDL_dcomplex__array_get3(d_array,i,j,k);
      return reinterpret_cast<dcomplex&>(_local_result);
    }

    // get
    dcomplex get(int32_t i, int32_t j, int32_t k, int32_t l) {
      SIDL_dcomplex _local_result =
         SIDL_dcomplex__array_get4(d_array,i,j,k,l);
      return reinterpret_cast<dcomplex&>(_local_result);
    }

    // get
    dcomplex get(const int32_t ind[]) {
      SIDL_dcomplex _local_result =
         SIDL_dcomplex__array_get(d_array, ind);
      return reinterpret_cast<dcomplex&>(_local_result);
    }

    // set
    void set(int32_t i, dcomplex element) {
      SIDL_dcomplex _local_element = { element.real(), element.imag() };
      SIDL_dcomplex__array_set1(d_array,i,_local_element);
    } 

    // set
    void set(int32_t i, int32_t j, dcomplex element) {
      SIDL_dcomplex _local_element = { element.real(), element.imag() };
      SIDL_dcomplex__array_set2(d_array,i,j,_local_element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, dcomplex element) {
      SIDL_dcomplex _local_element = { element.real(), element.imag() };
      SIDL_dcomplex__array_set3(d_array,i,j,k,_local_element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, int32_t l, dcomplex element) {
      SIDL_dcomplex _local_element = { element.real(), element.imag() };
      SIDL_dcomplex__array_set4(d_array,i,j,k,l,_local_element);
    }

    void set(int32_t ind[], dcomplex element ) {
      SIDL_dcomplex _local_element = { element.real(), element.imag() };
      SIDL_dcomplex__array_set(d_array,ind,_local_element);
    }
  };

  // Now the template classes for built-in types.
  template<> 
  class array< opaque > :
      public array_mixin< struct SIDL_opaque__array, void*, void* > { 
  public:
    // default constructor 
    array() : array_mixin< struct SIDL_opaque__array, void*, void* >() {} 

    // default destructor
    virtual ~array() {
      if ( d_array ) {
        SIDL_opaque__array_deleteRef( d_array );
      }
    }

    // copy constructor
    array( const array< opaque >& original ) { 
      d_array = original.d_array;
      if ( d_array ) { addRef(); }
    }

    // assignment operator
    array< opaque >& operator=( const array< opaque >& rhs ) { 
      if ( d_array != rhs.d_array ) { 
	if ( d_array ) { deleteRef(); }
	d_array=rhs.d_array;
	if ( d_array ) { addRef(); }
      }
      return *this;
    }

    // conversion from ior to C++ class
    // (constructor/casting operator)
    array( SIDL_opaque__array* src ) : array_mixin< struct SIDL_opaque__array, void*, void* >(src) {}


    void addRef() throw ( NullIORException ) {
      if ( d_array == 0 ) { 
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< opaque >::addRef()'"
        ));
      }
      SIDL_opaque__array_addRef( d_array );
    }

    void deleteRef() throw ( NullIORException ) {
      if ( d_array == 0 ) {
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< opaque >::deleteRef()'"
        ));
      }
      SIDL_opaque__array_deleteRef( d_array );
      d_array = 0;
    }
       
    // static constructor: createRow
    static array< opaque >
    createRow(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< opaque > retval;
      retval._set_ior(SIDL_opaque__array_createRow(dimen, lower, upper) );
      return retval;
    }
    
    static array< opaque >
    createCol(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< opaque > retval;
      retval._set_ior( SIDL_opaque__array_createCol(dimen, lower, upper) );
      return retval;
    }
    
    static array< opaque >
    create1d(int32_t len) {
      array< opaque > retval;
      retval._set_ior(SIDL_opaque__array_create1d( len ) );
      return retval;
    }

    static array< opaque >
    create2dCol(int32_t m, int32_t n ) {
      array< opaque > retval;
      retval._set_ior( SIDL_opaque__array_create2dCol(m,n) );
      return retval;
    }

    static array< opaque >
    create2dRow(int32_t m, int32_t n ) {
      array< opaque > retval;
      retval._set_ior( SIDL_opaque__array_create2dRow(m,n) );
      return retval;
    }

    array< opaque >
    slice( int32_t dimen,
           const int32_t newElem[],
           const int32_t *srcStart = 0,
           const int32_t *srcStride = 0,
           const int32_t *newStart = 0) {
      array< opaque > retval;
      retval._set_ior(  SIDL_opaque__array_slice( d_array, dimen, newElem,
                                           srcStart, srcStride, newStart ) );
      return retval;
    }
    
    // borrow
    void borrow( void* * first_element, int32_t dimen,
      const int32_t lower[], const int32_t upper[], const int32_t stride[]) {
      d_array = SIDL_opaque__array_borrow(first_element, dimen, lower,
					upper, stride);
    }

    const void** first() const {
      return const_cast<const void**>(SIDL_opaque__array_first( _get_ior() ) );
    }

    void** first() {
      return SIDL_opaque__array_first( _get_ior() );
    }
    void copy( const array< opaque >& src ) {
      SIDL_opaque__array_copy( src._get_ior(), _get_ior() );
    }

    // smartCopy
    void smartCopy( ) {
       struct SIDL_opaque__array* p = SIDL_opaque__array_smartCopy( _get_ior() );
       if ( _not_nil() ) { deleteRef(); }
       _set_ior( p );
    }
    
    // ensure
    void ensure( int32_t dimen, int ordering ) {
      struct SIDL_opaque__array* p = SIDL_opaque__array_ensure( _get_ior(), dimen, ordering );
      if ( _not_nil() ) { deleteRef(); }
      _set_ior( p );
    }

    // isColumnOrder
    bool isColumnOrder() const {
      return SIDL_opaque__array_isColumnOrder( d_array ) == TRUE;
    }

    // isRowOrder
    bool isRowOrder() const {
      return SIDL_opaque__array_isRowOrder( d_array ) == TRUE;
    }

    // get dimension
    int32_t dimen() const { 
      return SIDL_opaque__array_dimen(
	reinterpret_cast<const struct SIDL_opaque__array *>(d_array));
    }
    
    // get lower bound along particular dimension
    int32_t lower( int32_t d ) const {
      return SIDL_opaque__array_lower(
	reinterpret_cast<const struct SIDL_opaque__array *>(d_array), d);
    } 
    
    // get upper bound along particular dimension
    int32_t upper( int32_t d ) const {
      return SIDL_opaque__array_upper(
	reinterpret_cast<const struct SIDL_opaque__array *>(d_array), d);
    }
    
    // get stride along particular dimension
    int32_t stride( int32_t d ) const {
      return SIDL_opaque__array_stride(
	reinterpret_cast<const struct SIDL_opaque__array *>(d_array), d);
    }

    // get
    void* get(int32_t i) {
      return SIDL_opaque__array_get1(d_array,i);
    }

    // get
    void* get(int32_t i, int32_t j) {
      return SIDL_opaque__array_get2(d_array,i,j);
    }

    // get
    void* get(int32_t i, int32_t j, int32_t k) {
      return SIDL_opaque__array_get3(d_array,i,j,k);
    }

    // get
    void* get(int32_t i, int32_t j, int32_t k, int32_t l) {
      return SIDL_opaque__array_get4(d_array,i,j,k,l);
    }

    // get
    void* get(const int32_t ind[]) {
      return SIDL_opaque__array_get(d_array, ind);
    }

    // set
    void set(int32_t i, void* element) {
      SIDL_opaque__array_set1(d_array,i,element);
    } 

    // set
    void set(int32_t i, int32_t j, void* element) {
      SIDL_opaque__array_set2(d_array,i,j,element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, void* element) {
      SIDL_opaque__array_set3(d_array,i,j,k,element);
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, int32_t l, void* element) {
      SIDL_opaque__array_set4(d_array,i,j,k,l,element);
    }

    void set(int32_t ind[], void* element ) {
      SIDL_opaque__array_set(d_array,ind,element);
    }
  };

  // Now the template classes for built-in types.
  template<> 
  class array< string > :
      public array_mixin< struct SIDL_string__array, char*, string > { 
  public:
    // default constructor 
    array() : array_mixin< struct SIDL_string__array, char*, string >() {} 

    // default destructor
    virtual ~array() {
      if ( d_array ) {
        SIDL_string__array_deleteRef( d_array );
      }
    }

    // copy constructor
    array( const array< string >& original ) { 
      d_array = original.d_array;
      if ( d_array ) { addRef(); }
    }

    // assignment operator
    array< string >& operator=( const array< string >& rhs ) { 
      if ( d_array != rhs.d_array ) { 
	if ( d_array ) { deleteRef(); }
	d_array=rhs.d_array;
	if ( d_array ) { addRef(); }
      }
      return *this;
    }

    // conversion from ior to C++ class
    // (constructor/casting operator)
    array( SIDL_string__array* src ) : array_mixin< struct SIDL_string__array, char*, string >(src) {}


    void addRef() throw ( NullIORException ) {
      if ( d_array == 0 ) { 
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< string >::addRef()'"
        ));
      }
      SIDL_string__array_addRef( d_array );
    }

    void deleteRef() throw ( NullIORException ) {
      if ( d_array == 0 ) {
        throw NullIORException( ::std::string(
          "Null IOR Pointer in 'array< string >::deleteRef()'"
        ));
      }
      SIDL_string__array_deleteRef( d_array );
      d_array = 0;
    }
       
    // static constructor: createRow
    static array< string >
    createRow(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< string > retval;
      retval._set_ior(SIDL_string__array_createRow(dimen, lower, upper) );
      return retval;
    }
    
    static array< string >
    createCol(int32_t dimen, const int32_t lower[], const int32_t upper[]) {
      array< string > retval;
      retval._set_ior( SIDL_string__array_createCol(dimen, lower, upper) );
      return retval;
    }
    
    static array< string >
    create1d(int32_t len) {
      array< string > retval;
      retval._set_ior(SIDL_string__array_create1d( len ) );
      return retval;
    }

    static array< string >
    create2dCol(int32_t m, int32_t n ) {
      array< string > retval;
      retval._set_ior( SIDL_string__array_create2dCol(m,n) );
      return retval;
    }

    static array< string >
    create2dRow(int32_t m, int32_t n ) {
      array< string > retval;
      retval._set_ior( SIDL_string__array_create2dRow(m,n) );
      return retval;
    }

    array< string >
    slice( int32_t dimen,
           const int32_t newElem[],
           const int32_t *srcStart = 0,
           const int32_t *srcStride = 0,
           const int32_t *newStart = 0) {
      array< string > retval;
      retval._set_ior(  SIDL_string__array_slice( d_array, dimen, newElem,
                                           srcStart, srcStride, newStart ) );
      return retval;
    }
    
    // borrow
    void borrow( char* * first_element, int32_t dimen,
      const int32_t lower[], const int32_t upper[], const int32_t stride[]) {
      d_array = SIDL_string__array_borrow(first_element, dimen, lower,
					upper, stride);
    }

    /*
     const char** first() const {
      return const_cast<const char**>(SIDL_string__array_first( _get_ior() ) );
    }

    char** first() {
      return SIDL_string__array_first( _get_ior() );
    }
    */

    void copy( const array< string >& src ) {
      SIDL_string__array_copy( src._get_ior(), _get_ior() );
    }

    // smartCopy
    void smartCopy( ) {
       struct SIDL_string__array* p = SIDL_string__array_smartCopy( _get_ior() );
       if ( _not_nil() ) { deleteRef(); }
       _set_ior( p );
    }
    
    // ensure
    void ensure( int32_t dimen, int ordering ) {
      struct SIDL_string__array* p = SIDL_string__array_ensure( _get_ior(), dimen, ordering );
      if ( _not_nil() ) { deleteRef(); }
      _set_ior( p );
    }

    // isColumnOrder
    bool isColumnOrder() const {
      return SIDL_string__array_isColumnOrder( d_array ) == TRUE;
    }

    // isRowOrder
    bool isRowOrder() const {
      return SIDL_string__array_isRowOrder( d_array ) == TRUE;
    }

    // get dimension
    int32_t dimen() const { 
      return SIDL_string__array_dimen(
	reinterpret_cast<const struct SIDL_string__array *>(d_array));
    }
    
    // get lower bound along particular dimension
    int32_t lower( int32_t d ) const {
      return SIDL_string__array_lower(
	reinterpret_cast<const struct SIDL_string__array *>(d_array), d);
    } 
    
    // get upper bound along particular dimension
    int32_t upper( int32_t d ) const {
      return SIDL_string__array_upper(
	reinterpret_cast<const struct SIDL_string__array *>(d_array), d);
    }
    
    // get stride along particular dimension
    int32_t stride( int32_t d ) const {
      return SIDL_string__array_stride(
	reinterpret_cast<const struct SIDL_string__array *>(d_array), d);
    }

    // get
    string get(int32_t i) {
      // special case:
      // must make a local copy, since return value
      // must be free'd
      string s;
      char *tmp =  SIDL_string__array_get1(d_array,i);
      if (tmp) {
        s = tmp;
        free(tmp);
      }
      return s;
    }

    // get
    string get(int32_t i, int32_t j) {
      // special case:
      // must make a local copy, since return value
      // must be free'd
      string s;
      char *tmp =  SIDL_string__array_get2(d_array,i,j);
      if (tmp) {
        s = tmp;
        free(tmp);
      }
      return s;
    }

    // get
    string get(int32_t i, int32_t j, int32_t k) {
      // special case:
      // must make a local copy, since return value
      // must be free'd
      string s;
      char *tmp =  SIDL_string__array_get3(d_array,i,j,k);
      if (tmp) {
        s = tmp;
        free(tmp);
      }
      return s;
    }

    // get
    string get(int32_t i, int32_t j, int32_t k, int32_t l) {
      // special case:
      // must make a local copy, since return value
      // must be free'd
      string s;
      char *tmp =  SIDL_string__array_get4(d_array,i,j,k,l);
      if (tmp) {
        s = tmp;
        free(tmp);
      }
      return s;
    }

    // get
    string get(const int32_t ind[]) {
      // special case:
      // must make a local copy, since return value
      // must be free'd
      string s;
      char *tmp =  SIDL_string__array_get(d_array, ind);
      if (tmp) {
        s = tmp;
        free(tmp);
      }
      return s;
    }

    // set
    void set(int32_t i, string element) {
      SIDL_string__array_set1(d_array,i,element.c_str());
    } 

    // set
    void set(int32_t i, int32_t j, string element) {
      SIDL_string__array_set2(d_array,i,j,element.c_str());
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, string element) {
      SIDL_string__array_set3(d_array,i,j,k,element.c_str());
    } 

    // set
    void set(int32_t i, int32_t j, int32_t k, int32_t l, string element) {
      SIDL_string__array_set4(d_array,i,j,k,l,element.c_str());
    }

    void set(int32_t ind[], string element ) {
      SIDL_string__array_set(d_array,ind,element.c_str());
    }
  };

}

#endif // defined included_SIDL_cxx_hh
