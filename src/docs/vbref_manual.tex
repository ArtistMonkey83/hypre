\documentclass{article}
\usepackage{docxx}
\begin{document}
\pagebreak
\sloppy
\cxxVersion{
2.4.0b\strut}
\cxxTitle{}
        {{\it hypre} Reference Manual: \linebreak Babel-based Interface in C}
        {}
        {
}
        {}
\begin{cxxContents}
\cxxContentsEntry{1}{Matrix and Vector Views (Conceptual Interfaces)}{
}
\begin{cxxContents}
\cxxContentsEntry{1.1}{IJ Matrix View}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{1.2}{IJ Vector View}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{1.3}{Struct Matrix View}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{1.4}{Struct Vector View}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{1.5}{SemiStructured Matrix View}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{1.6}{SemiStructured Vector View}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{2}{Operator Interface}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{3}{Vector Interface}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4}{Matrices and Vectors}{
}
\begin{cxxContents}
\cxxContentsEntry{4.1}{IJParCSR Matrix}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.2}{IJParCSR Vector}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.3}{Struct Matrix}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.4}{Struct Vector}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.5}{SemiStructured Matrix}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.6}{SemiStructured Vector}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.7}{SemiStructured ParCSR Matrix}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.8}{SemiStructured ParCSR Vector}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{5}{Solver Interface}{
}
\begin{cxxContents}
\cxxContentsEntry{5.9}{Identity Solver (does nothing)}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{5.10}{Hybrid Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6}{ParCSR Matrix Solvers}{Linear solvers for sparse matrix systems}
\begin{cxxContents}
\cxxContentsEntry{6.1}{ParCSRDiagScale Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.2}{ParCSR BoomerAMG Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.3}{ParCSR Euclid Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.4}{ParCSR Schwarz Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.5}{ParCSR ParaSails Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.6}{ParCSR Pilut Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{7}{Structured Matrix Solvers}{Linear solvers for struct matrix systems}
\begin{cxxContents}
\cxxContentsEntry{7.1}{StructDiagScale Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{7.2}{Struct Jacobi Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{7.3}{Struct PFMG Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{7.4}{Struct SMG Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{8}{SemiStructured Matrix Solvers}{Linear solvers for semi-struct matrix systems}
\begin{cxxContents}
\cxxContentsEntry{8.1}{SemiStruct DiagScale Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{8.2}{Struct Split Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{9}{PreconditionedSolver Interface}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{10}{Preconditioned Solvers}{
}
\begin{cxxContents}
\cxxContentsEntry{10.1}{PCG Preconditioned Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{10.2}{GMRES Preconditioned Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{10.3}{BiCGSTAB Preconditioned Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{10.4}{CGNR Preconditioned Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{11}{Other}{
}
\begin{cxxContents}
\cxxContentsEntry{11.1}{MPI Communicator}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{12}{Struct Grid, etc.}{
}
\begin{cxxContents}
\cxxContentsEntry{12.1}{Struct Grid}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{12.2}{Struct Stencil}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{13}{Semi-Structured Grid, etc.}{
}
\begin{cxxContents}
\cxxContentsEntry{13.1}{Semi-Structured Graph}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{13.2}{Semi-Structured Grid}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{13.3}{Semi-Structured Stencil}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{13.4}{Semi-Structured Variable}{
}
\begin{cxxContents}
\cxxContentsEntry{13.4.1}{bHYPRE\_SStructVariable\_\_enum}{
Symbol "bHYPRE}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{}{Class Graph}{}\end{cxxContents}
\clearpage\pagebreak
\begin{cxxdoc}



Copyright (c) 2008,  Lawrence Livermore National Security, LLC.
Produced at the Lawrence Livermore National Laboratory.
This file is part of HYPRE.  See file COPYRIGHT for details.

HYPRE is free software; you can redistribute it and/or modify it under the
terms of the GNU Lesser General Public License (as published by the Free
Software Foundation) version 2.1 dated February 1999.


\end{cxxdoc}
\begin{cxxentry}
{}
        {Matrix and Vector Views (Conceptual Interfaces)}
        {}
        {
}
        {1}
\begin{cxxnames}
\cxxitem{}
        {IJ Matrix View}
        {}
        {
}
        {1.1}
\cxxitem{}
        {IJ Vector View}
        {}
        {
}
        {1.2}
\cxxitem{}
        {Struct Matrix View}
        {}
        {
}
        {1.3}
\cxxitem{}
        {Struct Vector View}
        {}
        {
}
        {1.4}
\cxxitem{}
        {SemiStructured Matrix View}
        {}
        {
}
        {1.5}
\cxxitem{}
        {SemiStructured Vector View}
        {}
        {
}
        {1.6}
\end{cxxnames}
\begin{cxxentry}
{}
        {IJ Matrix View}
        {}
        {
}
        {1.1}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_IJMatrixView\_\_object}
        {}
        {
Symbol "bHYPRE}
        {1.1.1}
\cxxitem{extern\ \ C\ \ bHYPRE\_IJMatrixView\ }
        {bHYPRE\_IJMatrixView\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {1.1.2}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJMatrixView\_SetLocalRange}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ int32\_t\ ilower,\ \ int32\_t\ iupper,\ \ int32\_t\ jlower,\ \ int32\_t\ jupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the local range for a matrix object}
        {1.1.3}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJMatrixView\_SetValues}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ int32\_t\ nrows,\ \ int32\_t*\ ncols,\ \ int32\_t*\ rows,\ \ int32\_t*\ cols,\ \ double*\ values,\ \ int32\_t\ nnonzeros,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Sets values for {\tt nrows} of the matrix}
        {1.1.4}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJMatrixView\_AddToValues}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ int32\_t\ nrows,\ \ int32\_t*\ ncols,\ \ int32\_t*\ rows,\ \ int32\_t*\ cols,\ \ double*\ values,\ \ int32\_t\ nnonzeros,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Adds to values for {\tt nrows} of the matrix}
        {1.1.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJMatrixView\_GetLocalRange}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t*\ jlower,\ \ int32\_t*\ jupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gets range of rows owned by this processor and range of
column partitioning for this processor}
        {}
\label{cxx.1.1.11}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJMatrixView\_GetRowCounts}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ int32\_t\ nrows,\ \ int32\_t*\ rows,\ \ int32\_t*\ ncols,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gets number of nonzeros elements for {\tt nrows} rows
specified in {\tt rows} and returns them in {\tt ncols},
which needs to be allocated by the user}
        {}
\label{cxx.1.1.12}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJMatrixView\_GetValues}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ int32\_t\ nrows,\ \ int32\_t*\ ncols,\ \ int32\_t*\ rows,\ \ int32\_t*\ cols,\ \ double*\ values,\ \ int32\_t\ nnonzeros,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gets values for {\tt nrows} rows or partial rows of the
matrix}
        {1.1.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJMatrixView\_SetRowSizes}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ int32\_t*\ sizes,\ \ int32\_t\ nrows,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the max number of nonzeros to expect in each
row}
        {1.1.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJMatrixView\_Print}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ const\ char*\ filename,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the matrix to file}
        {1.1.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJMatrixView\_Read}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ const\ char*\ filename,\ \ bHYPRE\_MPICommunicator\ comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Read the matrix from file}
        {1.1.9}
\cxxitem{\ struct\ \ bHYPRE\_IJMatrixView\_\_object*\ bHYPRE\_IJMatrixView\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.1.1.13}
\cxxitem{void*\ }
        {bHYPRE\_IJMatrixView\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.1.1.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IJMatrixView\_\_exec}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.1.1.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_IJMatrixView\_\_getURL}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.1.1.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IJMatrixView\_\_raddRef}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.1.1.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_IJMatrixView\_\_isRemote}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.1.1.18}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_IJMatrixView\_\_isLocal}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.1.1.19}
\cxxitem{\ struct\ \ bHYPRE\_IJMatrixView\_\_object*\ bHYPRE\_IJMatrixView\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.1.1.20}
\cxxitem{\ struct\ \ bHYPRE\_IJMatrixView\_\_object*\ bHYPRE\_IJMatrixView\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {1.1.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_IJMatrixView\_\_object}
        {}
        {
Symbol "bHYPRE}
        {1.1.1}
\begin{cxxdoc}

Symbol "bHYPRE.IJMatrixView" (version 1.0.0)

This interface represents a linear-algebraic conceptual view of a
linear system.  The 'I' and 'J' in the name are meant to be
mnemonic for the traditional matrix notation A(I,J).
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{extern\ \ C\ \ bHYPRE\_IJMatrixView\ }
        {bHYPRE\_IJMatrixView\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {1.1.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJMatrixView\_SetLocalRange}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ int32\_t\ ilower,\ \ int32\_t\ iupper,\ \ int32\_t\ jlower,\ \ int32\_t\ jupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the local range for a matrix object}
        {1.1.3}
\begin{cxxdoc}

Set the local range for a matrix object.  Each process owns
some unique consecutive range of rows, indicated by the
global row indices {\tt ilower} and {\tt iupper}.  The row
data is required to be such that the value of {\tt ilower} on
any process $p$ be exactly one more than the value of {\tt
iupper} on process $p-1$.  Note that the first row of the
global matrix may start with any integer value.  In
particular, one may use zero- or one-based indexing.

For square matrices, {\tt jlower} and {\tt jupper} typically
should match {\tt ilower} and {\tt iupper}, respectively.
For rectangular matrices, {\tt jlower} and {\tt jupper}
should define a partitioning of the columns.  This
partitioning must be used for any vector $v$ that will be
used in matrix-vector products with the rectangular matrix.
The matrix data structure may use {\tt jlower} and {\tt
jupper} to store the diagonal blocks (rectangular in general)
of the matrix separately from the rest of the matrix.

Collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_IJMatrixView\_SetValues}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ int32\_t\ nrows,\ \ int32\_t*\ ncols,\ \ int32\_t*\ rows,\ \ int32\_t*\ cols,\ \ double*\ values,\ \ int32\_t\ nnonzeros,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Sets values for {\tt nrows} of the matrix}
        {1.1.4}
\begin{cxxdoc}

Sets values for {\tt nrows} of the matrix.  The arrays {\tt
ncols} and {\tt rows} are of dimension {\tt nrows} and
contain the number of columns in each row and the row
indices, respectively.  The array {\tt cols} contains the
column indices for each of the {\tt rows}, and is ordered by
rows.  The data in the {\tt values} array corresponds
directly to the column entries in {\tt cols}.  The last argument
is the size of the cols and values arrays, i.e. the total number
of nonzeros being provided, i.e. the sum of all values in ncols.
This functin erases any previous values at the specified locations and
replaces them with new ones, or, if there was no value there before,
inserts a new one.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_IJMatrixView\_AddToValues}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ int32\_t\ nrows,\ \ int32\_t*\ ncols,\ \ int32\_t*\ rows,\ \ int32\_t*\ cols,\ \ double*\ values,\ \ int32\_t\ nnonzeros,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Adds to values for {\tt nrows} of the matrix}
        {1.1.5}
\begin{cxxdoc}

Adds to values for {\tt nrows} of the matrix.  Usage details
are analogous to {\tt SetValues}.  Adds to any previous
values at the specified locations, or, if there was no value
there before, inserts a new one.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_IJMatrixView\_GetValues}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ int32\_t\ nrows,\ \ int32\_t*\ ncols,\ \ int32\_t*\ rows,\ \ int32\_t*\ cols,\ \ double*\ values,\ \ int32\_t\ nnonzeros,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gets values for {\tt nrows} rows or partial rows of the
matrix}
        {1.1.6}
\begin{cxxdoc}

Gets values for {\tt nrows} rows or partial rows of the
matrix.  Usage details are analogous to {\tt SetValues}.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJMatrixView\_SetRowSizes}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ int32\_t*\ sizes,\ \ int32\_t\ nrows,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the max number of nonzeros to expect in each
row}
        {1.1.7}
\begin{cxxdoc}

(Optional) Set the max number of nonzeros to expect in each
row.  The array {\tt sizes} contains estimated sizes for each
row on this process.  The integer nrows is the number of rows in
the local matrix.  This call can significantly improve the
efficiency of matrix construction, and should always be
utilized if possible.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJMatrixView\_Print}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ const\ char*\ filename,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the matrix to file}
        {1.1.8}
\begin{cxxdoc}

Print the matrix to file.  This is mainly for debugging
purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJMatrixView\_Read}
        {(\ \ bHYPRE\_IJMatrixView\ self,\ \ const\ char*\ filename,\ \ bHYPRE\_MPICommunicator\ comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Read the matrix from file}
        {1.1.9}
\begin{cxxdoc}

Read the matrix from file.  This is mainly for debugging
purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_IJMatrixView\_\_object*\ bHYPRE\_IJMatrixView\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {1.1.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {IJ Vector View}
        {}
        {
}
        {1.2}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_IJVectorView\_\_object}
        {}
        {
Symbol "bHYPRE}
        {1.2.1}
\cxxitem{extern\ \ C\ \ bHYPRE\_IJVectorView\ }
        {bHYPRE\_IJVectorView\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {1.2.2}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJVectorView\_SetLocalRange}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ int32\_t\ jlower,\ \ int32\_t\ jupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the local range for a vector object}
        {1.2.3}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJVectorView\_SetValues}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ int32\_t\ nvalues,\ \ int32\_t*\ indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Sets values in vector}
        {1.2.4}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJVectorView\_AddToValues}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ int32\_t\ nvalues,\ \ int32\_t*\ indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Adds to values in vector}
        {1.2.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJVectorView\_GetLocalRange}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ int32\_t*\ jlower,\ \ int32\_t*\ jupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Returns range of the part of the vector owned by this
processor}
        {}
\label{cxx.1.2.10}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJVectorView\_GetValues}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ int32\_t\ nvalues,\ \ int32\_t*\ indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gets values in vector}
        {1.2.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJVectorView\_Print}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ const\ char*\ filename,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the vector to file}
        {1.2.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJVectorView\_Read}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ const\ char*\ filename,\ \ bHYPRE\_MPICommunicator\ comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Read the vector from file}
        {1.2.8}
\cxxitem{\ struct\ \ bHYPRE\_IJVectorView\_\_object*\ bHYPRE\_IJVectorView\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.1.2.11}
\cxxitem{void*\ }
        {bHYPRE\_IJVectorView\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.1.2.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IJVectorView\_\_exec}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.1.2.13}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_IJVectorView\_\_getURL}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.1.2.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IJVectorView\_\_raddRef}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.1.2.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_IJVectorView\_\_isRemote}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.1.2.16}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_IJVectorView\_\_isLocal}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.1.2.17}
\cxxitem{\ struct\ \ bHYPRE\_IJVectorView\_\_object*\ bHYPRE\_IJVectorView\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.1.2.18}
\cxxitem{\ struct\ \ bHYPRE\_IJVectorView\_\_object*\ bHYPRE\_IJVectorView\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {1.2.9}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_IJVectorView\_\_object}
        {}
        {
Symbol "bHYPRE}
        {1.2.1}
\begin{cxxdoc}

Symbol "bHYPRE.IJVectorView" (version 1.0.0)
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{extern\ \ C\ \ bHYPRE\_IJVectorView\ }
        {bHYPRE\_IJVectorView\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {1.2.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJVectorView\_SetLocalRange}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ int32\_t\ jlower,\ \ int32\_t\ jupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the local range for a vector object}
        {1.2.3}
\begin{cxxdoc}

Set the local range for a vector object.  Each process owns
some unique consecutive range of vector unknowns, indicated
by the global indices {\tt jlower} and {\tt jupper}.  The
data is required to be such that the value of {\tt jlower} on
any process $p$ be exactly one more than the value of {\tt
jupper} on process $p-1$.  Note that the first index of the
global vector may start with any integer value.  In
particular, one may use zero- or one-based indexing.

Collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_IJVectorView\_SetValues}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ int32\_t\ nvalues,\ \ int32\_t*\ indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Sets values in vector}
        {1.2.4}
\begin{cxxdoc}

Sets values in vector.  The arrays {\tt values} and {\tt
indices} are of dimension {\tt nvalues} and contain the
vector values to be set and the corresponding global vector
indices, respectively.  Erases any previous values at the
specified locations and replaces them with new ones.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_IJVectorView\_AddToValues}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ int32\_t\ nvalues,\ \ int32\_t*\ indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Adds to values in vector}
        {1.2.5}
\begin{cxxdoc}

Adds to values in vector.  Usage details are analogous to
{\tt SetValues}.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_IJVectorView\_GetValues}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ int32\_t\ nvalues,\ \ int32\_t*\ indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gets values in vector}
        {1.2.6}
\begin{cxxdoc}

Gets values in vector.  Usage details are analogous to {\tt
SetValues}.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJVectorView\_Print}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ const\ char*\ filename,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the vector to file}
        {1.2.7}
\begin{cxxdoc}

Print the vector to file.  This is mainly for debugging
purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJVectorView\_Read}
        {(\ \ bHYPRE\_IJVectorView\ self,\ \ const\ char*\ filename,\ \ bHYPRE\_MPICommunicator\ comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Read the vector from file}
        {1.2.8}
\begin{cxxdoc}

Read the vector from file.  This is mainly for debugging
purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_IJVectorView\_\_object*\ bHYPRE\_IJVectorView\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {1.2.9}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct Matrix View}
        {}
        {
}
        {1.3}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_StructMatrixView\_\_object}
        {}
        {
Symbol "bHYPRE}
        {1.3.1}
\cxxitem{extern\ \ C\ \ bHYPRE\_StructMatrixView\ }
        {bHYPRE\_StructMatrixView\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {1.3.2}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetGrid}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ bHYPRE\_StructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the grid on which vectors are defined}
        {1.3.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetStencil}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ bHYPRE\_StructStencil\ stencil,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the stencil}
        {1.3.4}
\cxxitem{int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetValues}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ num\_stencil\_indices,\ \ int32\_t*\ stencil\_indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix values at grid point, given by "index"}
        {1.3.5}
\cxxitem{int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetBoxValues}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ num\_stencil\_indices,\ \ int32\_t*\ stencil\_indices,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix values throughout a box in the grid, specified by its lower
and upper corners}
        {1.3.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetNumGhost}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ int32\_t*\ num\_ghost,\ \ int32\_t\ dim2,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of ghost zones, separately on the lower and upper sides
for each dimension}
        {1.3.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetSymmetric}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ int32\_t\ symmetric,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Call SetSymmetric with symmetric=1 to turn on symmetric matrix storage if
available}
        {}
\label{cxx.1.3.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetConstantEntries}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ int32\_t\ num\_stencil\_constant\_points,\ \ int32\_t*\ stencil\_constant\_points,\ \ sidl\_BaseInterface\ *\_ex)}
        {
State which stencil entries are constant over the grid}
        {1.3.8}
\cxxitem{int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetConstantValues}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ int32\_t\ num\_stencil\_indices,\ \ int32\_t*\ stencil\_indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Provide values for matrix coefficients which are constant throughout
the grid, one value for each stencil point}
        {1.3.9}
\cxxitem{\ struct\ \ bHYPRE\_StructMatrixView\_\_object*\ bHYPRE\_StructMatrixView\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.1.3.12}
\cxxitem{void*\ }
        {bHYPRE\_StructMatrixView\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.1.3.13}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructMatrixView\_\_exec}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.1.3.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_StructMatrixView\_\_getURL}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.1.3.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructMatrixView\_\_raddRef}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.1.3.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_StructMatrixView\_\_isRemote}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.1.3.17}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_StructMatrixView\_\_isLocal}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.1.3.18}
\cxxitem{\ struct\ \ bHYPRE\_StructMatrixView\_\_object*\ bHYPRE\_StructMatrixView\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.1.3.19}
\cxxitem{\ struct\ \ bHYPRE\_StructMatrixView\_\_object*\ bHYPRE\_StructMatrixView\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {1.3.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_StructMatrixView\_\_object}
        {}
        {
Symbol "bHYPRE}
        {1.3.1}
\begin{cxxdoc}

Symbol "bHYPRE.StructMatrixView" (version 1.0.0)
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{extern\ \ C\ \ bHYPRE\_StructMatrixView\ }
        {bHYPRE\_StructMatrixView\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {1.3.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetGrid}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ bHYPRE\_StructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the grid on which vectors are defined}
        {1.3.3}
\begin{cxxdoc}

Set the grid on which vectors are defined.  This and the stencil
determine the matrix structure. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetStencil}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ bHYPRE\_StructStencil\ stencil,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the stencil}
        {1.3.4}
\begin{cxxdoc}

Set the stencil. This and the grid determine the matrix structure. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetValues}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ num\_stencil\_indices,\ \ int32\_t*\ stencil\_indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix values at grid point, given by "index"}
        {1.3.5}
\begin{cxxdoc}

Set matrix values at grid point, given by "index".
You can supply values for one or more positions in the stencil.
"index" is an array of size "dim"; and "stencil\_indices" and "values"
are arrays of size "num\_stencil\_indices".
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetBoxValues}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ num\_stencil\_indices,\ \ int32\_t*\ stencil\_indices,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix values throughout a box in the grid, specified by its lower
and upper corners}
        {1.3.6}
\begin{cxxdoc}

Set matrix values throughout a box in the grid, specified by its lower
and upper corners.  You can supply these values for one or more positions
in the stencil.  Thus the total number of matrix values you supply,
"nvalues", is num\_stencil\_indices x box\_size, where box\_size is the
number of grid points in the box.  The values array should be organized
so all values for a given box point are together (i.e., the stencil
index is the most rapidly varying).
"ilower" and "iupper" are arrays of size "dim", "stencil\_indices" is an
array of size "num\_stencil\_indices", and "values" is an array of size
"nvalues". 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetNumGhost}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ int32\_t*\ num\_ghost,\ \ int32\_t\ dim2,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of ghost zones, separately on the lower and upper sides
for each dimension}
        {1.3.7}
\begin{cxxdoc}

Set the number of ghost zones, separately on the lower and upper sides
for each dimension.
"num\_ghost" is an array of size "dim2", twice the number of dimensions
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetConstantEntries}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ int32\_t\ num\_stencil\_constant\_points,\ \ int32\_t*\ stencil\_constant\_points,\ \ sidl\_BaseInterface\ *\_ex)}
        {
State which stencil entries are constant over the grid}
        {1.3.8}
\begin{cxxdoc}

State which stencil entries are constant over the grid.
Supported options are: (i) none (the default),
(ii) all (stencil\_constant\_points should include all stencil points)
(iii) all entries but the diagonal. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_StructMatrixView\_SetConstantValues}
        {(\ \ bHYPRE\_StructMatrixView\ self,\ \ int32\_t\ num\_stencil\_indices,\ \ int32\_t*\ stencil\_indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Provide values for matrix coefficients which are constant throughout
the grid, one value for each stencil point}
        {1.3.9}
\begin{cxxdoc}

Provide values for matrix coefficients which are constant throughout
the grid, one value for each stencil point.
"stencil\_indices" and "values" is each an array of length
"num\_stencil\_indices" 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_StructMatrixView\_\_object*\ bHYPRE\_StructMatrixView\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {1.3.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct Vector View}
        {}
        {
}
        {1.4}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_StructVectorView\_\_object}
        {}
        {
Symbol "bHYPRE}
        {1.4.1}
\cxxitem{extern\ \ C\ \ bHYPRE\_StructVectorView\ }
        {bHYPRE\_StructVectorView\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {1.4.2}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVectorView\_SetGrid}
        {(\ \ bHYPRE\_StructVectorView\ self,\ \ bHYPRE\_StructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the grid on which vectors are defined}
        {}
\label{cxx.1.4.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVectorView\_SetNumGhost}
        {(\ \ bHYPRE\_StructVectorView\ self,\ \ int32\_t*\ num\_ghost,\ \ int32\_t\ dim2,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of ghost zones, separately on the lower and upper sides
for each dimension}
        {1.4.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVectorView\_SetValue}
        {(\ \ bHYPRE\_StructVectorView\ self,\ \ int32\_t*\ grid\_index,\ \ int32\_t\ dim,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the value of a single vector coefficient, given by "grid\_index"}
        {1.4.4}
\cxxitem{int32\_t\ }
        {bHYPRE\_StructVectorView\_SetBoxValues}
        {(\ \ bHYPRE\_StructVectorView\ self,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the values of all vector coefficient for grid points in a box}
        {1.4.5}
\cxxitem{\ struct\ \ bHYPRE\_StructVectorView\_\_object*\ bHYPRE\_StructVectorView\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.1.4.8}
\cxxitem{void*\ }
        {bHYPRE\_StructVectorView\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.1.4.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructVectorView\_\_exec}
        {(\ \ bHYPRE\_StructVectorView\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.1.4.10}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_StructVectorView\_\_getURL}
        {(\ \ bHYPRE\_StructVectorView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.1.4.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructVectorView\_\_raddRef}
        {(\ \ bHYPRE\_StructVectorView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.1.4.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_StructVectorView\_\_isRemote}
        {(\ \ bHYPRE\_StructVectorView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.1.4.13}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_StructVectorView\_\_isLocal}
        {(\ \ bHYPRE\_StructVectorView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.1.4.14}
\cxxitem{\ struct\ \ bHYPRE\_StructVectorView\_\_object*\ bHYPRE\_StructVectorView\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.1.4.15}
\cxxitem{\ struct\ \ bHYPRE\_StructVectorView\_\_object*\ bHYPRE\_StructVectorView\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {1.4.6}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_StructVectorView\_\_object}
        {}
        {
Symbol "bHYPRE}
        {1.4.1}
\begin{cxxdoc}

Symbol "bHYPRE.StructVectorView" (version 1.0.0)
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{extern\ \ C\ \ bHYPRE\_StructVectorView\ }
        {bHYPRE\_StructVectorView\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {1.4.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVectorView\_SetNumGhost}
        {(\ \ bHYPRE\_StructVectorView\ self,\ \ int32\_t*\ num\_ghost,\ \ int32\_t\ dim2,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of ghost zones, separately on the lower and upper sides
for each dimension}
        {1.4.3}
\begin{cxxdoc}

Set the number of ghost zones, separately on the lower and upper sides
for each dimension.
"num\_ghost" is an array of size "dim2", twice the number of dimensions. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVectorView\_SetValue}
        {(\ \ bHYPRE\_StructVectorView\ self,\ \ int32\_t*\ grid\_index,\ \ int32\_t\ dim,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the value of a single vector coefficient, given by "grid\_index"}
        {1.4.4}
\begin{cxxdoc}

Set the value of a single vector coefficient, given by "grid\_index".
"grid\_index" is an array of size "dim", where dim is the number
of dimensions. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_StructVectorView\_SetBoxValues}
        {(\ \ bHYPRE\_StructVectorView\ self,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the values of all vector coefficient for grid points in a box}
        {1.4.5}
\begin{cxxdoc}

Set the values of all vector coefficient for grid points in a box.
The box is defined by its lower and upper corners in the grid.
"ilower" and "iupper" are arrays of size "dim", where dim is the
number of dimensions.  The "values" array has size "nvalues", which
is the number of grid points in the box. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_StructVectorView\_\_object*\ bHYPRE\_StructVectorView\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {1.4.6}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {SemiStructured Matrix View}
        {}
        {
}
        {1.5}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_SStructMatrixView\_\_object}
        {}
        {
Symbol "bHYPRE}
        {1.5.1}
\cxxitem{extern\ \ C\ \ bHYPRE\_SStructMatrixView\ }
        {bHYPRE\_SStructMatrixView\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {1.5.2}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrixView\_SetGraph}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ bHYPRE\_SStructGraph\ graph,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the matrix graph}
        {1.5.3}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructMatrixView\_SetValues}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix coefficients index by index}
        {1.5.4}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructMatrixView\_SetBoxValues}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix coefficients a box at a time}
        {1.5.5}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructMatrixView\_AddToValues}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add to matrix coefficients index by index}
        {1.5.6}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructMatrixView\_AddToBoxValues}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add to matrix coefficients a box at a time}
        {1.5.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrixView\_SetSymmetric}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ int32\_t\ part,\ \ int32\_t\ var,\ \ int32\_t\ to\_var,\ \ int32\_t\ symmetric,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Define symmetry properties for the stencil entries in the
matrix}
        {1.5.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrixView\_SetNSSymmetric}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ int32\_t\ symmetric,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Define symmetry properties for all non-stencil matrix
entries}
        {}
\label{cxx.1.5.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrixView\_SetComplex}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the matrix to be complex}
        {}
\label{cxx.1.5.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrixView\_Print}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ const\ char*\ filename,\ \ int32\_t\ all,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the matrix to file}
        {1.5.9}
\cxxitem{\ struct\ \ bHYPRE\_SStructMatrixView\_\_object*\ bHYPRE\_SStructMatrixView\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.1.5.13}
\cxxitem{void*\ }
        {bHYPRE\_SStructMatrixView\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.1.5.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructMatrixView\_\_exec}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.1.5.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_SStructMatrixView\_\_getURL}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.1.5.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructMatrixView\_\_raddRef}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.1.5.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_SStructMatrixView\_\_isRemote}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.1.5.18}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_SStructMatrixView\_\_isLocal}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.1.5.19}
\cxxitem{\ struct\ \ bHYPRE\_SStructMatrixView\_\_object*\ bHYPRE\_SStructMatrixView\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.1.5.20}
\cxxitem{\ struct\ \ bHYPRE\_SStructMatrixView\_\_object*\ bHYPRE\_SStructMatrixView\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {1.5.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_SStructMatrixView\_\_object}
        {}
        {
Symbol "bHYPRE}
        {1.5.1}
\begin{cxxdoc}

Symbol "bHYPRE.SStructMatrixView" (version 1.0.0)
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{extern\ \ C\ \ bHYPRE\_SStructMatrixView\ }
        {bHYPRE\_SStructMatrixView\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {1.5.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrixView\_SetGraph}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ bHYPRE\_SStructGraph\ graph,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the matrix graph}
        {1.5.3}
\begin{cxxdoc}

Set the matrix graph.
DEPRECATED     Use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructMatrixView\_SetValues}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix coefficients index by index}
        {1.5.4}
\begin{cxxdoc}

Set matrix coefficients index by index.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

NOTE: The entries in this routine must all be of the same
type: either stencil or non-stencil, but not both.  Also, if
they are stencil entries, they must all represent couplings
to the same variable type (there are no such restrictions for
non-stencil entries).

If the matrix is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructMatrixView\_SetBoxValues}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix coefficients a box at a time}
        {1.5.5}
\begin{cxxdoc}

Set matrix coefficients a box at a time.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

NOTE: The entries in this routine must all be of the same
type: either stencil or non-stencil, but not both.  Also, if
they are stencil entries, they must all represent couplings
to the same variable type (there are no such restrictions for
non-stencil entries).

If the matrix is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructMatrixView\_AddToValues}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add to matrix coefficients index by index}
        {1.5.6}
\begin{cxxdoc}

Add to matrix coefficients index by index.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

NOTE: The entries in this routine must all be of the same
type: either stencil or non-stencil, but not both.  Also, if
they are stencil entries, they must all represent couplings
to the same variable type.

If the matrix is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructMatrixView\_AddToBoxValues}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add to matrix coefficients a box at a time}
        {1.5.7}
\begin{cxxdoc}

Add to matrix coefficients a box at a time.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

NOTE: The entries in this routine must all be of stencil
type.  Also, they must all represent couplings to the same
variable type.

If the matrix is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrixView\_SetSymmetric}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ int32\_t\ part,\ \ int32\_t\ var,\ \ int32\_t\ to\_var,\ \ int32\_t\ symmetric,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Define symmetry properties for the stencil entries in the
matrix}
        {1.5.8}
\begin{cxxdoc}

Define symmetry properties for the stencil entries in the
matrix.  The boolean argument {\tt symmetric} is applied to
stencil entries on part {\tt part} that couple variable {\tt
var} to variable {\tt to\_var}.  A value of -1 may be used
for {\tt part}, {\tt var}, or {\tt to\_var} to specify
``all''.  For example, if {\tt part} and {\tt to\_var} are
set to -1, then the boolean is applied to stencil entries on
all parts that couple variable {\tt var} to all other
variables.

By default, matrices are assumed to be nonsymmetric.
Significant storage savings can be made if the matrix is
symmetric.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrixView\_Print}
        {(\ \ bHYPRE\_SStructMatrixView\ self,\ \ const\ char*\ filename,\ \ int32\_t\ all,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the matrix to file}
        {1.5.9}
\begin{cxxdoc}

Print the matrix to file.  This is mainly for debugging
purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_SStructMatrixView\_\_object*\ bHYPRE\_SStructMatrixView\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {1.5.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {SemiStructured Vector View}
        {}
        {
}
        {1.6}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_SStructVectorView\_\_object}
        {}
        {
Symbol "bHYPRE}
        {1.6.1}
\cxxitem{extern\ \ C\ \ bHYPRE\_SStructVectorView\ }
        {bHYPRE\_SStructVectorView\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {1.6.2}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVectorView\_SetGrid}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ bHYPRE\_SStructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the vector grid}
        {}
\label{cxx.1.6.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVectorView\_SetValues}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients index by index}
        {1.6.3}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructVectorView\_SetBoxValues}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients a box at a time}
        {1.6.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVectorView\_AddToValues}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients index by index}
        {1.6.5}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructVectorView\_AddToBoxValues}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients a box at a time}
        {1.6.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVectorView\_Gather}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gather vector data before calling {\tt GetValues}}
        {}
\label{cxx.1.6.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVectorView\_GetValues}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get vector coefficients index by index}
        {1.6.7}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructVectorView\_GetBoxValues}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get vector coefficients a box at a time}
        {1.6.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVectorView\_SetComplex}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the vector to be complex}
        {}
\label{cxx.1.6.13}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVectorView\_Print}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ const\ char*\ filename,\ \ int32\_t\ all,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the vector to file}
        {1.6.9}
\cxxitem{\ struct\ \ bHYPRE\_SStructVectorView\_\_object*\ bHYPRE\_SStructVectorView\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.1.6.14}
\cxxitem{void*\ }
        {bHYPRE\_SStructVectorView\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.1.6.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructVectorView\_\_exec}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.1.6.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_SStructVectorView\_\_getURL}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.1.6.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructVectorView\_\_raddRef}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.1.6.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_SStructVectorView\_\_isRemote}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.1.6.19}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_SStructVectorView\_\_isLocal}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.1.6.20}
\cxxitem{\ struct\ \ bHYPRE\_SStructVectorView\_\_object*\ bHYPRE\_SStructVectorView\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.1.6.21}
\cxxitem{\ struct\ \ bHYPRE\_SStructVectorView\_\_object*\ bHYPRE\_SStructVectorView\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {1.6.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_SStructVectorView\_\_object}
        {}
        {
Symbol "bHYPRE}
        {1.6.1}
\begin{cxxdoc}

Symbol "bHYPRE.SStructVectorView" (version 1.0.0)
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{extern\ \ C\ \ bHYPRE\_SStructVectorView\ }
        {bHYPRE\_SStructVectorView\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {1.6.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVectorView\_SetValues}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients index by index}
        {1.6.3}
\begin{cxxdoc}

Set vector coefficients index by index.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

If the vector is complex, then {\tt value} consists of a pair
of doubles representing the real and imaginary parts of the
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructVectorView\_SetBoxValues}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients a box at a time}
        {1.6.4}
\begin{cxxdoc}

Set vector coefficients a box at a time.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

If the vector is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVectorView\_AddToValues}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients index by index}
        {1.6.5}
\begin{cxxdoc}

Set vector coefficients index by index.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

If the vector is complex, then {\tt value} consists of a pair
of doubles representing the real and imaginary parts of the
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructVectorView\_AddToBoxValues}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients a box at a time}
        {1.6.6}
\begin{cxxdoc}

Set vector coefficients a box at a time.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

If the vector is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVectorView\_GetValues}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get vector coefficients index by index}
        {1.6.7}
\begin{cxxdoc}

Get vector coefficients index by index.

NOTE: Users may only get values on processes that own the
associated variables.

If the vector is complex, then {\tt value} consists of a pair
of doubles representing the real and imaginary parts of the
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructVectorView\_GetBoxValues}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get vector coefficients a box at a time}
        {1.6.8}
\begin{cxxdoc}

Get vector coefficients a box at a time.

NOTE: Users may only get values on processes that own the
associated variables.

If the vector is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVectorView\_Print}
        {(\ \ bHYPRE\_SStructVectorView\ self,\ \ const\ char*\ filename,\ \ int32\_t\ all,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the vector to file}
        {1.6.9}
\begin{cxxdoc}

Print the vector to file.  This is mainly for debugging
purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_SStructVectorView\_\_object*\ bHYPRE\_SStructVectorView\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {1.6.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{}
        {Operator Interface}
        {}
        {
}
        {2}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_Operator\_\_object}
        {}
        {
Symbol "bHYPRE}
        {2.1}
\cxxitem{extern\ \ C\ \ bHYPRE\_Operator\ }
        {bHYPRE\_Operator\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {2.2}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Operator\_SetCommunicator}
        {(\ \ bHYPRE\_Operator\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {2.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Operator\_Destroy}
        {(\ \ bHYPRE\_Operator\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {2.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Operator\_SetIntParameter}
        {(\ \ bHYPRE\_Operator\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.2.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Operator\_SetDoubleParameter}
        {(\ \ bHYPRE\_Operator\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.2.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Operator\_SetStringParameter}
        {(\ \ bHYPRE\_Operator\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.2.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Operator\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_Operator\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.2.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Operator\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_Operator\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.2.10}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Operator\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_Operator\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.2.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Operator\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_Operator\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.2.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Operator\_GetIntValue}
        {(\ \ bHYPRE\_Operator\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.2.13}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Operator\_GetDoubleValue}
        {(\ \ bHYPRE\_Operator\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.2.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Operator\_Setup}
        {(\ \ bHYPRE\_Operator\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.2.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Operator\_Apply}
        {(\ \ bHYPRE\_Operator\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.2.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Operator\_ApplyAdjoint}
        {(\ \ bHYPRE\_Operator\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.2.17}
\cxxitem{\ struct\ \ bHYPRE\_Operator\_\_object*\ bHYPRE\_Operator\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.2.18}
\cxxitem{void*\ }
        {bHYPRE\_Operator\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.2.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Operator\_\_exec}
        {(\ \ bHYPRE\_Operator\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.2.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_Operator\_\_getURL}
        {(\ \ bHYPRE\_Operator\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.2.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Operator\_\_raddRef}
        {(\ \ bHYPRE\_Operator\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.2.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_Operator\_\_isRemote}
        {(\ \ bHYPRE\_Operator\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.2.23}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_Operator\_\_isLocal}
        {(\ \ bHYPRE\_Operator\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.2.24}
\cxxitem{\ struct\ \ bHYPRE\_Operator\_\_object*\ bHYPRE\_Operator\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.2.25}
\cxxitem{\ struct\ \ bHYPRE\_Operator\_\_object*\ bHYPRE\_Operator\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {2.5}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_Operator\_\_object}
        {}
        {
Symbol "bHYPRE}
        {2.1}
\begin{cxxdoc}

Symbol "bHYPRE.Operator" (version 1.0.0)

An Operator is anything that maps one Vector to another.  The
terms {\tt Setup} and {\tt Apply} are reserved for Operators.
The implementation is allowed to assume that supplied parameter
arrays will not be destroyed.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{extern\ \ C\ \ bHYPRE\_Operator\ }
        {bHYPRE\_Operator\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {2.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Operator\_SetCommunicator}
        {(\ \ bHYPRE\_Operator\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {2.3}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Operator\_Destroy}
        {(\ \ bHYPRE\_Operator\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {2.4}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_Operator\_\_object*\ bHYPRE\_Operator\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {2.5}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Vector Interface}
        {}
        {
}
        {3}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_Vector\_\_object}
        {}
        {
Symbol "bHYPRE}
        {3.1}
\cxxitem{extern\ \ C\ \ bHYPRE\_Vector\ }
        {bHYPRE\_Vector\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {3.2}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Vector\_Clear}
        {(\ \ bHYPRE\_Vector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set {\tt self} to 0}
        {}
\label{cxx.3.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Vector\_Copy}
        {(\ \ bHYPRE\_Vector\ self,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Copy data from x into {\tt self}}
        {}
\label{cxx.3.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Vector\_Clone}
        {(\ \ bHYPRE\_Vector\ self,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Create an {\tt x} compatible with {\tt self}}
        {3.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Vector\_Scale}
        {(\ \ bHYPRE\_Vector\ self,\ \ double\ a,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Scale {\tt self} by {\tt a}}
        {}
\label{cxx.3.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Vector\_Dot}
        {(\ \ bHYPRE\_Vector\ self,\ \ bHYPRE\_Vector\ x,\ \ double*\ d,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Compute {\tt d}, the inner-product of {\tt self} and {\tt x}}
        {}
\label{cxx.3.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Vector\_Axpy}
        {(\ \ bHYPRE\_Vector\ self,\ \ double\ a,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add {\tt a}{\tt x} to {\tt self}}
        {}
\label{cxx.3.9}
\cxxitem{\ struct\ \ bHYPRE\_Vector\_\_object*\ bHYPRE\_Vector\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.3.10}
\cxxitem{void*\ }
        {bHYPRE\_Vector\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.3.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Vector\_\_exec}
        {(\ \ bHYPRE\_Vector\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.3.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_Vector\_\_getURL}
        {(\ \ bHYPRE\_Vector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.3.13}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Vector\_\_raddRef}
        {(\ \ bHYPRE\_Vector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.3.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_Vector\_\_isRemote}
        {(\ \ bHYPRE\_Vector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.3.15}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_Vector\_\_isLocal}
        {(\ \ bHYPRE\_Vector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.3.16}
\cxxitem{\ struct\ \ bHYPRE\_Vector\_\_object*\ bHYPRE\_Vector\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.3.17}
\cxxitem{\ struct\ \ bHYPRE\_Vector\_\_object*\ bHYPRE\_Vector\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {3.4}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_Vector\_\_object}
        {}
        {
Symbol "bHYPRE}
        {3.1}
\begin{cxxdoc}

Symbol "bHYPRE.Vector" (version 1.0.0)
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{extern\ \ C\ \ bHYPRE\_Vector\ }
        {bHYPRE\_Vector\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {3.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Vector\_Clone}
        {(\ \ bHYPRE\_Vector\ self,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Create an {\tt x} compatible with {\tt self}}
        {3.3}
\begin{cxxdoc}

Create an {\tt x} compatible with {\tt self}.
The new vector's data is not specified.

NOTE: When this method is used in an inherited class, the
cloned {\tt Vector} object can be cast to an object with the
inherited class type.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_Vector\_\_object*\ bHYPRE\_Vector\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {3.4}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Matrices and Vectors}
        {}
        {
}
        {4}
\begin{cxxnames}
\cxxitem{}
        {IJParCSR Matrix}
        {}
        {
}
        {4.1}
\cxxitem{}
        {IJParCSR Vector}
        {}
        {
}
        {4.2}
\cxxitem{}
        {Struct Matrix}
        {}
        {
}
        {4.3}
\cxxitem{}
        {Struct Vector}
        {}
        {
}
        {4.4}
\cxxitem{}
        {SemiStructured Matrix}
        {}
        {
}
        {4.5}
\cxxitem{}
        {SemiStructured Vector}
        {}
        {
}
        {4.6}
\cxxitem{}
        {SemiStructured ParCSR Matrix}
        {}
        {
}
        {4.7}
\cxxitem{}
        {SemiStructured ParCSR Vector}
        {}
        {
}
        {4.8}
\end{cxxnames}
\begin{cxxentry}
{}
        {IJParCSR Matrix}
        {}
        {
}
        {4.1}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_IJParCSRMatrix\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.1.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_IJParCSRMatrix\_\_object*\ bHYPRE\_IJParCSRMatrix\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.4.1.16}
\cxxitem{bHYPRE\_IJParCSRMatrix\ }
        {bHYPRE\_IJParCSRMatrix\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.4.1.17}
\cxxitem{bHYPRE\_IJParCSRMatrix\ }
        {bHYPRE\_IJParCSRMatrix\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_IJParCSRMatrix\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.4.1.18}
\cxxitem{bHYPRE\_IJParCSRMatrix\ }
        {bHYPRE\_IJParCSRMatrix\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.1.2}
\cxxitem{bHYPRE\_IJParCSRMatrix\ }
        {bHYPRE\_IJParCSRMatrix\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ int32\_t\ ilower,\ \ int32\_t\ iupper,\ \ int32\_t\ jlower,\ \ int32\_t\ jupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create an IJParCSR Matrix}
        {}
\label{cxx.4.1.19}
\cxxitem{bHYPRE\_IJParCSRMatrix\ }
        {bHYPRE\_IJParCSRMatrix\_GenerateLaplacian}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ int32\_t\ nx,\ \ int32\_t\ ny,\ \ int32\_t\ nz,\ \ int32\_t\ Px,\ \ int32\_t\ Py,\ \ int32\_t\ Pz,\ \ int32\_t\ p,\ \ int32\_t\ q,\ \ int32\_t\ r,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ int32\_t\ discretization,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  GenerateLaplacian[]}
        {}
\label{cxx.4.1.20}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetDiagOffdSizes}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t*\ diag\_sizes,\ \ int32\_t*\ offdiag\_sizes,\ \ int32\_t\ local\_nrows,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the max number of nonzeros to expect in each
row of the diagonal and off-diagonal blocks}
        {4.1.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetLocalRange}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t\ ilower,\ \ int32\_t\ iupper,\ \ int32\_t\ jlower,\ \ int32\_t\ jupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the local range for a matrix object}
        {4.1.4}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetValues}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t\ nrows,\ \ int32\_t*\ ncols,\ \ int32\_t*\ rows,\ \ int32\_t*\ cols,\ \ double*\ values,\ \ int32\_t\ nnonzeros,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Sets values for {\tt nrows} of the matrix}
        {4.1.5}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_AddToValues}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t\ nrows,\ \ int32\_t*\ ncols,\ \ int32\_t*\ rows,\ \ int32\_t*\ cols,\ \ double*\ values,\ \ int32\_t\ nnonzeros,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Adds to values for {\tt nrows} of the matrix}
        {4.1.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_GetLocalRange}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t*\ jlower,\ \ int32\_t*\ jupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gets range of rows owned by this processor and range of
column partitioning for this processor}
        {}
\label{cxx.4.1.21}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_GetRowCounts}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t\ nrows,\ \ int32\_t*\ rows,\ \ int32\_t*\ ncols,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gets number of nonzeros elements for {\tt nrows} rows
specified in {\tt rows} and returns them in {\tt ncols},
which needs to be allocated by the user}
        {}
\label{cxx.4.1.22}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_GetValues}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t\ nrows,\ \ int32\_t*\ ncols,\ \ int32\_t*\ rows,\ \ int32\_t*\ cols,\ \ double*\ values,\ \ int32\_t\ nnonzeros,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gets values for {\tt nrows} rows or partial rows of the
matrix}
        {4.1.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetRowSizes}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t*\ sizes,\ \ int32\_t\ nrows,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the max number of nonzeros to expect in each
row}
        {4.1.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_Print}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ const\ char*\ filename,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the matrix to file}
        {4.1.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_Read}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ const\ char*\ filename,\ \ bHYPRE\_MPICommunicator\ comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Read the matrix from file}
        {4.1.10}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetCommunicator}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.1.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IJParCSRMatrix\_Destroy}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.1.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_Initialize}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Prepare an object for setting coefficient values, whether for
the first time or subsequently}
        {}
\label{cxx.4.1.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_Assemble}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.1.13}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetIntParameter}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.4.1.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetDoubleParameter}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.4.1.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetStringParameter}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.4.1.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.1.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.1.28}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.1.29}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.1.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_GetIntValue}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.4.1.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_GetDoubleValue}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.4.1.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_Setup}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.4.1.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_Apply}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.4.1.34}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_ApplyAdjoint}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.4.1.35}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_GetRow}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t\ row,\ \ int32\_t*\ size,\ \ struct\ sidl\_int\_\_array**\ col\_ind,\ \ struct\ sidl\_double\_\_array**\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The GetRow method will allocate space for its two output
arrays on the first call}
        {4.1.14}
\cxxitem{\ struct\ \ bHYPRE\_IJParCSRMatrix\_\_object*\ bHYPRE\_IJParCSRMatrix\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.1.36}
\cxxitem{void*\ }
        {bHYPRE\_IJParCSRMatrix\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.4.1.37}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IJParCSRMatrix\_\_exec}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.4.1.38}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_IJParCSRMatrix\_\_getURL}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.4.1.39}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IJParCSRMatrix\_\_raddRef}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.4.1.40}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_IJParCSRMatrix\_\_isRemote}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.1.41}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_IJParCSRMatrix\_\_isLocal}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.1.42}
\cxxitem{\ struct\ \ bHYPRE\_IJParCSRMatrix\_\_object*\ bHYPRE\_IJParCSRMatrix\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.1.43}
\cxxitem{\ struct\ \ bHYPRE\_IJParCSRMatrix\_\_object*\ bHYPRE\_IJParCSRMatrix\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.1.15}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_IJParCSRMatrix\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.1.1}
\begin{cxxdoc}

Symbol "bHYPRE.IJParCSRMatrix" (version 1.0.0)

The IJParCSR matrix class.

Objects of this type can be cast to IJMatrixView, Operator, or
CoefficientAccess objects using the {\tt \_\_cast} methods.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_IJParCSRMatrix\ }
        {bHYPRE\_IJParCSRMatrix\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.1.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetDiagOffdSizes}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t*\ diag\_sizes,\ \ int32\_t*\ offdiag\_sizes,\ \ int32\_t\ local\_nrows,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the max number of nonzeros to expect in each
row of the diagonal and off-diagonal blocks}
        {4.1.3}
\begin{cxxdoc}

(Optional) Set the max number of nonzeros to expect in each
row of the diagonal and off-diagonal blocks.  The diagonal
block is the submatrix whose column numbers correspond to
rows owned by this process, and the off-diagonal block is
everything else.  The arrays {\tt diag\_sizes} and {\tt
offdiag\_sizes} contain estimated sizes for each row of the
diagonal and off-diagonal blocks, respectively.  This routine
can significantly improve the efficiency of matrix
construction, and should always be utilized if possible.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetLocalRange}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t\ ilower,\ \ int32\_t\ iupper,\ \ int32\_t\ jlower,\ \ int32\_t\ jupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the local range for a matrix object}
        {4.1.4}
\begin{cxxdoc}

Set the local range for a matrix object.  Each process owns
some unique consecutive range of rows, indicated by the
global row indices {\tt ilower} and {\tt iupper}.  The row
data is required to be such that the value of {\tt ilower} on
any process $p$ be exactly one more than the value of {\tt
iupper} on process $p-1$.  Note that the first row of the
global matrix may start with any integer value.  In
particular, one may use zero- or one-based indexing.

For square matrices, {\tt jlower} and {\tt jupper} typically
should match {\tt ilower} and {\tt iupper}, respectively.
For rectangular matrices, {\tt jlower} and {\tt jupper}
should define a partitioning of the columns.  This
partitioning must be used for any vector $v$ that will be
used in matrix-vector products with the rectangular matrix.
The matrix data structure may use {\tt jlower} and {\tt
jupper} to store the diagonal blocks (rectangular in general)
of the matrix separately from the rest of the matrix.

Collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetValues}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t\ nrows,\ \ int32\_t*\ ncols,\ \ int32\_t*\ rows,\ \ int32\_t*\ cols,\ \ double*\ values,\ \ int32\_t\ nnonzeros,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Sets values for {\tt nrows} of the matrix}
        {4.1.5}
\begin{cxxdoc}

Sets values for {\tt nrows} of the matrix.  The arrays {\tt
ncols} and {\tt rows} are of dimension {\tt nrows} and
contain the number of columns in each row and the row
indices, respectively.  The array {\tt cols} contains the
column indices for each of the {\tt rows}, and is ordered by
rows.  The data in the {\tt values} array corresponds
directly to the column entries in {\tt cols}.  The last argument
is the size of the cols and values arrays, i.e. the total number
of nonzeros being provided, i.e. the sum of all values in ncols.
This functin erases any previous values at the specified locations and
replaces them with new ones, or, if there was no value there before,
inserts a new one.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_AddToValues}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t\ nrows,\ \ int32\_t*\ ncols,\ \ int32\_t*\ rows,\ \ int32\_t*\ cols,\ \ double*\ values,\ \ int32\_t\ nnonzeros,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Adds to values for {\tt nrows} of the matrix}
        {4.1.6}
\begin{cxxdoc}

Adds to values for {\tt nrows} of the matrix.  Usage details
are analogous to {\tt SetValues}.  Adds to any previous
values at the specified locations, or, if there was no value
there before, inserts a new one.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_GetValues}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t\ nrows,\ \ int32\_t*\ ncols,\ \ int32\_t*\ rows,\ \ int32\_t*\ cols,\ \ double*\ values,\ \ int32\_t\ nnonzeros,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gets values for {\tt nrows} rows or partial rows of the
matrix}
        {4.1.7}
\begin{cxxdoc}

Gets values for {\tt nrows} rows or partial rows of the
matrix.  Usage details are analogous to {\tt SetValues}.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetRowSizes}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t*\ sizes,\ \ int32\_t\ nrows,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the max number of nonzeros to expect in each
row}
        {4.1.8}
\begin{cxxdoc}

(Optional) Set the max number of nonzeros to expect in each
row.  The array {\tt sizes} contains estimated sizes for each
row on this process.  The integer nrows is the number of rows in
the local matrix.  This call can significantly improve the
efficiency of matrix construction, and should always be
utilized if possible.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_Print}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ const\ char*\ filename,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the matrix to file}
        {4.1.9}
\begin{cxxdoc}

Print the matrix to file.  This is mainly for debugging
purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_Read}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ const\ char*\ filename,\ \ bHYPRE\_MPICommunicator\ comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Read the matrix from file}
        {4.1.10}
\begin{cxxdoc}

Read the matrix from file.  This is mainly for debugging
purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_SetCommunicator}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.1.11}
\begin{cxxdoc}

Set the MPI Communicator.  DEPRECATED, Use Create()
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IJParCSRMatrix\_Destroy}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.1.12}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_Assemble}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.1.13}
\begin{cxxdoc}

Finalize the construction of an object before using, either
for the first time or on subsequent uses. {\tt Initialize}
and {\tt Assemble} always appear in a matched set, with
Initialize preceding Assemble. Values can only be set in
between a call to Initialize and Assemble.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRMatrix\_GetRow}
        {(\ \ bHYPRE\_IJParCSRMatrix\ self,\ \ int32\_t\ row,\ \ int32\_t*\ size,\ \ struct\ sidl\_int\_\_array**\ col\_ind,\ \ struct\ sidl\_double\_\_array**\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The GetRow method will allocate space for its two output
arrays on the first call}
        {4.1.14}
\begin{cxxdoc}

The GetRow method will allocate space for its two output
arrays on the first call.  The space will be reused on
subsequent calls.  Thus the user must not delete them, yet
must not depend on the data from GetRow to persist beyond the
next GetRow call.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_IJParCSRMatrix\_\_object*\ bHYPRE\_IJParCSRMatrix\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.1.15}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {IJParCSR Vector}
        {}
        {
}
        {4.2}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_IJParCSRVector\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.2.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_IJParCSRVector\_\_object*\ bHYPRE\_IJParCSRVector\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.4.2.14}
\cxxitem{bHYPRE\_IJParCSRVector\ }
        {bHYPRE\_IJParCSRVector\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.4.2.15}
\cxxitem{bHYPRE\_IJParCSRVector\ }
        {bHYPRE\_IJParCSRVector\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_IJParCSRVector\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.4.2.16}
\cxxitem{bHYPRE\_IJParCSRVector\ }
        {bHYPRE\_IJParCSRVector\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.2.2}
\cxxitem{bHYPRE\_IJParCSRVector\ }
        {bHYPRE\_IJParCSRVector\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ int32\_t\ jlower,\ \ int32\_t\ jupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create an IJParCSR Vector}
        {}
\label{cxx.4.2.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_SetLocalRange}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ int32\_t\ jlower,\ \ int32\_t\ jupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the local range for a vector object}
        {4.2.3}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJParCSRVector\_SetValues}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ int32\_t\ nvalues,\ \ int32\_t*\ indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Sets values in vector}
        {4.2.4}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJParCSRVector\_AddToValues}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ int32\_t\ nvalues,\ \ int32\_t*\ indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Adds to values in vector}
        {4.2.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_GetLocalRange}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ int32\_t*\ jlower,\ \ int32\_t*\ jupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Returns range of the part of the vector owned by this
processor}
        {}
\label{cxx.4.2.18}
\cxxitem{int32\_t\ }
        {bHYPRE\_IJParCSRVector\_GetValues}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ int32\_t\ nvalues,\ \ int32\_t*\ indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gets values in vector}
        {4.2.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_Print}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ const\ char*\ filename,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the vector to file}
        {4.2.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_Read}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ const\ char*\ filename,\ \ bHYPRE\_MPICommunicator\ comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Read the vector from file}
        {4.2.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_SetCommunicator}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.2.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IJParCSRVector\_Destroy}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.2.10}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_Initialize}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Prepare an object for setting coefficient values, whether for
the first time or subsequently}
        {}
\label{cxx.4.2.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_Assemble}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.2.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_Clear}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set {\tt self} to 0}
        {}
\label{cxx.4.2.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_Copy}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Copy data from x into {\tt self}}
        {}
\label{cxx.4.2.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_Clone}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Create an {\tt x} compatible with {\tt self}}
        {4.2.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_Scale}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ double\ a,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Scale {\tt self} by {\tt a}}
        {}
\label{cxx.4.2.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_Dot}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ bHYPRE\_Vector\ x,\ \ double*\ d,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Compute {\tt d}, the inner-product of {\tt self} and {\tt x}}
        {}
\label{cxx.4.2.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_Axpy}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ double\ a,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add {\tt a}{\tt x} to {\tt self}}
        {}
\label{cxx.4.2.24}
\cxxitem{\ struct\ \ bHYPRE\_IJParCSRVector\_\_object*\ bHYPRE\_IJParCSRVector\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.2.25}
\cxxitem{void*\ }
        {bHYPRE\_IJParCSRVector\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.4.2.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IJParCSRVector\_\_exec}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.4.2.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_IJParCSRVector\_\_getURL}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.4.2.28}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IJParCSRVector\_\_raddRef}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.4.2.29}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_IJParCSRVector\_\_isRemote}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.2.30}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_IJParCSRVector\_\_isLocal}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.2.31}
\cxxitem{\ struct\ \ bHYPRE\_IJParCSRVector\_\_object*\ bHYPRE\_IJParCSRVector\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.2.32}
\cxxitem{\ struct\ \ bHYPRE\_IJParCSRVector\_\_object*\ bHYPRE\_IJParCSRVector\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.2.13}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_IJParCSRVector\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.2.1}
\begin{cxxdoc}

Symbol "bHYPRE.IJParCSRVector" (version 1.0.0)

The IJParCSR vector class.

Objects of this type can be cast to IJVectorView or Vector
objects using the {\tt \_\_cast} methods.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_IJParCSRVector\ }
        {bHYPRE\_IJParCSRVector\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.2.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_SetLocalRange}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ int32\_t\ jlower,\ \ int32\_t\ jupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the local range for a vector object}
        {4.2.3}
\begin{cxxdoc}

Set the local range for a vector object.  Each process owns
some unique consecutive range of vector unknowns, indicated
by the global indices {\tt jlower} and {\tt jupper}.  The
data is required to be such that the value of {\tt jlower} on
any process $p$ be exactly one more than the value of {\tt
jupper} on process $p-1$.  Note that the first index of the
global vector may start with any integer value.  In
particular, one may use zero- or one-based indexing.

Collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_IJParCSRVector\_SetValues}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ int32\_t\ nvalues,\ \ int32\_t*\ indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Sets values in vector}
        {4.2.4}
\begin{cxxdoc}

Sets values in vector.  The arrays {\tt values} and {\tt
indices} are of dimension {\tt nvalues} and contain the
vector values to be set and the corresponding global vector
indices, respectively.  Erases any previous values at the
specified locations and replaces them with new ones.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_IJParCSRVector\_AddToValues}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ int32\_t\ nvalues,\ \ int32\_t*\ indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Adds to values in vector}
        {4.2.5}
\begin{cxxdoc}

Adds to values in vector.  Usage details are analogous to
{\tt SetValues}.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_IJParCSRVector\_GetValues}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ int32\_t\ nvalues,\ \ int32\_t*\ indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gets values in vector}
        {4.2.6}
\begin{cxxdoc}

Gets values in vector.  Usage details are analogous to {\tt
SetValues}.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_Print}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ const\ char*\ filename,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the vector to file}
        {4.2.7}
\begin{cxxdoc}

Print the vector to file.  This is mainly for debugging
purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_Read}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ const\ char*\ filename,\ \ bHYPRE\_MPICommunicator\ comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Read the vector from file}
        {4.2.8}
\begin{cxxdoc}

Read the vector from file.  This is mainly for debugging
purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_SetCommunicator}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.2.9}
\begin{cxxdoc}

Set the MPI Communicator.  DEPRECATED, Use Create()
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IJParCSRVector\_Destroy}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.2.10}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_Assemble}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.2.11}
\begin{cxxdoc}

Finalize the construction of an object before using, either
for the first time or on subsequent uses. {\tt Initialize}
and {\tt Assemble} always appear in a matched set, with
Initialize preceding Assemble. Values can only be set in
between a call to Initialize and Assemble.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IJParCSRVector\_Clone}
        {(\ \ bHYPRE\_IJParCSRVector\ self,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Create an {\tt x} compatible with {\tt self}}
        {4.2.12}
\begin{cxxdoc}

Create an {\tt x} compatible with {\tt self}.
The new vector's data is not specified.

NOTE: When this method is used in an inherited class, the
cloned {\tt Vector} object can be cast to an object with the
inherited class type.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_IJParCSRVector\_\_object*\ bHYPRE\_IJParCSRVector\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.2.13}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct Matrix}
        {}
        {
}
        {4.3}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_StructMatrix\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.3.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_StructMatrix\_\_object*\ bHYPRE\_StructMatrix\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.4.3.14}
\cxxitem{bHYPRE\_StructMatrix\ }
        {bHYPRE\_StructMatrix\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.4.3.15}
\cxxitem{bHYPRE\_StructMatrix\ }
        {bHYPRE\_StructMatrix\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_StructMatrix\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.4.3.16}
\cxxitem{bHYPRE\_StructMatrix\ }
        {bHYPRE\_StructMatrix\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.3.2}
\cxxitem{bHYPRE\_StructMatrix\ }
        {bHYPRE\_StructMatrix\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_StructGrid\ grid,\ \ bHYPRE\_StructStencil\ stencil,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a Struct Matrix}
        {}
\label{cxx.4.3.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetGrid}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ bHYPRE\_StructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the grid on which vectors are defined}
        {4.3.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetStencil}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ bHYPRE\_StructStencil\ stencil,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the stencil}
        {4.3.4}
\cxxitem{int32\_t\ }
        {bHYPRE\_StructMatrix\_SetValues}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ num\_stencil\_indices,\ \ int32\_t*\ stencil\_indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix values at grid point, given by "index"}
        {4.3.5}
\cxxitem{int32\_t\ }
        {bHYPRE\_StructMatrix\_SetBoxValues}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ num\_stencil\_indices,\ \ int32\_t*\ stencil\_indices,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix values throughout a box in the grid, specified by its lower
and upper corners}
        {4.3.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetNumGhost}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ int32\_t*\ num\_ghost,\ \ int32\_t\ dim2,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of ghost zones, separately on the lower and upper sides
for each dimension}
        {4.3.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetSymmetric}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ int32\_t\ symmetric,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Call SetSymmetric with symmetric=1 to turn on symmetric matrix storage if
available}
        {}
\label{cxx.4.3.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetConstantEntries}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ int32\_t\ num\_stencil\_constant\_points,\ \ int32\_t*\ stencil\_constant\_points,\ \ sidl\_BaseInterface\ *\_ex)}
        {
State which stencil entries are constant over the grid}
        {4.3.8}
\cxxitem{int32\_t\ }
        {bHYPRE\_StructMatrix\_SetConstantValues}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ int32\_t\ num\_stencil\_indices,\ \ int32\_t*\ stencil\_indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Provide values for matrix coefficients which are constant throughout
the grid, one value for each stencil point}
        {4.3.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetCommunicator}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.3.10}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructMatrix\_Destroy}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.3.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_Initialize}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Prepare an object for setting coefficient values, whether for
the first time or subsequently}
        {}
\label{cxx.4.3.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_Assemble}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.3.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetIntParameter}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.4.3.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetDoubleParameter}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.4.3.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetStringParameter}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.4.3.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.3.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.3.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.3.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.3.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_GetIntValue}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.4.3.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_GetDoubleValue}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.4.3.28}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_Setup}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.4.3.29}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_Apply}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.4.3.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_ApplyAdjoint}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.4.3.31}
\cxxitem{\ struct\ \ bHYPRE\_StructMatrix\_\_object*\ bHYPRE\_StructMatrix\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.3.32}
\cxxitem{void*\ }
        {bHYPRE\_StructMatrix\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.4.3.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructMatrix\_\_exec}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.4.3.34}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_StructMatrix\_\_getURL}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.4.3.35}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructMatrix\_\_raddRef}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.4.3.36}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_StructMatrix\_\_isRemote}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.3.37}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_StructMatrix\_\_isLocal}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.3.38}
\cxxitem{\ struct\ \ bHYPRE\_StructMatrix\_\_object*\ bHYPRE\_StructMatrix\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.3.39}
\cxxitem{\ struct\ \ bHYPRE\_StructMatrix\_\_object*\ bHYPRE\_StructMatrix\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.3.13}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_StructMatrix\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.3.1}
\begin{cxxdoc}

Symbol "bHYPRE.StructMatrix" (version 1.0.0)

A single class that implements both a view interface and an
operator interface.
A StructMatrix is a matrix on a structured grid.
One function unique to a StructMatrix is SetConstantEntries.
This declares that matrix entries corresponding to certain stencil points
(supplied as stencil element indices) will be constant throughout the grid.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_StructMatrix\ }
        {bHYPRE\_StructMatrix\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.3.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetGrid}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ bHYPRE\_StructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the grid on which vectors are defined}
        {4.3.3}
\begin{cxxdoc}

Set the grid on which vectors are defined.  This and the stencil
determine the matrix structure. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetStencil}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ bHYPRE\_StructStencil\ stencil,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the stencil}
        {4.3.4}
\begin{cxxdoc}

Set the stencil. This and the grid determine the matrix structure. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_StructMatrix\_SetValues}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ num\_stencil\_indices,\ \ int32\_t*\ stencil\_indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix values at grid point, given by "index"}
        {4.3.5}
\begin{cxxdoc}

Set matrix values at grid point, given by "index".
You can supply values for one or more positions in the stencil.
"index" is an array of size "dim"; and "stencil\_indices" and "values"
are arrays of size "num\_stencil\_indices".
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_StructMatrix\_SetBoxValues}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ num\_stencil\_indices,\ \ int32\_t*\ stencil\_indices,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix values throughout a box in the grid, specified by its lower
and upper corners}
        {4.3.6}
\begin{cxxdoc}

Set matrix values throughout a box in the grid, specified by its lower
and upper corners.  You can supply these values for one or more positions
in the stencil.  Thus the total number of matrix values you supply,
"nvalues", is num\_stencil\_indices x box\_size, where box\_size is the
number of grid points in the box.  The values array should be organized
so all values for a given box point are together (i.e., the stencil
index is the most rapidly varying).
"ilower" and "iupper" are arrays of size "dim", "stencil\_indices" is an
array of size "num\_stencil\_indices", and "values" is an array of size
"nvalues". 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetNumGhost}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ int32\_t*\ num\_ghost,\ \ int32\_t\ dim2,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of ghost zones, separately on the lower and upper sides
for each dimension}
        {4.3.7}
\begin{cxxdoc}

Set the number of ghost zones, separately on the lower and upper sides
for each dimension.
"num\_ghost" is an array of size "dim2", twice the number of dimensions
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetConstantEntries}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ int32\_t\ num\_stencil\_constant\_points,\ \ int32\_t*\ stencil\_constant\_points,\ \ sidl\_BaseInterface\ *\_ex)}
        {
State which stencil entries are constant over the grid}
        {4.3.8}
\begin{cxxdoc}

State which stencil entries are constant over the grid.
Supported options are: (i) none (the default),
(ii) all (stencil\_constant\_points should include all stencil points)
(iii) all entries but the diagonal. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_StructMatrix\_SetConstantValues}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ int32\_t\ num\_stencil\_indices,\ \ int32\_t*\ stencil\_indices,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Provide values for matrix coefficients which are constant throughout
the grid, one value for each stencil point}
        {4.3.9}
\begin{cxxdoc}

Provide values for matrix coefficients which are constant throughout
the grid, one value for each stencil point.
"stencil\_indices" and "values" is each an array of length
"num\_stencil\_indices" 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_SetCommunicator}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.3.10}
\begin{cxxdoc}

Set the MPI Communicator.  DEPRECATED, Use Create()
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructMatrix\_Destroy}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.3.11}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructMatrix\_Assemble}
        {(\ \ bHYPRE\_StructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.3.12}
\begin{cxxdoc}

Finalize the construction of an object before using, either
for the first time or on subsequent uses. {\tt Initialize}
and {\tt Assemble} always appear in a matched set, with
Initialize preceding Assemble. Values can only be set in
between a call to Initialize and Assemble.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_StructMatrix\_\_object*\ bHYPRE\_StructMatrix\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.3.13}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct Vector}
        {}
        {
}
        {4.4}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_StructVector\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.4.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_StructVector\_\_object*\ bHYPRE\_StructVector\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.4.4.11}
\cxxitem{bHYPRE\_StructVector\ }
        {bHYPRE\_StructVector\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.4.4.12}
\cxxitem{bHYPRE\_StructVector\ }
        {bHYPRE\_StructVector\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_StructVector\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.4.4.13}
\cxxitem{bHYPRE\_StructVector\ }
        {bHYPRE\_StructVector\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.4.2}
\cxxitem{bHYPRE\_StructVector\ }
        {bHYPRE\_StructVector\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_StructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a Struct Vector}
        {}
\label{cxx.4.4.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_SetGrid}
        {(\ \ bHYPRE\_StructVector\ self,\ \ bHYPRE\_StructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the grid on which vectors are defined}
        {}
\label{cxx.4.4.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_SetNumGhost}
        {(\ \ bHYPRE\_StructVector\ self,\ \ int32\_t*\ num\_ghost,\ \ int32\_t\ dim2,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of ghost zones, separately on the lower and upper sides
for each dimension}
        {4.4.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_SetValue}
        {(\ \ bHYPRE\_StructVector\ self,\ \ int32\_t*\ grid\_index,\ \ int32\_t\ dim,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the value of a single vector coefficient, given by "grid\_index"}
        {4.4.4}
\cxxitem{int32\_t\ }
        {bHYPRE\_StructVector\_SetBoxValues}
        {(\ \ bHYPRE\_StructVector\ self,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the values of all vector coefficient for grid points in a box}
        {4.4.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_SetCommunicator}
        {(\ \ bHYPRE\_StructVector\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.4.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructVector\_Destroy}
        {(\ \ bHYPRE\_StructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.4.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_Initialize}
        {(\ \ bHYPRE\_StructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Prepare an object for setting coefficient values, whether for
the first time or subsequently}
        {}
\label{cxx.4.4.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_Assemble}
        {(\ \ bHYPRE\_StructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.4.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_Clear}
        {(\ \ bHYPRE\_StructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set {\tt self} to 0}
        {}
\label{cxx.4.4.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_Copy}
        {(\ \ bHYPRE\_StructVector\ self,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Copy data from x into {\tt self}}
        {}
\label{cxx.4.4.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_Clone}
        {(\ \ bHYPRE\_StructVector\ self,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Create an {\tt x} compatible with {\tt self}}
        {4.4.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_Scale}
        {(\ \ bHYPRE\_StructVector\ self,\ \ double\ a,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Scale {\tt self} by {\tt a}}
        {}
\label{cxx.4.4.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_Dot}
        {(\ \ bHYPRE\_StructVector\ self,\ \ bHYPRE\_Vector\ x,\ \ double*\ d,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Compute {\tt d}, the inner-product of {\tt self} and {\tt x}}
        {}
\label{cxx.4.4.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_Axpy}
        {(\ \ bHYPRE\_StructVector\ self,\ \ double\ a,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add {\tt a}{\tt x} to {\tt self}}
        {}
\label{cxx.4.4.21}
\cxxitem{\ struct\ \ bHYPRE\_StructVector\_\_object*\ bHYPRE\_StructVector\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.4.22}
\cxxitem{void*\ }
        {bHYPRE\_StructVector\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.4.4.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructVector\_\_exec}
        {(\ \ bHYPRE\_StructVector\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.4.4.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_StructVector\_\_getURL}
        {(\ \ bHYPRE\_StructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.4.4.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructVector\_\_raddRef}
        {(\ \ bHYPRE\_StructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.4.4.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_StructVector\_\_isRemote}
        {(\ \ bHYPRE\_StructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.4.27}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_StructVector\_\_isLocal}
        {(\ \ bHYPRE\_StructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.4.28}
\cxxitem{\ struct\ \ bHYPRE\_StructVector\_\_object*\ bHYPRE\_StructVector\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.4.29}
\cxxitem{\ struct\ \ bHYPRE\_StructVector\_\_object*\ bHYPRE\_StructVector\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.4.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_StructVector\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.4.1}
\begin{cxxdoc}

Symbol "bHYPRE.StructVector" (version 1.0.0)
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_StructVector\ }
        {bHYPRE\_StructVector\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.4.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_SetNumGhost}
        {(\ \ bHYPRE\_StructVector\ self,\ \ int32\_t*\ num\_ghost,\ \ int32\_t\ dim2,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of ghost zones, separately on the lower and upper sides
for each dimension}
        {4.4.3}
\begin{cxxdoc}

Set the number of ghost zones, separately on the lower and upper sides
for each dimension.
"num\_ghost" is an array of size "dim2", twice the number of dimensions. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_SetValue}
        {(\ \ bHYPRE\_StructVector\ self,\ \ int32\_t*\ grid\_index,\ \ int32\_t\ dim,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the value of a single vector coefficient, given by "grid\_index"}
        {4.4.4}
\begin{cxxdoc}

Set the value of a single vector coefficient, given by "grid\_index".
"grid\_index" is an array of size "dim", where dim is the number
of dimensions. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_StructVector\_SetBoxValues}
        {(\ \ bHYPRE\_StructVector\ self,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the values of all vector coefficient for grid points in a box}
        {4.4.5}
\begin{cxxdoc}

Set the values of all vector coefficient for grid points in a box.
The box is defined by its lower and upper corners in the grid.
"ilower" and "iupper" are arrays of size "dim", where dim is the
number of dimensions.  The "values" array has size "nvalues", which
is the number of grid points in the box. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_SetCommunicator}
        {(\ \ bHYPRE\_StructVector\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.4.6}
\begin{cxxdoc}

Set the MPI Communicator.  DEPRECATED, Use Create()
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructVector\_Destroy}
        {(\ \ bHYPRE\_StructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.4.7}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_Assemble}
        {(\ \ bHYPRE\_StructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.4.8}
\begin{cxxdoc}

Finalize the construction of an object before using, either
for the first time or on subsequent uses. {\tt Initialize}
and {\tt Assemble} always appear in a matched set, with
Initialize preceding Assemble. Values can only be set in
between a call to Initialize and Assemble.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructVector\_Clone}
        {(\ \ bHYPRE\_StructVector\ self,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Create an {\tt x} compatible with {\tt self}}
        {4.4.9}
\begin{cxxdoc}

Create an {\tt x} compatible with {\tt self}.
The new vector's data is not specified.

NOTE: When this method is used in an inherited class, the
cloned {\tt Vector} object can be cast to an object with the
inherited class type.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_StructVector\_\_object*\ bHYPRE\_StructVector\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.4.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {SemiStructured Matrix}
        {}
        {
}
        {4.5}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_SStructMatrix\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.5.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_SStructMatrix\_\_object*\ bHYPRE\_SStructMatrix\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.4.5.15}
\cxxitem{bHYPRE\_SStructMatrix\ }
        {bHYPRE\_SStructMatrix\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.4.5.16}
\cxxitem{bHYPRE\_SStructMatrix\ }
        {bHYPRE\_SStructMatrix\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_SStructMatrix\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.4.5.17}
\cxxitem{bHYPRE\_SStructMatrix\ }
        {bHYPRE\_SStructMatrix\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.5.2}
\cxxitem{bHYPRE\_SStructMatrix\ }
        {bHYPRE\_SStructMatrix\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_SStructGraph\ graph,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a SStruct Matrix}
        {}
\label{cxx.4.5.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetObjectType}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ int32\_t\ type,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  SetObjectType[]}
        {}
\label{cxx.4.5.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetGraph}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ bHYPRE\_SStructGraph\ graph,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the matrix graph}
        {4.5.3}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetValues}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix coefficients index by index}
        {4.5.4}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetBoxValues}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix coefficients a box at a time}
        {4.5.5}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructMatrix\_AddToValues}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add to matrix coefficients index by index}
        {4.5.6}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructMatrix\_AddToBoxValues}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add to matrix coefficients a box at a time}
        {4.5.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetSymmetric}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t\ var,\ \ int32\_t\ to\_var,\ \ int32\_t\ symmetric,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Define symmetry properties for the stencil entries in the
matrix}
        {4.5.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetNSSymmetric}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ int32\_t\ symmetric,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Define symmetry properties for all non-stencil matrix
entries}
        {}
\label{cxx.4.5.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetComplex}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the matrix to be complex}
        {}
\label{cxx.4.5.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_Print}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ const\ char*\ filename,\ \ int32\_t\ all,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the matrix to file}
        {4.5.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_GetObject}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ sidl\_BaseInterface*\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
A semi-structured matrix or vector contains a Struct or IJ matrix
or vector}
        {4.5.10}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetCommunicator}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.5.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructMatrix\_Destroy}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.5.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_Initialize}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Prepare an object for setting coefficient values, whether for
the first time or subsequently}
        {}
\label{cxx.4.5.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_Assemble}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.5.13}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetIntParameter}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.4.5.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetDoubleParameter}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.4.5.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetStringParameter}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.4.5.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.5.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.5.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.5.28}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.5.29}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_GetIntValue}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.4.5.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_GetDoubleValue}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.4.5.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_Setup}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.4.5.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_Apply}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.4.5.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_ApplyAdjoint}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.4.5.34}
\cxxitem{\ struct\ \ bHYPRE\_SStructMatrix\_\_object*\ bHYPRE\_SStructMatrix\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.5.35}
\cxxitem{void*\ }
        {bHYPRE\_SStructMatrix\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.4.5.36}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructMatrix\_\_exec}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.4.5.37}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_SStructMatrix\_\_getURL}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.4.5.38}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructMatrix\_\_raddRef}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.4.5.39}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_SStructMatrix\_\_isRemote}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.5.40}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_SStructMatrix\_\_isLocal}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.5.41}
\cxxitem{\ struct\ \ bHYPRE\_SStructMatrix\_\_object*\ bHYPRE\_SStructMatrix\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.5.42}
\cxxitem{\ struct\ \ bHYPRE\_SStructMatrix\_\_object*\ bHYPRE\_SStructMatrix\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.5.14}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_SStructMatrix\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.5.1}
\begin{cxxdoc}

Symbol "bHYPRE.SStructMatrix" (version 1.0.0)

The semi-structured grid matrix class.

Objects of this type can be cast to SStructMatrixView or
Operator objects using the {\tt \_\_cast} methods.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_SStructMatrix\ }
        {bHYPRE\_SStructMatrix\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.5.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetGraph}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ bHYPRE\_SStructGraph\ graph,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the matrix graph}
        {4.5.3}
\begin{cxxdoc}

Set the matrix graph.
DEPRECATED     Use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetValues}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix coefficients index by index}
        {4.5.4}
\begin{cxxdoc}

Set matrix coefficients index by index.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

NOTE: The entries in this routine must all be of the same
type: either stencil or non-stencil, but not both.  Also, if
they are stencil entries, they must all represent couplings
to the same variable type (there are no such restrictions for
non-stencil entries).

If the matrix is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetBoxValues}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix coefficients a box at a time}
        {4.5.5}
\begin{cxxdoc}

Set matrix coefficients a box at a time.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

NOTE: The entries in this routine must all be of the same
type: either stencil or non-stencil, but not both.  Also, if
they are stencil entries, they must all represent couplings
to the same variable type (there are no such restrictions for
non-stencil entries).

If the matrix is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructMatrix\_AddToValues}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add to matrix coefficients index by index}
        {4.5.6}
\begin{cxxdoc}

Add to matrix coefficients index by index.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

NOTE: The entries in this routine must all be of the same
type: either stencil or non-stencil, but not both.  Also, if
they are stencil entries, they must all represent couplings
to the same variable type.

If the matrix is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructMatrix\_AddToBoxValues}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add to matrix coefficients a box at a time}
        {4.5.7}
\begin{cxxdoc}

Add to matrix coefficients a box at a time.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

NOTE: The entries in this routine must all be of stencil
type.  Also, they must all represent couplings to the same
variable type.

If the matrix is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetSymmetric}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t\ var,\ \ int32\_t\ to\_var,\ \ int32\_t\ symmetric,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Define symmetry properties for the stencil entries in the
matrix}
        {4.5.8}
\begin{cxxdoc}

Define symmetry properties for the stencil entries in the
matrix.  The boolean argument {\tt symmetric} is applied to
stencil entries on part {\tt part} that couple variable {\tt
var} to variable {\tt to\_var}.  A value of -1 may be used
for {\tt part}, {\tt var}, or {\tt to\_var} to specify
``all''.  For example, if {\tt part} and {\tt to\_var} are
set to -1, then the boolean is applied to stencil entries on
all parts that couple variable {\tt var} to all other
variables.

By default, matrices are assumed to be nonsymmetric.
Significant storage savings can be made if the matrix is
symmetric.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_Print}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ const\ char*\ filename,\ \ int32\_t\ all,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the matrix to file}
        {4.5.9}
\begin{cxxdoc}

Print the matrix to file.  This is mainly for debugging
purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_GetObject}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ sidl\_BaseInterface*\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
A semi-structured matrix or vector contains a Struct or IJ matrix
or vector}
        {4.5.10}
\begin{cxxdoc}

A semi-structured matrix or vector contains a Struct or IJ matrix
or vector.  GetObject returns it.
The returned type is a sidl.BaseInterface.
A cast must be used on the returned object to convert it into a known type.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_SetCommunicator}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.5.11}
\begin{cxxdoc}

Set the MPI Communicator.  DEPRECATED, Use Create()
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructMatrix\_Destroy}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.5.12}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructMatrix\_Assemble}
        {(\ \ bHYPRE\_SStructMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.5.13}
\begin{cxxdoc}

Finalize the construction of an object before using, either
for the first time or on subsequent uses. {\tt Initialize}
and {\tt Assemble} always appear in a matched set, with
Initialize preceding Assemble. Values can only be set in
between a call to Initialize and Assemble.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_SStructMatrix\_\_object*\ bHYPRE\_SStructMatrix\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.5.14}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {SemiStructured Vector}
        {}
        {
}
        {4.6}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_SStructVector\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.6.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_SStructVector\_\_object*\ bHYPRE\_SStructVector\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.4.6.16}
\cxxitem{bHYPRE\_SStructVector\ }
        {bHYPRE\_SStructVector\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.4.6.17}
\cxxitem{bHYPRE\_SStructVector\ }
        {bHYPRE\_SStructVector\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_SStructVector\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.4.6.18}
\cxxitem{bHYPRE\_SStructVector\ }
        {bHYPRE\_SStructVector\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.6.2}
\cxxitem{bHYPRE\_SStructVector\ }
        {bHYPRE\_SStructVector\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_SStructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a SStruct Vector}
        {}
\label{cxx.4.6.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_SetObjectType}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ int32\_t\ type,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  SetObjectType[]}
        {}
\label{cxx.4.6.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_SetGrid}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ bHYPRE\_SStructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the vector grid}
        {}
\label{cxx.4.6.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_SetValues}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients index by index}
        {4.6.3}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructVector\_SetBoxValues}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients a box at a time}
        {4.6.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_AddToValues}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients index by index}
        {4.6.5}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructVector\_AddToBoxValues}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients a box at a time}
        {4.6.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_Gather}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gather vector data before calling {\tt GetValues}}
        {}
\label{cxx.4.6.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_GetValues}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get vector coefficients index by index}
        {4.6.7}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructVector\_GetBoxValues}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get vector coefficients a box at a time}
        {4.6.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_SetComplex}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the vector to be complex}
        {}
\label{cxx.4.6.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_Print}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ const\ char*\ filename,\ \ int32\_t\ all,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the vector to file}
        {4.6.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_GetObject}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ sidl\_BaseInterface*\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
A semi-structured matrix or vector contains a Struct or IJ matrix
or vector}
        {4.6.10}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_SetCommunicator}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.6.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructVector\_Destroy}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.6.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_Initialize}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Prepare an object for setting coefficient values, whether for
the first time or subsequently}
        {}
\label{cxx.4.6.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_Assemble}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.6.13}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_Clear}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set {\tt self} to 0}
        {}
\label{cxx.4.6.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_Copy}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Copy data from x into {\tt self}}
        {}
\label{cxx.4.6.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_Clone}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Create an {\tt x} compatible with {\tt self}}
        {4.6.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_Scale}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ double\ a,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Scale {\tt self} by {\tt a}}
        {}
\label{cxx.4.6.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_Dot}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ bHYPRE\_Vector\ x,\ \ double*\ d,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Compute {\tt d}, the inner-product of {\tt self} and {\tt x}}
        {}
\label{cxx.4.6.28}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_Axpy}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ double\ a,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add {\tt a}{\tt x} to {\tt self}}
        {}
\label{cxx.4.6.29}
\cxxitem{\ struct\ \ bHYPRE\_SStructVector\_\_object*\ bHYPRE\_SStructVector\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.6.30}
\cxxitem{void*\ }
        {bHYPRE\_SStructVector\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.4.6.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructVector\_\_exec}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.4.6.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_SStructVector\_\_getURL}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.4.6.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructVector\_\_raddRef}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.4.6.34}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_SStructVector\_\_isRemote}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.6.35}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_SStructVector\_\_isLocal}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.6.36}
\cxxitem{\ struct\ \ bHYPRE\_SStructVector\_\_object*\ bHYPRE\_SStructVector\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.6.37}
\cxxitem{\ struct\ \ bHYPRE\_SStructVector\_\_object*\ bHYPRE\_SStructVector\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.6.15}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_SStructVector\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.6.1}
\begin{cxxdoc}

Symbol "bHYPRE.SStructVector" (version 1.0.0)

The semi-structured grid vector class.

Objects of this type can be cast to SStructVectorView or Vector
objects using the {\tt \_\_cast} methods.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_SStructVector\ }
        {bHYPRE\_SStructVector\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.6.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_SetValues}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients index by index}
        {4.6.3}
\begin{cxxdoc}

Set vector coefficients index by index.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

If the vector is complex, then {\tt value} consists of a pair
of doubles representing the real and imaginary parts of the
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructVector\_SetBoxValues}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients a box at a time}
        {4.6.4}
\begin{cxxdoc}

Set vector coefficients a box at a time.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

If the vector is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_AddToValues}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients index by index}
        {4.6.5}
\begin{cxxdoc}

Set vector coefficients index by index.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

If the vector is complex, then {\tt value} consists of a pair
of doubles representing the real and imaginary parts of the
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructVector\_AddToBoxValues}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients a box at a time}
        {4.6.6}
\begin{cxxdoc}

Set vector coefficients a box at a time.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

If the vector is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_GetValues}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get vector coefficients index by index}
        {4.6.7}
\begin{cxxdoc}

Get vector coefficients index by index.

NOTE: Users may only get values on processes that own the
associated variables.

If the vector is complex, then {\tt value} consists of a pair
of doubles representing the real and imaginary parts of the
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructVector\_GetBoxValues}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get vector coefficients a box at a time}
        {4.6.8}
\begin{cxxdoc}

Get vector coefficients a box at a time.

NOTE: Users may only get values on processes that own the
associated variables.

If the vector is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_Print}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ const\ char*\ filename,\ \ int32\_t\ all,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the vector to file}
        {4.6.9}
\begin{cxxdoc}

Print the vector to file.  This is mainly for debugging
purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_GetObject}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ sidl\_BaseInterface*\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
A semi-structured matrix or vector contains a Struct or IJ matrix
or vector}
        {4.6.10}
\begin{cxxdoc}

A semi-structured matrix or vector contains a Struct or IJ matrix
or vector.  GetObject returns it.
The returned type is a sidl.BaseInterface.
A cast must be used on the returned object to convert it into a known type.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_SetCommunicator}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.6.11}
\begin{cxxdoc}

Set the MPI Communicator.  DEPRECATED, Use Create()
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructVector\_Destroy}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.6.12}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_Assemble}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.6.13}
\begin{cxxdoc}

Finalize the construction of an object before using, either
for the first time or on subsequent uses. {\tt Initialize}
and {\tt Assemble} always appear in a matched set, with
Initialize preceding Assemble. Values can only be set in
between a call to Initialize and Assemble.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructVector\_Clone}
        {(\ \ bHYPRE\_SStructVector\ self,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Create an {\tt x} compatible with {\tt self}}
        {4.6.14}
\begin{cxxdoc}

Create an {\tt x} compatible with {\tt self}.
The new vector's data is not specified.

NOTE: When this method is used in an inherited class, the
cloned {\tt Vector} object can be cast to an object with the
inherited class type.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_SStructVector\_\_object*\ bHYPRE\_SStructVector\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.6.15}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {SemiStructured ParCSR Matrix}
        {}
        {
}
        {4.7}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_SStructParCSRMatrix\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.7.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_SStructParCSRMatrix\_\_object*\ bHYPRE\_SStructParCSRMatrix\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.4.7.15}
\cxxitem{bHYPRE\_SStructParCSRMatrix\ }
        {bHYPRE\_SStructParCSRMatrix\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.4.7.16}
\cxxitem{bHYPRE\_SStructParCSRMatrix\ }
        {bHYPRE\_SStructParCSRMatrix\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_SStructParCSRMatrix\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.4.7.17}
\cxxitem{bHYPRE\_SStructParCSRMatrix\ }
        {bHYPRE\_SStructParCSRMatrix\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.7.2}
\cxxitem{bHYPRE\_SStructParCSRMatrix\ }
        {bHYPRE\_SStructParCSRMatrix\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_SStructGraph\ graph,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a SStruct ParCSR Matrix}
        {}
\label{cxx.4.7.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetGraph}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ bHYPRE\_SStructGraph\ graph,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the matrix graph}
        {4.7.3}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetValues}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix coefficients index by index}
        {4.7.4}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetBoxValues}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix coefficients a box at a time}
        {4.7.5}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_AddToValues}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add to matrix coefficients index by index}
        {4.7.6}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_AddToBoxValues}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add to matrix coefficients a box at a time}
        {4.7.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetSymmetric}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t\ var,\ \ int32\_t\ to\_var,\ \ int32\_t\ symmetric,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Define symmetry properties for the stencil entries in the
matrix}
        {4.7.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetNSSymmetric}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ int32\_t\ symmetric,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Define symmetry properties for all non-stencil matrix
entries}
        {}
\label{cxx.4.7.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetComplex}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the matrix to be complex}
        {}
\label{cxx.4.7.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_Print}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ const\ char*\ filename,\ \ int32\_t\ all,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the matrix to file}
        {4.7.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_GetObject}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ sidl\_BaseInterface*\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
A semi-structured matrix or vector contains a Struct or IJ matrix
or vector}
        {4.7.10}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetCommunicator}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.7.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructParCSRMatrix\_Destroy}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.7.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_Initialize}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Prepare an object for setting coefficient values, whether for
the first time or subsequently}
        {}
\label{cxx.4.7.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_Assemble}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.7.13}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetIntParameter}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.4.7.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetDoubleParameter}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.4.7.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetStringParameter}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.4.7.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.7.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.7.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.7.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.4.7.28}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_GetIntValue}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.4.7.29}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_GetDoubleValue}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.4.7.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_Setup}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.4.7.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_Apply}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.4.7.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_ApplyAdjoint}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.4.7.33}
\cxxitem{\ struct\ \ bHYPRE\_SStructParCSRMatrix\_\_object*\ bHYPRE\_SStructParCSRMatrix\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.7.34}
\cxxitem{void*\ }
        {bHYPRE\_SStructParCSRMatrix\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.4.7.35}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructParCSRMatrix\_\_exec}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.4.7.36}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_SStructParCSRMatrix\_\_getURL}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.4.7.37}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructParCSRMatrix\_\_raddRef}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.4.7.38}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_SStructParCSRMatrix\_\_isRemote}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.7.39}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_SStructParCSRMatrix\_\_isLocal}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.7.40}
\cxxitem{\ struct\ \ bHYPRE\_SStructParCSRMatrix\_\_object*\ bHYPRE\_SStructParCSRMatrix\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.7.41}
\cxxitem{\ struct\ \ bHYPRE\_SStructParCSRMatrix\_\_object*\ bHYPRE\_SStructParCSRMatrix\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.7.14}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_SStructParCSRMatrix\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.7.1}
\begin{cxxdoc}

Symbol "bHYPRE.SStructParCSRMatrix" (version 1.0.0)

The SStructParCSR matrix class.

Objects of this type can be cast to SStructMatrixView or
Operator objects using the {\tt \_\_cast} methods.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_SStructParCSRMatrix\ }
        {bHYPRE\_SStructParCSRMatrix\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.7.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetGraph}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ bHYPRE\_SStructGraph\ graph,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the matrix graph}
        {4.7.3}
\begin{cxxdoc}

Set the matrix graph.
DEPRECATED     Use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetValues}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix coefficients index by index}
        {4.7.4}
\begin{cxxdoc}

Set matrix coefficients index by index.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

NOTE: The entries in this routine must all be of the same
type: either stencil or non-stencil, but not both.  Also, if
they are stencil entries, they must all represent couplings
to the same variable type (there are no such restrictions for
non-stencil entries).

If the matrix is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetBoxValues}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set matrix coefficients a box at a time}
        {4.7.5}
\begin{cxxdoc}

Set matrix coefficients a box at a time.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

NOTE: The entries in this routine must all be of the same
type: either stencil or non-stencil, but not both.  Also, if
they are stencil entries, they must all represent couplings
to the same variable type (there are no such restrictions for
non-stencil entries).

If the matrix is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_AddToValues}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add to matrix coefficients index by index}
        {4.7.6}
\begin{cxxdoc}

Add to matrix coefficients index by index.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

NOTE: The entries in this routine must all be of the same
type: either stencil or non-stencil, but not both.  Also, if
they are stencil entries, they must all represent couplings
to the same variable type.

If the matrix is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_AddToBoxValues}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ nentries,\ \ int32\_t*\ entries,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add to matrix coefficients a box at a time}
        {4.7.7}
\begin{cxxdoc}

Add to matrix coefficients a box at a time.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

NOTE: The entries in this routine must all be of stencil
type.  Also, they must all represent couplings to the same
variable type.

If the matrix is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetSymmetric}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ int32\_t\ part,\ \ int32\_t\ var,\ \ int32\_t\ to\_var,\ \ int32\_t\ symmetric,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Define symmetry properties for the stencil entries in the
matrix}
        {4.7.8}
\begin{cxxdoc}

Define symmetry properties for the stencil entries in the
matrix.  The boolean argument {\tt symmetric} is applied to
stencil entries on part {\tt part} that couple variable {\tt
var} to variable {\tt to\_var}.  A value of -1 may be used
for {\tt part}, {\tt var}, or {\tt to\_var} to specify
``all''.  For example, if {\tt part} and {\tt to\_var} are
set to -1, then the boolean is applied to stencil entries on
all parts that couple variable {\tt var} to all other
variables.

By default, matrices are assumed to be nonsymmetric.
Significant storage savings can be made if the matrix is
symmetric.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_Print}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ const\ char*\ filename,\ \ int32\_t\ all,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the matrix to file}
        {4.7.9}
\begin{cxxdoc}

Print the matrix to file.  This is mainly for debugging
purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_GetObject}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ sidl\_BaseInterface*\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
A semi-structured matrix or vector contains a Struct or IJ matrix
or vector}
        {4.7.10}
\begin{cxxdoc}

A semi-structured matrix or vector contains a Struct or IJ matrix
or vector.  GetObject returns it.
The returned type is a sidl.BaseInterface.
A cast must be used on the returned object to convert it into a known type.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_SetCommunicator}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.7.11}
\begin{cxxdoc}

Set the MPI Communicator.  DEPRECATED, Use Create()
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructParCSRMatrix\_Destroy}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.7.12}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRMatrix\_Assemble}
        {(\ \ bHYPRE\_SStructParCSRMatrix\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.7.13}
\begin{cxxdoc}

Finalize the construction of an object before using, either
for the first time or on subsequent uses. {\tt Initialize}
and {\tt Assemble} always appear in a matched set, with
Initialize preceding Assemble. Values can only be set in
between a call to Initialize and Assemble.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_SStructParCSRMatrix\_\_object*\ bHYPRE\_SStructParCSRMatrix\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.7.14}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {SemiStructured ParCSR Vector}
        {}
        {
}
        {4.8}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_SStructParCSRVector\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.8.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_SStructParCSRVector\_\_object*\ bHYPRE\_SStructParCSRVector\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.4.8.16}
\cxxitem{bHYPRE\_SStructParCSRVector\ }
        {bHYPRE\_SStructParCSRVector\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.4.8.17}
\cxxitem{bHYPRE\_SStructParCSRVector\ }
        {bHYPRE\_SStructParCSRVector\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_SStructParCSRVector\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.4.8.18}
\cxxitem{bHYPRE\_SStructParCSRVector\ }
        {bHYPRE\_SStructParCSRVector\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.8.2}
\cxxitem{bHYPRE\_SStructParCSRVector\ }
        {bHYPRE\_SStructParCSRVector\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_SStructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a SStruct ParCSR Vector}
        {}
\label{cxx.4.8.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_SetGrid}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ bHYPRE\_SStructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the vector grid}
        {}
\label{cxx.4.8.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_SetValues}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients index by index}
        {4.8.3}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_SetBoxValues}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients a box at a time}
        {4.8.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_AddToValues}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients index by index}
        {4.8.5}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_AddToBoxValues}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients a box at a time}
        {4.8.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_Gather}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Gather vector data before calling {\tt GetValues}}
        {}
\label{cxx.4.8.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_GetValues}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get vector coefficients index by index}
        {4.8.7}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_GetBoxValues}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get vector coefficients a box at a time}
        {4.8.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_SetComplex}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the vector to be complex}
        {}
\label{cxx.4.8.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_Print}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ const\ char*\ filename,\ \ int32\_t\ all,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the vector to file}
        {4.8.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_GetObject}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ sidl\_BaseInterface*\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
A semi-structured matrix or vector contains a Struct or IJ matrix
or vector}
        {4.8.10}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_SetCommunicator}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.8.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructParCSRVector\_Destroy}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.8.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_Initialize}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Prepare an object for setting coefficient values, whether for
the first time or subsequently}
        {}
\label{cxx.4.8.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_Assemble}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.8.13}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_Clear}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set {\tt self} to 0}
        {}
\label{cxx.4.8.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_Copy}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Copy data from x into {\tt self}}
        {}
\label{cxx.4.8.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_Clone}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Create an {\tt x} compatible with {\tt self}}
        {4.8.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_Scale}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ double\ a,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Scale {\tt self} by {\tt a}}
        {}
\label{cxx.4.8.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_Dot}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ bHYPRE\_Vector\ x,\ \ double*\ d,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Compute {\tt d}, the inner-product of {\tt self} and {\tt x}}
        {}
\label{cxx.4.8.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_Axpy}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ double\ a,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add {\tt a}{\tt x} to {\tt self}}
        {}
\label{cxx.4.8.28}
\cxxitem{\ struct\ \ bHYPRE\_SStructParCSRVector\_\_object*\ bHYPRE\_SStructParCSRVector\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.8.29}
\cxxitem{void*\ }
        {bHYPRE\_SStructParCSRVector\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.4.8.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructParCSRVector\_\_exec}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.4.8.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_SStructParCSRVector\_\_getURL}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.4.8.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructParCSRVector\_\_raddRef}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.4.8.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_SStructParCSRVector\_\_isRemote}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.8.34}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_SStructParCSRVector\_\_isLocal}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.4.8.35}
\cxxitem{\ struct\ \ bHYPRE\_SStructParCSRVector\_\_object*\ bHYPRE\_SStructParCSRVector\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.4.8.36}
\cxxitem{\ struct\ \ bHYPRE\_SStructParCSRVector\_\_object*\ bHYPRE\_SStructParCSRVector\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.8.15}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_SStructParCSRVector\_\_object}
        {}
        {
Symbol "bHYPRE}
        {4.8.1}
\begin{cxxdoc}

Symbol "bHYPRE.SStructParCSRVector" (version 1.0.0)

The SStructParCSR vector class.

Objects of this type can be cast to SStructVectorView or Vector
objects using the {\tt \_\_cast} methods.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_SStructParCSRVector\ }
        {bHYPRE\_SStructParCSRVector\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {4.8.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_SetValues}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients index by index}
        {4.8.3}
\begin{cxxdoc}

Set vector coefficients index by index.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

If the vector is complex, then {\tt value} consists of a pair
of doubles representing the real and imaginary parts of the
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_SetBoxValues}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients a box at a time}
        {4.8.4}
\begin{cxxdoc}

Set vector coefficients a box at a time.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

If the vector is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_AddToValues}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients index by index}
        {4.8.5}
\begin{cxxdoc}

Set vector coefficients index by index.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

If the vector is complex, then {\tt value} consists of a pair
of doubles representing the real and imaginary parts of the
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_AddToBoxValues}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set vector coefficients a box at a time}
        {4.8.6}
\begin{cxxdoc}

Set vector coefficients a box at a time.

NOTE: Users are required to set values on all processes that
own the associated variables.  This means that some data will
be multiply defined.

If the vector is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_GetValues}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get vector coefficients index by index}
        {4.8.7}
\begin{cxxdoc}

Get vector coefficients index by index.

NOTE: Users may only get values on processes that own the
associated variables.

If the vector is complex, then {\tt value} consists of a pair
of doubles representing the real and imaginary parts of the
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_GetBoxValues}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ double*\ values,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get vector coefficients a box at a time}
        {4.8.8}
\begin{cxxdoc}

Get vector coefficients a box at a time.

NOTE: Users may only get values on processes that own the
associated variables.

If the vector is complex, then {\tt values} consists of pairs
of doubles representing the real and imaginary parts of each
complex value.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_Print}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ const\ char*\ filename,\ \ int32\_t\ all,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Print the vector to file}
        {4.8.9}
\begin{cxxdoc}

Print the vector to file.  This is mainly for debugging
purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_GetObject}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ sidl\_BaseInterface*\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
A semi-structured matrix or vector contains a Struct or IJ matrix
or vector}
        {4.8.10}
\begin{cxxdoc}

A semi-structured matrix or vector contains a Struct or IJ matrix
or vector.  GetObject returns it.
The returned type is a sidl.BaseInterface.
A cast must be used on the returned object to convert it into a known type.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_SetCommunicator}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {4.8.11}
\begin{cxxdoc}

Set the MPI Communicator.  DEPRECATED, Use Create()
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructParCSRVector\_Destroy}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {4.8.12}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_Assemble}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {4.8.13}
\begin{cxxdoc}

Finalize the construction of an object before using, either
for the first time or on subsequent uses. {\tt Initialize}
and {\tt Assemble} always appear in a matched set, with
Initialize preceding Assemble. Values can only be set in
between a call to Initialize and Assemble.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructParCSRVector\_Clone}
        {(\ \ bHYPRE\_SStructParCSRVector\ self,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Create an {\tt x} compatible with {\tt self}}
        {4.8.14}
\begin{cxxdoc}

Create an {\tt x} compatible with {\tt self}.
The new vector's data is not specified.

NOTE: When this method is used in an inherited class, the
cloned {\tt Vector} object can be cast to an object with the
inherited class type.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_SStructParCSRVector\_\_object*\ bHYPRE\_SStructParCSRVector\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {4.8.15}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{}
        {Solver Interface}
        {}
        {
}
        {5}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_Solver\_\_object}
        {}
        {
Symbol "bHYPRE}
        {5.1}
\cxxitem{extern\ \ C\ \ bHYPRE\_Solver\ }
        {bHYPRE\_Solver\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {5.2}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Solver\_SetOperator}
        {(\ \ bHYPRE\_Solver\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {5.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Solver\_SetTolerance}
        {(\ \ bHYPRE\_Solver\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {5.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Solver\_SetMaxIterations}
        {(\ \ bHYPRE\_Solver\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {5.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Solver\_SetLogging}
        {(\ \ bHYPRE\_Solver\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {5.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Solver\_SetPrintLevel}
        {(\ \ bHYPRE\_Solver\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {5.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Solver\_GetNumIterations}
        {(\ \ bHYPRE\_Solver\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.5.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Solver\_GetRelResidualNorm}
        {(\ \ bHYPRE\_Solver\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.5.12}
\cxxitem{\ struct\ \ bHYPRE\_Solver\_\_object*\ bHYPRE\_Solver\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.5.13}
\cxxitem{void*\ }
        {bHYPRE\_Solver\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.5.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Solver\_\_exec}
        {(\ \ bHYPRE\_Solver\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.5.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_Solver\_\_getURL}
        {(\ \ bHYPRE\_Solver\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.5.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Solver\_\_raddRef}
        {(\ \ bHYPRE\_Solver\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.5.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_Solver\_\_isRemote}
        {(\ \ bHYPRE\_Solver\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.5.18}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_Solver\_\_isLocal}
        {(\ \ bHYPRE\_Solver\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.5.19}
\cxxitem{\ struct\ \ bHYPRE\_Solver\_\_object*\ bHYPRE\_Solver\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.5.20}
\cxxitem{\ struct\ \ bHYPRE\_Solver\_\_object*\ bHYPRE\_Solver\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {5.8}
\cxxitem{}
        {Identity Solver (does nothing)}
        {}
        {
}
        {5.9}
\cxxitem{}
        {Hybrid Solver}
        {}
        {
}
        {5.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_Solver\_\_object}
        {}
        {
Symbol "bHYPRE}
        {5.1}
\begin{cxxdoc}

Symbol "bHYPRE.Solver" (version 1.0.0)
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{extern\ \ C\ \ bHYPRE\_Solver\ }
        {bHYPRE\_Solver\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {5.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Solver\_SetOperator}
        {(\ \ bHYPRE\_Solver\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {5.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Solver\_SetTolerance}
        {(\ \ bHYPRE\_Solver\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {5.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Solver\_SetMaxIterations}
        {(\ \ bHYPRE\_Solver\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {5.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Solver\_SetLogging}
        {(\ \ bHYPRE\_Solver\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {5.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Solver\_SetPrintLevel}
        {(\ \ bHYPRE\_Solver\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {5.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_Solver\_\_object*\ bHYPRE\_Solver\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {5.8}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxentry}
{}
        {Identity Solver (does nothing)}
        {}
        {
}
        {5.9}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_IdentitySolver\_\_object}
        {}
        {
Symbol "bHYPRE}
        {5.9.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_IdentitySolver\_\_object*\ bHYPRE\_IdentitySolver\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.5.9.11}
\cxxitem{bHYPRE\_IdentitySolver\ }
        {bHYPRE\_IdentitySolver\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.5.9.12}
\cxxitem{bHYPRE\_IdentitySolver\ }
        {bHYPRE\_IdentitySolver\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_IdentitySolver\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.5.9.13}
\cxxitem{bHYPRE\_IdentitySolver\ }
        {bHYPRE\_IdentitySolver\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {5.9.2}
\cxxitem{bHYPRE\_IdentitySolver\ }
        {bHYPRE\_IdentitySolver\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create an Identity (null) solver}
        {}
\label{cxx.5.9.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetOperator}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {5.9.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetTolerance}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {5.9.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetMaxIterations}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {5.9.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetLogging}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {5.9.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetPrintLevel}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {5.9.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_GetNumIterations}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.5.9.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_GetRelResidualNorm}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.5.9.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetCommunicator}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {5.9.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IdentitySolver\_Destroy}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {5.9.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetIntParameter}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.5.9.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetDoubleParameter}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.5.9.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetStringParameter}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.5.9.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.5.9.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.5.9.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.5.9.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.5.9.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_GetIntValue}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.5.9.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_GetDoubleValue}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.5.9.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_Setup}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.5.9.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_Apply}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.5.9.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_ApplyAdjoint}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.5.9.28}
\cxxitem{\ struct\ \ bHYPRE\_IdentitySolver\_\_object*\ bHYPRE\_IdentitySolver\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.5.9.29}
\cxxitem{void*\ }
        {bHYPRE\_IdentitySolver\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.5.9.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IdentitySolver\_\_exec}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.5.9.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_IdentitySolver\_\_getURL}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.5.9.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IdentitySolver\_\_raddRef}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.5.9.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_IdentitySolver\_\_isRemote}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.5.9.34}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_IdentitySolver\_\_isLocal}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.5.9.35}
\cxxitem{\ struct\ \ bHYPRE\_IdentitySolver\_\_object*\ bHYPRE\_IdentitySolver\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.5.9.36}
\cxxitem{\ struct\ \ bHYPRE\_IdentitySolver\_\_object*\ bHYPRE\_IdentitySolver\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {5.9.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_IdentitySolver\_\_object}
        {}
        {
Symbol "bHYPRE}
        {5.9.1}
\begin{cxxdoc}

Symbol "bHYPRE.IdentitySolver" (version 1.0.0)

Identity solver, just solves an identity matrix, for when you don't really
want a preconditioner

Objects of this type can be cast to Solver objects using the
{\tt \_\_cast} methods.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_IdentitySolver\ }
        {bHYPRE\_IdentitySolver\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {5.9.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetOperator}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {5.9.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetTolerance}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {5.9.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetMaxIterations}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {5.9.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetLogging}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {5.9.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetPrintLevel}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {5.9.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_IdentitySolver\_SetCommunicator}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {5.9.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_IdentitySolver\_Destroy}
        {(\ \ bHYPRE\_IdentitySolver\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {5.9.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_IdentitySolver\_\_object*\ bHYPRE\_IdentitySolver\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {5.9.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Hybrid Solver}
        {}
        {
}
        {5.10}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_Hybrid\_\_object}
        {}
        {
Symbol "bHYPRE}
        {5.10.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_Hybrid\_\_object*\ bHYPRE\_Hybrid\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.5.10.11}
\cxxitem{bHYPRE\_Hybrid\ }
        {bHYPRE\_Hybrid\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.5.10.12}
\cxxitem{bHYPRE\_Hybrid\ }
        {bHYPRE\_Hybrid\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_Hybrid\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.5.10.13}
\cxxitem{bHYPRE\_Hybrid\ }
        {bHYPRE\_Hybrid\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {5.10.2}
\cxxitem{bHYPRE\_Hybrid\ }
        {bHYPRE\_Hybrid\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_PreconditionedSolver\ SecondSolver,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a Hybrid solver}
        {}
\label{cxx.5.10.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_GetFirstSolver}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ bHYPRE\_PreconditionedSolver*\ FirstSolver,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  GetFirstSolver[]}
        {}
\label{cxx.5.10.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_GetSecondSolver}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ bHYPRE\_PreconditionedSolver*\ SecondSolver,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  GetSecondSolver[]}
        {}
\label{cxx.5.10.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetOperator}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {5.10.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetTolerance}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {5.10.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetMaxIterations}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {5.10.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetLogging}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {5.10.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetPrintLevel}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {5.10.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_GetNumIterations}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.5.10.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_GetRelResidualNorm}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.5.10.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetCommunicator}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {5.10.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Hybrid\_Destroy}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {5.10.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetIntParameter}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.5.10.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetDoubleParameter}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.5.10.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetStringParameter}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.5.10.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.5.10.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.5.10.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.5.10.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.5.10.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_GetIntValue}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.5.10.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_GetDoubleValue}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.5.10.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_Setup}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.5.10.28}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_Apply}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.5.10.29}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_ApplyAdjoint}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.5.10.30}
\cxxitem{\ struct\ \ bHYPRE\_Hybrid\_\_object*\ bHYPRE\_Hybrid\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.5.10.31}
\cxxitem{void*\ }
        {bHYPRE\_Hybrid\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.5.10.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Hybrid\_\_exec}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.5.10.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_Hybrid\_\_getURL}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.5.10.34}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Hybrid\_\_raddRef}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.5.10.35}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_Hybrid\_\_isRemote}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.5.10.36}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_Hybrid\_\_isLocal}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.5.10.37}
\cxxitem{\ struct\ \ bHYPRE\_Hybrid\_\_object*\ bHYPRE\_Hybrid\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.5.10.38}
\cxxitem{\ struct\ \ bHYPRE\_Hybrid\_\_object*\ bHYPRE\_Hybrid\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {5.10.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_Hybrid\_\_object}
        {}
        {
Symbol "bHYPRE}
        {5.10.1}
\begin{cxxdoc}

Symbol "bHYPRE.Hybrid" (version 1.0.0)

Hybrid solver
first tries to solve with the specified Krylov solver, preconditioned by
If that fails to converge, it will try again with the user-specified

Specify the preconditioner  by calling SecondSolver's SetPreconditioner
method.  If no preconditioner is specified (equivalently, if the
preconditioner for SecondSolver is IdentitySolver), the preconditioner for
the second try will be one of the following defaults.
StructMatrix: SMG.  other matrix types: not implemented

The Hybrid solver's Setup method will call Setup on KrylovSolver, so the
user should not call Setup on KrylovSolver.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_Hybrid\ }
        {bHYPRE\_Hybrid\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {5.10.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetOperator}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {5.10.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetTolerance}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {5.10.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetMaxIterations}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {5.10.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetLogging}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {5.10.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetPrintLevel}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {5.10.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Hybrid\_SetCommunicator}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {5.10.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Hybrid\_Destroy}
        {(\ \ bHYPRE\_Hybrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {5.10.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_Hybrid\_\_object*\ bHYPRE\_Hybrid\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {5.10.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR Matrix Solvers}
        {}
        {Linear solvers for sparse matrix systems}
        {6}
\begin{cxxnames}
\cxxitem{}
        {ParCSRDiagScale Solver}
        {}
        {
}
        {6.1}
\cxxitem{}
        {ParCSR BoomerAMG Solver}
        {}
        {
}
        {6.2}
\cxxitem{}
        {ParCSR Euclid Solver}
        {}
        {
}
        {6.3}
\cxxitem{}
        {ParCSR Schwarz Solver}
        {}
        {
}
        {6.4}
\cxxitem{}
        {ParCSR ParaSails Solver}
        {}
        {
}
        {6.5}
\cxxitem{}
        {ParCSR Pilut Solver}
        {}
        {
}
        {6.6}
\end{cxxnames}
\begin{cxxdoc}


These solvers use matrix/vector storage schemes that are tailored
for general sparse matrix systems.


\end{cxxdoc}
\begin{cxxentry}
{}
        {ParCSRDiagScale Solver}
        {}
        {
}
        {6.1}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_ParCSRDiagScale\_\_object}
        {}
        {
Symbol "bHYPRE}
        {6.1.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_ParCSRDiagScale\_\_object*\ bHYPRE\_ParCSRDiagScale\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.6.1.11}
\cxxitem{bHYPRE\_ParCSRDiagScale\ }
        {bHYPRE\_ParCSRDiagScale\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.6.1.12}
\cxxitem{bHYPRE\_ParCSRDiagScale\ }
        {bHYPRE\_ParCSRDiagScale\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_ParCSRDiagScale\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.6.1.13}
\cxxitem{bHYPRE\_ParCSRDiagScale\ }
        {bHYPRE\_ParCSRDiagScale\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {6.1.2}
\cxxitem{bHYPRE\_ParCSRDiagScale\ }
        {bHYPRE\_ParCSRDiagScale\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_IJParCSRMatrix\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a ParCSR DiagScale solver}
        {}
\label{cxx.6.1.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetOperator}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {6.1.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetTolerance}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {6.1.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetMaxIterations}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {6.1.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetLogging}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {6.1.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetPrintLevel}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {6.1.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_GetNumIterations}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.6.1.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_GetRelResidualNorm}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.6.1.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetCommunicator}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {6.1.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_ParCSRDiagScale\_Destroy}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {6.1.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetIntParameter}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.6.1.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetDoubleParameter}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.6.1.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetStringParameter}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.6.1.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.1.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.1.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.1.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.1.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_GetIntValue}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.6.1.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_GetDoubleValue}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.6.1.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_Setup}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.6.1.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_Apply}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.6.1.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_ApplyAdjoint}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.6.1.28}
\cxxitem{\ struct\ \ bHYPRE\_ParCSRDiagScale\_\_object*\ bHYPRE\_ParCSRDiagScale\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.6.1.29}
\cxxitem{void*\ }
        {bHYPRE\_ParCSRDiagScale\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.6.1.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_ParCSRDiagScale\_\_exec}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.6.1.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_ParCSRDiagScale\_\_getURL}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.6.1.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_ParCSRDiagScale\_\_raddRef}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.6.1.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_ParCSRDiagScale\_\_isRemote}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.6.1.34}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_ParCSRDiagScale\_\_isLocal}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.6.1.35}
\cxxitem{\ struct\ \ bHYPRE\_ParCSRDiagScale\_\_object*\ bHYPRE\_ParCSRDiagScale\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.6.1.36}
\cxxitem{\ struct\ \ bHYPRE\_ParCSRDiagScale\_\_object*\ bHYPRE\_ParCSRDiagScale\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {6.1.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_ParCSRDiagScale\_\_object}
        {}
        {
Symbol "bHYPRE}
        {6.1.1}
\begin{cxxdoc}

Symbol "bHYPRE.ParCSRDiagScale" (version 1.0.0)

Diagonal scaling preconditioner for ParCSR matrix class.

Objects of this type can be cast to Solver objects using the
{\tt \_\_cast} methods.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_ParCSRDiagScale\ }
        {bHYPRE\_ParCSRDiagScale\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {6.1.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetOperator}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {6.1.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetTolerance}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {6.1.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetMaxIterations}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {6.1.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetLogging}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {6.1.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetPrintLevel}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {6.1.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParCSRDiagScale\_SetCommunicator}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {6.1.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_ParCSRDiagScale\_Destroy}
        {(\ \ bHYPRE\_ParCSRDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {6.1.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_ParCSRDiagScale\_\_object*\ bHYPRE\_ParCSRDiagScale\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {6.1.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR BoomerAMG Solver}
        {}
        {
}
        {6.2}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_BoomerAMG\_\_object}
        {}
        {
Symbol "bHYPRE}
        {6.2.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_BoomerAMG\_\_object*\ bHYPRE\_BoomerAMG\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.6.2.11}
\cxxitem{bHYPRE\_BoomerAMG\ }
        {bHYPRE\_BoomerAMG\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.6.2.12}
\cxxitem{bHYPRE\_BoomerAMG\ }
        {bHYPRE\_BoomerAMG\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_BoomerAMG\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.6.2.13}
\cxxitem{bHYPRE\_BoomerAMG\ }
        {bHYPRE\_BoomerAMG\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {6.2.2}
\cxxitem{bHYPRE\_BoomerAMG\ }
        {bHYPRE\_BoomerAMG\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_IJParCSRMatrix\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a BoomerAMG solver}
        {}
\label{cxx.6.2.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetLevelRelaxWt}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ double\ relax\_wt,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  SetLevelRelaxWt[]}
        {}
\label{cxx.6.2.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_InitGridRelaxation}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ struct\ sidl\_int\_\_array**\ num\_grid\_sweeps,\ \ struct\ sidl\_int\_\_array**\ grid\_relax\_type,\ \ struct\ sidl\_int\_\_array**\ grid\_relax\_points,\ \ int32\_t\ coarsen\_type,\ \ struct\ sidl\_double\_\_array**\ relax\_weights,\ \ int32\_t\ max\_levels,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  InitGridRelaxation[]}
        {}
\label{cxx.6.2.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetOperator}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {6.2.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetTolerance}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {6.2.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetMaxIterations}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {6.2.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetLogging}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {6.2.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetPrintLevel}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {6.2.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_GetNumIterations}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.6.2.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_GetRelResidualNorm}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.6.2.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetCommunicator}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {6.2.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_BoomerAMG\_Destroy}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {6.2.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetIntParameter}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.6.2.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetDoubleParameter}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.6.2.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetStringParameter}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.6.2.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.2.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.2.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.2.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.2.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_GetIntValue}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.6.2.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_GetDoubleValue}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.6.2.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_Setup}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.6.2.28}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_Apply}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.6.2.29}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_ApplyAdjoint}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.6.2.30}
\cxxitem{\ struct\ \ bHYPRE\_BoomerAMG\_\_object*\ bHYPRE\_BoomerAMG\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.6.2.31}
\cxxitem{void*\ }
        {bHYPRE\_BoomerAMG\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.6.2.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_BoomerAMG\_\_exec}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.6.2.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_BoomerAMG\_\_getURL}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.6.2.34}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_BoomerAMG\_\_raddRef}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.6.2.35}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_BoomerAMG\_\_isRemote}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.6.2.36}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_BoomerAMG\_\_isLocal}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.6.2.37}
\cxxitem{\ struct\ \ bHYPRE\_BoomerAMG\_\_object*\ bHYPRE\_BoomerAMG\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.6.2.38}
\cxxitem{\ struct\ \ bHYPRE\_BoomerAMG\_\_object*\ bHYPRE\_BoomerAMG\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {6.2.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_BoomerAMG\_\_object}
        {}
        {
Symbol "bHYPRE}
        {6.2.1}
\begin{cxxdoc}

Symbol "bHYPRE.BoomerAMG" (version 1.0.0)

Algebraic multigrid solver, based on classical Ruge-Stueben.

BoomerAMG requires an IJParCSR matrix

The following optional parameters are available and may be set
using the appropriate {\tt Parameter} function (as indicated in
parentheses):

\begin{description}

\item[MaxLevels] ({\tt Int}) - maximum number of multigrid
levels.

\item[StrongThreshold] ({\tt Double}) - AMG strength threshold.

\item[MaxRowSum] ({\tt Double}) -

\item[CoarsenType] ({\tt Int}) - type of parallel coarsening
algorithm used.

\item[MeasureType] ({\tt Int}) - type of measure used; local or
global.

\item[CycleType] ({\tt Int}) - type of cycle used; a V-cycle
(default) or a W-cycle.

\item[NumGridSweeps] ({\tt IntArray 1D}) - number of sweeps for
fine and coarse grid, up and down cycle. DEPRECATED:
Use NumSweeps or Cycle?NumSweeps instead.

\item[NumSweeps] ({\tt Int}) - number of sweeps for fine grid, up and
down cycle.

\item[Cycle1NumSweeps] ({\tt Int}) - number of sweeps for down cycle

\item[Cycle2NumSweeps] ({\tt Int}) - number of sweeps for up cycle

\item[Cycle3NumSweeps] ({\tt Int}) - number of sweeps for coarse grid

\item[GridRelaxType] ({\tt IntArray 1D}) - type of smoother used on
fine and coarse grid, up and down cycle. DEPRECATED:
Use RelaxType or Cycle?RelaxType instead.

\item[RelaxType] ({\tt Int}) - type of smoother for fine grid, up and
down cycle.

\item[Cycle1RelaxType] ({\tt Int}) - type of smoother for down cycle

\item[Cycle2RelaxType] ({\tt Int}) - type of smoother for up cycle

\item[Cycle3RelaxType] ({\tt Int}) - type of smoother for coarse grid

\item[GridRelaxPoints] ({\tt IntArray 2D}) - point ordering used in
relaxation.  DEPRECATED.

\item[RelaxWeight] ({\tt DoubleArray 1D}) - relaxation weight for
smoothed Jacobi and hybrid SOR.  DEPRECATED:
Instead, use the RelaxWt parameter and the SetLevelRelaxWt function.

\item[RelaxWt] ({\tt Int}) - relaxation weight for all levels for
smoothed Jacobi and hybrid SOR.

\item[TruncFactor] ({\tt Double}) - truncation factor for
interpolation.

\item[JacobiTruncThreshold] ({\tt Double}) - threshold for truncation
of Jacobi interpolation.

\item[SmoothType] ({\tt Int}) - more complex smoothers.

\item[SmoothNumLevels] ({\tt Int}) - number of levels for more
complex smoothers.

\item[SmoothNumSweeps] ({\tt Int}) - number of sweeps for more
complex smoothers.

\item[PrintFileName] ({\tt String}) - name of file printed to in
association with {\tt SetPrintLevel}.

\item[NumFunctions] ({\tt Int}) - size of the system of PDEs
(when using the systems version).

\item[DOFFunc] ({\tt IntArray 1D}) - mapping that assigns the
function to each variable (when using the systems version).

\item[Variant] ({\tt Int}) - variant of Schwarz used.

\item[Overlap] ({\tt Int}) - overlap for Schwarz.

\item[DomainType] ({\tt Int}) - type of domain used for Schwarz.

\item[SchwarzRlxWeight] ({\tt Double}) - the smoothing parameter
for additive Schwarz.

\item[Tolerance] ({\tt Double}) - convergence tolerance, if this
is used as a solver; ignored if this is used as a preconditioner

\item[DebugFlag] ({\tt Int}) -

\item[InterpType] ({\tt Int}) - Defines which parallel interpolation
operator is used. There are the following options for interp\_type: 

\begin{tabular}{|c|l|} \hline
0 &	classical modified interpolation \\
1 &	LS interpolation (for use with GSMG) \\
2 &	classical modified interpolation for hyperbolic PDEs \\
3 &	direct interpolation (with separation of weights) \\
4 &	multipass interpolation \\
5 &	multipass interpolation (with separation of weights) \\
6 &  extended classical modified interpolation \\
7 &  extended (if no common C neighbor) classical modified interpolation \\
8 &	standard interpolation \\
9 &	standard interpolation (with separation of weights) \\
10 &	classical block interpolation (for use with nodal systems version only) \\
11 &	classical block interpolation (for use with nodal systems version only) \\
&	with diagonalized diagonal blocks \\
12 &	FF interpolation \\
13 &	FF1 interpolation \\
\hline
\end{tabular}

The default is 0. 

\item[NumSamples] ({\tt Int}) - Defines the number of sample vectors used
in GSMG or LS interpolation.

\item[MaxIterations] ({\tt Int}) - maximum number of iterations

\item[Logging] ({\tt Int}) - Set the {\it logging level}, specifying the
degree of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.

\item[PrintLevel] ({\tt Int}) - Set the {\it print level}, specifying the
degree of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.

\end{description}

The following function is specific to this class:

\begin{description}

\item[SetLevelRelxWeight] ({\tt Double , \tt Int}) -
relaxation weight for one specified level of smoothed Jacobi and hybrid SOR.

\end{description}

Objects of this type can be cast to Solver objects using the
{\tt \_\_cast} methods.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_BoomerAMG\ }
        {bHYPRE\_BoomerAMG\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {6.2.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetOperator}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {6.2.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetTolerance}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {6.2.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetMaxIterations}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {6.2.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetLogging}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {6.2.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetPrintLevel}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {6.2.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BoomerAMG\_SetCommunicator}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {6.2.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_BoomerAMG\_Destroy}
        {(\ \ bHYPRE\_BoomerAMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {6.2.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_BoomerAMG\_\_object*\ bHYPRE\_BoomerAMG\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {6.2.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR Euclid Solver}
        {}
        {
}
        {6.3}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_Euclid\_\_object}
        {}
        {
Symbol "bHYPRE}
        {6.3.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_Euclid\_\_object*\ bHYPRE\_Euclid\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.6.3.11}
\cxxitem{bHYPRE\_Euclid\ }
        {bHYPRE\_Euclid\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.6.3.12}
\cxxitem{bHYPRE\_Euclid\ }
        {bHYPRE\_Euclid\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_Euclid\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.6.3.13}
\cxxitem{bHYPRE\_Euclid\ }
        {bHYPRE\_Euclid\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {6.3.2}
\cxxitem{bHYPRE\_Euclid\ }
        {bHYPRE\_Euclid\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_IJParCSRMatrix\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a Euclid solver}
        {}
\label{cxx.6.3.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetParameters}
        {(\ \ bHYPRE\_Euclid\ self,\ \ int32\_t\ argc,\ \ char**\ argv,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  SetParameters[]}
        {}
\label{cxx.6.3.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetOperator}
        {(\ \ bHYPRE\_Euclid\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {6.3.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetTolerance}
        {(\ \ bHYPRE\_Euclid\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {6.3.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetMaxIterations}
        {(\ \ bHYPRE\_Euclid\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {6.3.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetLogging}
        {(\ \ bHYPRE\_Euclid\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {6.3.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetPrintLevel}
        {(\ \ bHYPRE\_Euclid\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {6.3.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_GetNumIterations}
        {(\ \ bHYPRE\_Euclid\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.6.3.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_GetRelResidualNorm}
        {(\ \ bHYPRE\_Euclid\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.6.3.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetCommunicator}
        {(\ \ bHYPRE\_Euclid\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {6.3.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Euclid\_Destroy}
        {(\ \ bHYPRE\_Euclid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {6.3.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetIntParameter}
        {(\ \ bHYPRE\_Euclid\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.6.3.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetDoubleParameter}
        {(\ \ bHYPRE\_Euclid\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.6.3.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetStringParameter}
        {(\ \ bHYPRE\_Euclid\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.6.3.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_Euclid\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.3.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_Euclid\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.3.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_Euclid\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.3.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_Euclid\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.3.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_GetIntValue}
        {(\ \ bHYPRE\_Euclid\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.6.3.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_GetDoubleValue}
        {(\ \ bHYPRE\_Euclid\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.6.3.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_Setup}
        {(\ \ bHYPRE\_Euclid\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.6.3.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_Apply}
        {(\ \ bHYPRE\_Euclid\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.6.3.28}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_ApplyAdjoint}
        {(\ \ bHYPRE\_Euclid\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.6.3.29}
\cxxitem{\ struct\ \ bHYPRE\_Euclid\_\_object*\ bHYPRE\_Euclid\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.6.3.30}
\cxxitem{void*\ }
        {bHYPRE\_Euclid\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.6.3.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Euclid\_\_exec}
        {(\ \ bHYPRE\_Euclid\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.6.3.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_Euclid\_\_getURL}
        {(\ \ bHYPRE\_Euclid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.6.3.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Euclid\_\_raddRef}
        {(\ \ bHYPRE\_Euclid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.6.3.34}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_Euclid\_\_isRemote}
        {(\ \ bHYPRE\_Euclid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.6.3.35}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_Euclid\_\_isLocal}
        {(\ \ bHYPRE\_Euclid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.6.3.36}
\cxxitem{\ struct\ \ bHYPRE\_Euclid\_\_object*\ bHYPRE\_Euclid\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.6.3.37}
\cxxitem{\ struct\ \ bHYPRE\_Euclid\_\_object*\ bHYPRE\_Euclid\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {6.3.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_Euclid\_\_object}
        {}
        {
Symbol "bHYPRE}
        {6.3.1}
\begin{cxxdoc}

Symbol "bHYPRE.Euclid" (version 1.0.0)

Objects of this type can be cast to Solver objects using the
{\tt \_\_cast} methods.

Although the usual Solver SetParameter functions are available,
a Euclid-stype parameter-setting function is also available, SetParameters.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_Euclid\ }
        {bHYPRE\_Euclid\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {6.3.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetOperator}
        {(\ \ bHYPRE\_Euclid\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {6.3.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetTolerance}
        {(\ \ bHYPRE\_Euclid\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {6.3.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetMaxIterations}
        {(\ \ bHYPRE\_Euclid\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {6.3.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetLogging}
        {(\ \ bHYPRE\_Euclid\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {6.3.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetPrintLevel}
        {(\ \ bHYPRE\_Euclid\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {6.3.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Euclid\_SetCommunicator}
        {(\ \ bHYPRE\_Euclid\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {6.3.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Euclid\_Destroy}
        {(\ \ bHYPRE\_Euclid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {6.3.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_Euclid\_\_object*\ bHYPRE\_Euclid\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {6.3.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR Schwarz Solver}
        {}
        {
}
        {6.4}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_Schwarz\_\_object}
        {}
        {
Symbol "bHYPRE}
        {6.4.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_Schwarz\_\_object*\ bHYPRE\_Schwarz\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.6.4.11}
\cxxitem{bHYPRE\_Schwarz\ }
        {bHYPRE\_Schwarz\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.6.4.12}
\cxxitem{bHYPRE\_Schwarz\ }
        {bHYPRE\_Schwarz\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_Schwarz\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.6.4.13}
\cxxitem{bHYPRE\_Schwarz\ }
        {bHYPRE\_Schwarz\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {6.4.2}
\cxxitem{bHYPRE\_Schwarz\ }
        {bHYPRE\_Schwarz\_Create}
        {(\ \ bHYPRE\_IJParCSRMatrix\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a Schwarz solver}
        {}
\label{cxx.6.4.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetOperator}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {6.4.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetTolerance}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {6.4.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetMaxIterations}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {6.4.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetLogging}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {6.4.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetPrintLevel}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {6.4.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_GetNumIterations}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.6.4.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_GetRelResidualNorm}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.6.4.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetCommunicator}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {6.4.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Schwarz\_Destroy}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {6.4.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetIntParameter}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.6.4.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetDoubleParameter}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.6.4.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetStringParameter}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.6.4.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.4.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.4.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.4.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.4.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_GetIntValue}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.6.4.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_GetDoubleValue}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.6.4.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_Setup}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.6.4.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_Apply}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.6.4.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_ApplyAdjoint}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.6.4.28}
\cxxitem{\ struct\ \ bHYPRE\_Schwarz\_\_object*\ bHYPRE\_Schwarz\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.6.4.29}
\cxxitem{void*\ }
        {bHYPRE\_Schwarz\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.6.4.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Schwarz\_\_exec}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.6.4.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_Schwarz\_\_getURL}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.6.4.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Schwarz\_\_raddRef}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.6.4.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_Schwarz\_\_isRemote}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.6.4.34}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_Schwarz\_\_isLocal}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.6.4.35}
\cxxitem{\ struct\ \ bHYPRE\_Schwarz\_\_object*\ bHYPRE\_Schwarz\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.6.4.36}
\cxxitem{\ struct\ \ bHYPRE\_Schwarz\_\_object*\ bHYPRE\_Schwarz\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {6.4.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_Schwarz\_\_object}
        {}
        {
Symbol "bHYPRE}
        {6.4.1}
\begin{cxxdoc}

Symbol "bHYPRE.Schwarz" (version 1.0.0)

Objects of this type can be cast to Solver objects using the
{\tt \_\_cast} methods.

Schwarz requires an IJParCSR matrix
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_Schwarz\ }
        {bHYPRE\_Schwarz\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {6.4.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetOperator}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {6.4.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetTolerance}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {6.4.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetMaxIterations}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {6.4.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetLogging}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {6.4.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetPrintLevel}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {6.4.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Schwarz\_SetCommunicator}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {6.4.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Schwarz\_Destroy}
        {(\ \ bHYPRE\_Schwarz\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {6.4.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_Schwarz\_\_object*\ bHYPRE\_Schwarz\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {6.4.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR ParaSails Solver}
        {}
        {
}
        {6.5}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_ParaSails\_\_object}
        {}
        {
Symbol "bHYPRE}
        {6.5.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_ParaSails\_\_object*\ bHYPRE\_ParaSails\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.6.5.11}
\cxxitem{bHYPRE\_ParaSails\ }
        {bHYPRE\_ParaSails\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.6.5.12}
\cxxitem{bHYPRE\_ParaSails\ }
        {bHYPRE\_ParaSails\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_ParaSails\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.6.5.13}
\cxxitem{bHYPRE\_ParaSails\ }
        {bHYPRE\_ParaSails\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {6.5.2}
\cxxitem{bHYPRE\_ParaSails\ }
        {bHYPRE\_ParaSails\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_IJParCSRMatrix\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a ParaSails solver}
        {}
\label{cxx.6.5.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetOperator}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {6.5.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetTolerance}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {6.5.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetMaxIterations}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {6.5.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetLogging}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {6.5.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetPrintLevel}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {6.5.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_GetNumIterations}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.6.5.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_GetRelResidualNorm}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.6.5.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetCommunicator}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {6.5.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_ParaSails\_Destroy}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {6.5.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetIntParameter}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.6.5.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetDoubleParameter}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.6.5.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetStringParameter}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.6.5.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.5.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.5.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.5.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.5.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_GetIntValue}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.6.5.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_GetDoubleValue}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.6.5.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_Setup}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.6.5.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_Apply}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.6.5.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_ApplyAdjoint}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.6.5.28}
\cxxitem{\ struct\ \ bHYPRE\_ParaSails\_\_object*\ bHYPRE\_ParaSails\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.6.5.29}
\cxxitem{void*\ }
        {bHYPRE\_ParaSails\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.6.5.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_ParaSails\_\_exec}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.6.5.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_ParaSails\_\_getURL}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.6.5.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_ParaSails\_\_raddRef}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.6.5.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_ParaSails\_\_isRemote}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.6.5.34}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_ParaSails\_\_isLocal}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.6.5.35}
\cxxitem{\ struct\ \ bHYPRE\_ParaSails\_\_object*\ bHYPRE\_ParaSails\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.6.5.36}
\cxxitem{\ struct\ \ bHYPRE\_ParaSails\_\_object*\ bHYPRE\_ParaSails\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {6.5.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_ParaSails\_\_object}
        {}
        {
Symbol "bHYPRE}
        {6.5.1}
\begin{cxxdoc}

Symbol "bHYPRE.ParaSails" (version 1.0.0)

Objects of this type can be cast to Solver objects using the
{\tt \_\_cast} methods.

ParaSails requires an IJParCSR matrix
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_ParaSails\ }
        {bHYPRE\_ParaSails\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {6.5.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetOperator}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {6.5.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetTolerance}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {6.5.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetMaxIterations}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {6.5.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetLogging}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {6.5.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetPrintLevel}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {6.5.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_ParaSails\_SetCommunicator}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {6.5.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_ParaSails\_Destroy}
        {(\ \ bHYPRE\_ParaSails\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {6.5.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_ParaSails\_\_object*\ bHYPRE\_ParaSails\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {6.5.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR Pilut Solver}
        {}
        {
}
        {6.6}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_Pilut\_\_object}
        {}
        {
Symbol "bHYPRE}
        {6.6.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_Pilut\_\_object*\ bHYPRE\_Pilut\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.6.6.11}
\cxxitem{bHYPRE\_Pilut\ }
        {bHYPRE\_Pilut\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.6.6.12}
\cxxitem{bHYPRE\_Pilut\ }
        {bHYPRE\_Pilut\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_Pilut\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.6.6.13}
\cxxitem{bHYPRE\_Pilut\ }
        {bHYPRE\_Pilut\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {6.6.2}
\cxxitem{bHYPRE\_Pilut\ }
        {bHYPRE\_Pilut\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a Pilut solver}
        {}
\label{cxx.6.6.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetOperator}
        {(\ \ bHYPRE\_Pilut\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {6.6.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetTolerance}
        {(\ \ bHYPRE\_Pilut\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {6.6.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetMaxIterations}
        {(\ \ bHYPRE\_Pilut\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {6.6.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetLogging}
        {(\ \ bHYPRE\_Pilut\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {6.6.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetPrintLevel}
        {(\ \ bHYPRE\_Pilut\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {6.6.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_GetNumIterations}
        {(\ \ bHYPRE\_Pilut\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.6.6.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_GetRelResidualNorm}
        {(\ \ bHYPRE\_Pilut\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.6.6.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetCommunicator}
        {(\ \ bHYPRE\_Pilut\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {6.6.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Pilut\_Destroy}
        {(\ \ bHYPRE\_Pilut\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {6.6.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetIntParameter}
        {(\ \ bHYPRE\_Pilut\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.6.6.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetDoubleParameter}
        {(\ \ bHYPRE\_Pilut\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.6.6.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetStringParameter}
        {(\ \ bHYPRE\_Pilut\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.6.6.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_Pilut\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.6.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_Pilut\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.6.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_Pilut\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.6.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_Pilut\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.6.6.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_GetIntValue}
        {(\ \ bHYPRE\_Pilut\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.6.6.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_GetDoubleValue}
        {(\ \ bHYPRE\_Pilut\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.6.6.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_Setup}
        {(\ \ bHYPRE\_Pilut\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.6.6.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_Apply}
        {(\ \ bHYPRE\_Pilut\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.6.6.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_ApplyAdjoint}
        {(\ \ bHYPRE\_Pilut\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.6.6.28}
\cxxitem{\ struct\ \ bHYPRE\_Pilut\_\_object*\ bHYPRE\_Pilut\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.6.6.29}
\cxxitem{void*\ }
        {bHYPRE\_Pilut\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.6.6.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Pilut\_\_exec}
        {(\ \ bHYPRE\_Pilut\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.6.6.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_Pilut\_\_getURL}
        {(\ \ bHYPRE\_Pilut\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.6.6.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Pilut\_\_raddRef}
        {(\ \ bHYPRE\_Pilut\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.6.6.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_Pilut\_\_isRemote}
        {(\ \ bHYPRE\_Pilut\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.6.6.34}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_Pilut\_\_isLocal}
        {(\ \ bHYPRE\_Pilut\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.6.6.35}
\cxxitem{\ struct\ \ bHYPRE\_Pilut\_\_object*\ bHYPRE\_Pilut\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.6.6.36}
\cxxitem{\ struct\ \ bHYPRE\_Pilut\_\_object*\ bHYPRE\_Pilut\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {6.6.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_Pilut\_\_object}
        {}
        {
Symbol "bHYPRE}
        {6.6.1}
\begin{cxxdoc}

Symbol "bHYPRE.Pilut" (version 1.0.0)

Objects of this type can be cast to Solver objects using the
{\tt \_\_cast} methods.

Pilut has not been implemented yet.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_Pilut\ }
        {bHYPRE\_Pilut\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {6.6.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetOperator}
        {(\ \ bHYPRE\_Pilut\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {6.6.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetTolerance}
        {(\ \ bHYPRE\_Pilut\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {6.6.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetMaxIterations}
        {(\ \ bHYPRE\_Pilut\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {6.6.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetLogging}
        {(\ \ bHYPRE\_Pilut\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {6.6.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetPrintLevel}
        {(\ \ bHYPRE\_Pilut\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {6.6.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_Pilut\_SetCommunicator}
        {(\ \ bHYPRE\_Pilut\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {6.6.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_Pilut\_Destroy}
        {(\ \ bHYPRE\_Pilut\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {6.6.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_Pilut\_\_object*\ bHYPRE\_Pilut\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {6.6.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{}
        {Structured Matrix Solvers}
        {}
        {Linear solvers for struct matrix systems}
        {7}
\begin{cxxnames}
\cxxitem{}
        {StructDiagScale Solver}
        {}
        {
}
        {7.1}
\cxxitem{}
        {Struct Jacobi Solver}
        {}
        {
}
        {7.2}
\cxxitem{}
        {Struct PFMG Solver}
        {}
        {
}
        {7.3}
\cxxitem{}
        {Struct SMG Solver}
        {}
        {
}
        {7.4}
\end{cxxnames}
\begin{cxxdoc}


These solvers use structured matrix/vector storage schemes.


\end{cxxdoc}
\begin{cxxentry}
{}
        {StructDiagScale Solver}
        {}
        {
}
        {7.1}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_StructDiagScale\_\_object}
        {}
        {
Symbol "bHYPRE}
        {7.1.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_StructDiagScale\_\_object*\ bHYPRE\_StructDiagScale\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.7.1.11}
\cxxitem{bHYPRE\_StructDiagScale\ }
        {bHYPRE\_StructDiagScale\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.7.1.12}
\cxxitem{bHYPRE\_StructDiagScale\ }
        {bHYPRE\_StructDiagScale\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_StructDiagScale\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.7.1.13}
\cxxitem{bHYPRE\_StructDiagScale\ }
        {bHYPRE\_StructDiagScale\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {7.1.2}
\cxxitem{bHYPRE\_StructDiagScale\ }
        {bHYPRE\_StructDiagScale\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_StructMatrix\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a Struct DiagScale solver}
        {}
\label{cxx.7.1.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetOperator}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {7.1.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetTolerance}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {7.1.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetMaxIterations}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {7.1.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetLogging}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {7.1.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetPrintLevel}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {7.1.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_GetNumIterations}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.7.1.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_GetRelResidualNorm}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.7.1.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetCommunicator}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {7.1.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructDiagScale\_Destroy}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {7.1.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetIntParameter}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.7.1.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetDoubleParameter}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.7.1.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetStringParameter}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.7.1.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.1.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.1.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.1.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.1.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_GetIntValue}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.7.1.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_GetDoubleValue}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.7.1.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_Setup}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.7.1.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_Apply}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.7.1.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_ApplyAdjoint}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.7.1.28}
\cxxitem{\ struct\ \ bHYPRE\_StructDiagScale\_\_object*\ bHYPRE\_StructDiagScale\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.7.1.29}
\cxxitem{void*\ }
        {bHYPRE\_StructDiagScale\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.7.1.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructDiagScale\_\_exec}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.7.1.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_StructDiagScale\_\_getURL}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.7.1.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructDiagScale\_\_raddRef}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.7.1.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_StructDiagScale\_\_isRemote}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.7.1.34}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_StructDiagScale\_\_isLocal}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.7.1.35}
\cxxitem{\ struct\ \ bHYPRE\_StructDiagScale\_\_object*\ bHYPRE\_StructDiagScale\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.7.1.36}
\cxxitem{\ struct\ \ bHYPRE\_StructDiagScale\_\_object*\ bHYPRE\_StructDiagScale\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {7.1.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_StructDiagScale\_\_object}
        {}
        {
Symbol "bHYPRE}
        {7.1.1}
\begin{cxxdoc}

Symbol "bHYPRE.StructDiagScale" (version 1.0.0)

Diagonal scaling preconditioner for STruct matrix class.

Objects of this type can be cast to Solver objects using the
{\tt \_\_cast} methods.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_StructDiagScale\ }
        {bHYPRE\_StructDiagScale\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {7.1.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetOperator}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {7.1.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetTolerance}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {7.1.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetMaxIterations}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {7.1.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetLogging}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {7.1.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetPrintLevel}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {7.1.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructDiagScale\_SetCommunicator}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {7.1.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructDiagScale\_Destroy}
        {(\ \ bHYPRE\_StructDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {7.1.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_StructDiagScale\_\_object*\ bHYPRE\_StructDiagScale\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {7.1.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct Jacobi Solver}
        {}
        {
}
        {7.2}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_StructJacobi\_\_object}
        {}
        {
Symbol "bHYPRE}
        {7.2.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_StructJacobi\_\_object*\ bHYPRE\_StructJacobi\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.7.2.11}
\cxxitem{bHYPRE\_StructJacobi\ }
        {bHYPRE\_StructJacobi\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.7.2.12}
\cxxitem{bHYPRE\_StructJacobi\ }
        {bHYPRE\_StructJacobi\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_StructJacobi\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.7.2.13}
\cxxitem{bHYPRE\_StructJacobi\ }
        {bHYPRE\_StructJacobi\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {7.2.2}
\cxxitem{bHYPRE\_StructJacobi\ }
        {bHYPRE\_StructJacobi\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_StructMatrix\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a Struct Jacobi solver}
        {}
\label{cxx.7.2.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetOperator}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {7.2.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetTolerance}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {7.2.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetMaxIterations}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {7.2.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetLogging}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {7.2.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetPrintLevel}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {7.2.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_GetNumIterations}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.7.2.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_GetRelResidualNorm}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.7.2.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetCommunicator}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {7.2.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructJacobi\_Destroy}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {7.2.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetIntParameter}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.7.2.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetDoubleParameter}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.7.2.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetStringParameter}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.7.2.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.2.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.2.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.2.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.2.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_GetIntValue}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.7.2.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_GetDoubleValue}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.7.2.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_Setup}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.7.2.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_Apply}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.7.2.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_ApplyAdjoint}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.7.2.28}
\cxxitem{\ struct\ \ bHYPRE\_StructJacobi\_\_object*\ bHYPRE\_StructJacobi\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.7.2.29}
\cxxitem{void*\ }
        {bHYPRE\_StructJacobi\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.7.2.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructJacobi\_\_exec}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.7.2.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_StructJacobi\_\_getURL}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.7.2.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructJacobi\_\_raddRef}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.7.2.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_StructJacobi\_\_isRemote}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.7.2.34}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_StructJacobi\_\_isLocal}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.7.2.35}
\cxxitem{\ struct\ \ bHYPRE\_StructJacobi\_\_object*\ bHYPRE\_StructJacobi\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.7.2.36}
\cxxitem{\ struct\ \ bHYPRE\_StructJacobi\_\_object*\ bHYPRE\_StructJacobi\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {7.2.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_StructJacobi\_\_object}
        {}
        {
Symbol "bHYPRE}
        {7.2.1}
\begin{cxxdoc}

Symbol "bHYPRE.StructJacobi" (version 1.0.0)

Objects of this type can be cast to Solver objects
using the {\tt \_\_cast} methods.

The StructJacobi solver requires a Struct matrix.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_StructJacobi\ }
        {bHYPRE\_StructJacobi\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {7.2.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetOperator}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {7.2.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetTolerance}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {7.2.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetMaxIterations}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {7.2.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetLogging}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {7.2.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetPrintLevel}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {7.2.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructJacobi\_SetCommunicator}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {7.2.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructJacobi\_Destroy}
        {(\ \ bHYPRE\_StructJacobi\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {7.2.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_StructJacobi\_\_object*\ bHYPRE\_StructJacobi\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {7.2.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct PFMG Solver}
        {}
        {
}
        {7.3}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_StructPFMG\_\_object}
        {}
        {
Symbol "bHYPRE}
        {7.3.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_StructPFMG\_\_object*\ bHYPRE\_StructPFMG\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.7.3.11}
\cxxitem{bHYPRE\_StructPFMG\ }
        {bHYPRE\_StructPFMG\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.7.3.12}
\cxxitem{bHYPRE\_StructPFMG\ }
        {bHYPRE\_StructPFMG\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_StructPFMG\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.7.3.13}
\cxxitem{bHYPRE\_StructPFMG\ }
        {bHYPRE\_StructPFMG\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {7.3.2}
\cxxitem{bHYPRE\_StructPFMG\ }
        {bHYPRE\_StructPFMG\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_StructMatrix\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a Struct PFMG solver}
        {}
\label{cxx.7.3.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetOperator}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {7.3.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetTolerance}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {7.3.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetMaxIterations}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {7.3.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetLogging}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {7.3.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetPrintLevel}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {7.3.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_GetNumIterations}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.7.3.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_GetRelResidualNorm}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.7.3.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetCommunicator}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {7.3.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructPFMG\_Destroy}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {7.3.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetIntParameter}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.7.3.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetDoubleParameter}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.7.3.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetStringParameter}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.7.3.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.3.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.3.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.3.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.3.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_GetIntValue}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.7.3.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_GetDoubleValue}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.7.3.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_Setup}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.7.3.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_Apply}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.7.3.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_ApplyAdjoint}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.7.3.28}
\cxxitem{\ struct\ \ bHYPRE\_StructPFMG\_\_object*\ bHYPRE\_StructPFMG\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.7.3.29}
\cxxitem{void*\ }
        {bHYPRE\_StructPFMG\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.7.3.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructPFMG\_\_exec}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.7.3.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_StructPFMG\_\_getURL}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.7.3.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructPFMG\_\_raddRef}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.7.3.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_StructPFMG\_\_isRemote}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.7.3.34}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_StructPFMG\_\_isLocal}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.7.3.35}
\cxxitem{\ struct\ \ bHYPRE\_StructPFMG\_\_object*\ bHYPRE\_StructPFMG\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.7.3.36}
\cxxitem{\ struct\ \ bHYPRE\_StructPFMG\_\_object*\ bHYPRE\_StructPFMG\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {7.3.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_StructPFMG\_\_object}
        {}
        {
Symbol "bHYPRE}
        {7.3.1}
\begin{cxxdoc}

Symbol "bHYPRE.StructPFMG" (version 1.0.0)

Objects of this type can be cast to Solver objects
using the {\tt \_\_cast} methods.

The StructPFMG solver requires a Struct matrix.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_StructPFMG\ }
        {bHYPRE\_StructPFMG\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {7.3.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetOperator}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {7.3.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetTolerance}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {7.3.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetMaxIterations}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {7.3.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetLogging}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {7.3.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetPrintLevel}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {7.3.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructPFMG\_SetCommunicator}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {7.3.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructPFMG\_Destroy}
        {(\ \ bHYPRE\_StructPFMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {7.3.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_StructPFMG\_\_object*\ bHYPRE\_StructPFMG\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {7.3.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct SMG Solver}
        {}
        {
}
        {7.4}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_StructSMG\_\_object}
        {}
        {
Symbol "bHYPRE}
        {7.4.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_StructSMG\_\_object*\ bHYPRE\_StructSMG\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.7.4.11}
\cxxitem{bHYPRE\_StructSMG\ }
        {bHYPRE\_StructSMG\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.7.4.12}
\cxxitem{bHYPRE\_StructSMG\ }
        {bHYPRE\_StructSMG\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_StructSMG\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.7.4.13}
\cxxitem{bHYPRE\_StructSMG\ }
        {bHYPRE\_StructSMG\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {7.4.2}
\cxxitem{bHYPRE\_StructSMG\ }
        {bHYPRE\_StructSMG\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_StructMatrix\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a Struct SMG solver}
        {}
\label{cxx.7.4.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetOperator}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {7.4.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetTolerance}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {7.4.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetMaxIterations}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {7.4.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetLogging}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {7.4.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetPrintLevel}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {7.4.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_GetNumIterations}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.7.4.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_GetRelResidualNorm}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.7.4.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetCommunicator}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {7.4.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructSMG\_Destroy}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {7.4.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetIntParameter}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.7.4.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetDoubleParameter}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.7.4.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetStringParameter}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.7.4.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.4.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.4.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.4.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.7.4.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_GetIntValue}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.7.4.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_GetDoubleValue}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.7.4.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_Setup}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.7.4.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_Apply}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.7.4.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_ApplyAdjoint}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.7.4.28}
\cxxitem{\ struct\ \ bHYPRE\_StructSMG\_\_object*\ bHYPRE\_StructSMG\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.7.4.29}
\cxxitem{void*\ }
        {bHYPRE\_StructSMG\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.7.4.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructSMG\_\_exec}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.7.4.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_StructSMG\_\_getURL}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.7.4.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructSMG\_\_raddRef}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.7.4.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_StructSMG\_\_isRemote}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.7.4.34}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_StructSMG\_\_isLocal}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.7.4.35}
\cxxitem{\ struct\ \ bHYPRE\_StructSMG\_\_object*\ bHYPRE\_StructSMG\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.7.4.36}
\cxxitem{\ struct\ \ bHYPRE\_StructSMG\_\_object*\ bHYPRE\_StructSMG\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {7.4.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_StructSMG\_\_object}
        {}
        {
Symbol "bHYPRE}
        {7.4.1}
\begin{cxxdoc}

Symbol "bHYPRE.StructSMG" (version 1.0.0)

Objects of this type can be cast to Solver objects
using the {\tt \_\_cast} methods.

The StructSMG solver requires a Struct matrix.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_StructSMG\ }
        {bHYPRE\_StructSMG\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {7.4.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetOperator}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {7.4.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetTolerance}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {7.4.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetMaxIterations}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {7.4.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetLogging}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {7.4.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetPrintLevel}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {7.4.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructSMG\_SetCommunicator}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {7.4.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructSMG\_Destroy}
        {(\ \ bHYPRE\_StructSMG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {7.4.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_StructSMG\_\_object*\ bHYPRE\_StructSMG\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {7.4.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{}
        {SemiStructured Matrix Solvers}
        {}
        {Linear solvers for semi-struct matrix systems}
        {8}
\begin{cxxnames}
\cxxitem{}
        {SemiStruct DiagScale Solver}
        {}
        {
}
        {8.1}
\cxxitem{}
        {Struct Split Solver}
        {}
        {
}
        {8.2}
\end{cxxnames}
\begin{cxxdoc}


These solvers use semi-structured matrix/vector storage schemes.


\end{cxxdoc}
\begin{cxxentry}
{}
        {SemiStruct DiagScale Solver}
        {}
        {
}
        {8.1}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_SStructDiagScale\_\_object}
        {}
        {
Symbol "bHYPRE}
        {8.1.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_SStructDiagScale\_\_object*\ bHYPRE\_SStructDiagScale\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.8.1.11}
\cxxitem{bHYPRE\_SStructDiagScale\ }
        {bHYPRE\_SStructDiagScale\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.8.1.12}
\cxxitem{bHYPRE\_SStructDiagScale\ }
        {bHYPRE\_SStructDiagScale\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_SStructDiagScale\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.8.1.13}
\cxxitem{bHYPRE\_SStructDiagScale\ }
        {bHYPRE\_SStructDiagScale\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {8.1.2}
\cxxitem{bHYPRE\_SStructDiagScale\ }
        {bHYPRE\_SStructDiagScale\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a SStruct DiagScale solver}
        {}
\label{cxx.8.1.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetOperator}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {8.1.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetTolerance}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {8.1.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetMaxIterations}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {8.1.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetLogging}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {8.1.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetPrintLevel}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {8.1.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_GetNumIterations}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.8.1.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_GetRelResidualNorm}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.8.1.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetCommunicator}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {8.1.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructDiagScale\_Destroy}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {8.1.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetIntParameter}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.8.1.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetDoubleParameter}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.8.1.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetStringParameter}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.8.1.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.8.1.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.8.1.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.8.1.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.8.1.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_GetIntValue}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.8.1.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_GetDoubleValue}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.8.1.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_Setup}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.8.1.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_Apply}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.8.1.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_ApplyAdjoint}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.8.1.28}
\cxxitem{\ struct\ \ bHYPRE\_SStructDiagScale\_\_object*\ bHYPRE\_SStructDiagScale\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.8.1.29}
\cxxitem{void*\ }
        {bHYPRE\_SStructDiagScale\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.8.1.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructDiagScale\_\_exec}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.8.1.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_SStructDiagScale\_\_getURL}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.8.1.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructDiagScale\_\_raddRef}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.8.1.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_SStructDiagScale\_\_isRemote}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.8.1.34}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_SStructDiagScale\_\_isLocal}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.8.1.35}
\cxxitem{\ struct\ \ bHYPRE\_SStructDiagScale\_\_object*\ bHYPRE\_SStructDiagScale\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.8.1.36}
\cxxitem{\ struct\ \ bHYPRE\_SStructDiagScale\_\_object*\ bHYPRE\_SStructDiagScale\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {8.1.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_SStructDiagScale\_\_object}
        {}
        {
Symbol "bHYPRE}
        {8.1.1}
\begin{cxxdoc}

Symbol "bHYPRE.SStructDiagScale" (version 1.0.0)
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_SStructDiagScale\ }
        {bHYPRE\_SStructDiagScale\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {8.1.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetOperator}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {8.1.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetTolerance}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {8.1.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetMaxIterations}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {8.1.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetLogging}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {8.1.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetPrintLevel}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {8.1.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructDiagScale\_SetCommunicator}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {8.1.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructDiagScale\_Destroy}
        {(\ \ bHYPRE\_SStructDiagScale\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {8.1.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_SStructDiagScale\_\_object*\ bHYPRE\_SStructDiagScale\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {8.1.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct Split Solver}
        {}
        {
}
        {8.2}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_SStructSplit\_\_object}
        {}
        {
Symbol "bHYPRE}
        {8.2.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_SStructSplit\_\_object*\ bHYPRE\_SStructSplit\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.8.2.11}
\cxxitem{bHYPRE\_SStructSplit\ }
        {bHYPRE\_SStructSplit\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.8.2.12}
\cxxitem{bHYPRE\_SStructSplit\ }
        {bHYPRE\_SStructSplit\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_SStructSplit\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.8.2.13}
\cxxitem{bHYPRE\_SStructSplit\ }
        {bHYPRE\_SStructSplit\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {8.2.2}
\cxxitem{bHYPRE\_SStructSplit\ }
        {bHYPRE\_SStructSplit\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a SStruct Split solver}
        {}
\label{cxx.8.2.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetOperator}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {8.2.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetTolerance}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {8.2.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetMaxIterations}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {8.2.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetLogging}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {8.2.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetPrintLevel}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {8.2.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_GetNumIterations}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.8.2.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_GetRelResidualNorm}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.8.2.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetCommunicator}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {8.2.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructSplit\_Destroy}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {8.2.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetIntParameter}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.8.2.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetDoubleParameter}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.8.2.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetStringParameter}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.8.2.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.8.2.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.8.2.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.8.2.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.8.2.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_GetIntValue}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.8.2.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_GetDoubleValue}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.8.2.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_Setup}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.8.2.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_Apply}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.8.2.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_ApplyAdjoint}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.8.2.28}
\cxxitem{\ struct\ \ bHYPRE\_SStructSplit\_\_object*\ bHYPRE\_SStructSplit\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.8.2.29}
\cxxitem{void*\ }
        {bHYPRE\_SStructSplit\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.8.2.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructSplit\_\_exec}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.8.2.31}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_SStructSplit\_\_getURL}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.8.2.32}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructSplit\_\_raddRef}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.8.2.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_SStructSplit\_\_isRemote}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.8.2.34}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_SStructSplit\_\_isLocal}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.8.2.35}
\cxxitem{\ struct\ \ bHYPRE\_SStructSplit\_\_object*\ bHYPRE\_SStructSplit\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.8.2.36}
\cxxitem{\ struct\ \ bHYPRE\_SStructSplit\_\_object*\ bHYPRE\_SStructSplit\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {8.2.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_SStructSplit\_\_object}
        {}
        {
Symbol "bHYPRE}
        {8.2.1}
\begin{cxxdoc}

Symbol "bHYPRE.SStructSplit" (version 1.0.0)


The SStructSplit solver requires a SStruct matrix.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_SStructSplit\ }
        {bHYPRE\_SStructSplit\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {8.2.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetOperator}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {8.2.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetTolerance}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {8.2.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetMaxIterations}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {8.2.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetLogging}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {8.2.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetPrintLevel}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {8.2.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructSplit\_SetCommunicator}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {8.2.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructSplit\_Destroy}
        {(\ \ bHYPRE\_SStructSplit\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {8.2.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_SStructSplit\_\_object*\ bHYPRE\_SStructSplit\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {8.2.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{}
        {PreconditionedSolver Interface}
        {}
        {
}
        {9}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_PreconditionedSolver\_\_object}
        {}
        {
Symbol "bHYPRE}
        {9.1}
\cxxitem{extern\ \ C\ \ bHYPRE\_PreconditionedSolver\ }
        {bHYPRE\_PreconditionedSolver\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {9.2}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PreconditionedSolver\_SetPreconditioner}
        {(\ \ bHYPRE\_PreconditionedSolver\ self,\ \ bHYPRE\_Solver\ s,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the preconditioner}
        {}
\label{cxx.9.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PreconditionedSolver\_GetPreconditioner}
        {(\ \ bHYPRE\_PreconditionedSolver\ self,\ \ bHYPRE\_Solver*\ s,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  GetPreconditioner[]}
        {}
\label{cxx.9.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PreconditionedSolver\_Clone}
        {(\ \ bHYPRE\_PreconditionedSolver\ self,\ \ bHYPRE\_PreconditionedSolver*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  Clone[]}
        {}
\label{cxx.9.6}
\cxxitem{\ struct\ \ bHYPRE\_PreconditionedSolver\_\_object*\ bHYPRE\_PreconditionedSolver\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.9.7}
\cxxitem{void*\ }
        {bHYPRE\_PreconditionedSolver\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.9.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_PreconditionedSolver\_\_exec}
        {(\ \ bHYPRE\_PreconditionedSolver\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.9.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_PreconditionedSolver\_\_getURL}
        {(\ \ bHYPRE\_PreconditionedSolver\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.9.10}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_PreconditionedSolver\_\_raddRef}
        {(\ \ bHYPRE\_PreconditionedSolver\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.9.11}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_PreconditionedSolver\_\_isRemote}
        {(\ \ bHYPRE\_PreconditionedSolver\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.9.12}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_PreconditionedSolver\_\_isLocal}
        {(\ \ bHYPRE\_PreconditionedSolver\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.9.13}
\cxxitem{\ struct\ \ bHYPRE\_PreconditionedSolver\_\_object*\ bHYPRE\_PreconditionedSolver\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.9.14}
\cxxitem{\ struct\ \ bHYPRE\_PreconditionedSolver\_\_object*\ bHYPRE\_PreconditionedSolver\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {9.3}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_PreconditionedSolver\_\_object}
        {}
        {
Symbol "bHYPRE}
        {9.1}
\begin{cxxdoc}

Symbol "bHYPRE.PreconditionedSolver" (version 1.0.0)
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{extern\ \ C\ \ bHYPRE\_PreconditionedSolver\ }
        {bHYPRE\_PreconditionedSolver\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {9.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_PreconditionedSolver\_\_object*\ bHYPRE\_PreconditionedSolver\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {9.3}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Preconditioned Solvers}
        {}
        {
}
        {10}
\begin{cxxnames}
\cxxitem{}
        {PCG Preconditioned Solver}
        {}
        {
}
        {10.1}
\cxxitem{}
        {GMRES Preconditioned Solver}
        {}
        {
}
        {10.2}
\cxxitem{}
        {BiCGSTAB Preconditioned Solver}
        {}
        {
}
        {10.3}
\cxxitem{}
        {CGNR Preconditioned Solver}
        {}
        {
}
        {10.4}
\end{cxxnames}
\begin{cxxentry}
{}
        {PCG Preconditioned Solver}
        {}
        {
}
        {10.1}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_PCG\_\_object}
        {}
        {
Symbol "bHYPRE}
        {10.1.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_PCG\_\_object*\ bHYPRE\_PCG\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.10.1.11}
\cxxitem{bHYPRE\_PCG\ }
        {bHYPRE\_PCG\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.10.1.12}
\cxxitem{bHYPRE\_PCG\ }
        {bHYPRE\_PCG\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_PCG\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.10.1.13}
\cxxitem{bHYPRE\_PCG\ }
        {bHYPRE\_PCG\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {10.1.2}
\cxxitem{bHYPRE\_PCG\ }
        {bHYPRE\_PCG\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a PCG solver}
        {}
\label{cxx.10.1.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetPreconditioner}
        {(\ \ bHYPRE\_PCG\ self,\ \ bHYPRE\_Solver\ s,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the preconditioner}
        {}
\label{cxx.10.1.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_GetPreconditioner}
        {(\ \ bHYPRE\_PCG\ self,\ \ bHYPRE\_Solver*\ s,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  GetPreconditioner[]}
        {}
\label{cxx.10.1.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_Clone}
        {(\ \ bHYPRE\_PCG\ self,\ \ bHYPRE\_PreconditionedSolver*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  Clone[]}
        {}
\label{cxx.10.1.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetOperator}
        {(\ \ bHYPRE\_PCG\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {10.1.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetTolerance}
        {(\ \ bHYPRE\_PCG\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {10.1.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetMaxIterations}
        {(\ \ bHYPRE\_PCG\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {10.1.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetLogging}
        {(\ \ bHYPRE\_PCG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {10.1.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetPrintLevel}
        {(\ \ bHYPRE\_PCG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {10.1.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_GetNumIterations}
        {(\ \ bHYPRE\_PCG\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.10.1.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_GetRelResidualNorm}
        {(\ \ bHYPRE\_PCG\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.10.1.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetCommunicator}
        {(\ \ bHYPRE\_PCG\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {10.1.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_PCG\_Destroy}
        {(\ \ bHYPRE\_PCG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {10.1.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetIntParameter}
        {(\ \ bHYPRE\_PCG\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.10.1.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetDoubleParameter}
        {(\ \ bHYPRE\_PCG\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.10.1.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetStringParameter}
        {(\ \ bHYPRE\_PCG\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.10.1.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_PCG\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.1.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_PCG\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.1.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_PCG\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.1.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_PCG\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.1.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_GetIntValue}
        {(\ \ bHYPRE\_PCG\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.10.1.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_GetDoubleValue}
        {(\ \ bHYPRE\_PCG\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.10.1.28}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_Setup}
        {(\ \ bHYPRE\_PCG\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.10.1.29}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_Apply}
        {(\ \ bHYPRE\_PCG\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.10.1.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_ApplyAdjoint}
        {(\ \ bHYPRE\_PCG\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.10.1.31}
\cxxitem{\ struct\ \ bHYPRE\_PCG\_\_object*\ bHYPRE\_PCG\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.10.1.32}
\cxxitem{void*\ }
        {bHYPRE\_PCG\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.10.1.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_PCG\_\_exec}
        {(\ \ bHYPRE\_PCG\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.10.1.34}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_PCG\_\_getURL}
        {(\ \ bHYPRE\_PCG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.10.1.35}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_PCG\_\_raddRef}
        {(\ \ bHYPRE\_PCG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.10.1.36}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_PCG\_\_isRemote}
        {(\ \ bHYPRE\_PCG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.10.1.37}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_PCG\_\_isLocal}
        {(\ \ bHYPRE\_PCG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.10.1.38}
\cxxitem{\ struct\ \ bHYPRE\_PCG\_\_object*\ bHYPRE\_PCG\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.10.1.39}
\cxxitem{\ struct\ \ bHYPRE\_PCG\_\_object*\ bHYPRE\_PCG\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {10.1.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_PCG\_\_object}
        {}
        {
Symbol "bHYPRE}
        {10.1.1}
\begin{cxxdoc}

Symbol "bHYPRE.PCG" (version 1.0.0)

PCG solver.
This calls Babel-interface matrix and vector functions, so it will work
with any consistent matrix, vector, and preconditioner classes.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_PCG\ }
        {bHYPRE\_PCG\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {10.1.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetOperator}
        {(\ \ bHYPRE\_PCG\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {10.1.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetTolerance}
        {(\ \ bHYPRE\_PCG\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {10.1.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetMaxIterations}
        {(\ \ bHYPRE\_PCG\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {10.1.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetLogging}
        {(\ \ bHYPRE\_PCG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {10.1.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetPrintLevel}
        {(\ \ bHYPRE\_PCG\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {10.1.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_PCG\_SetCommunicator}
        {(\ \ bHYPRE\_PCG\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {10.1.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_PCG\_Destroy}
        {(\ \ bHYPRE\_PCG\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {10.1.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_PCG\_\_object*\ bHYPRE\_PCG\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {10.1.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {GMRES Preconditioned Solver}
        {}
        {
}
        {10.2}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_GMRES\_\_object}
        {}
        {
Symbol "bHYPRE}
        {10.2.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_GMRES\_\_object*\ bHYPRE\_GMRES\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.10.2.11}
\cxxitem{bHYPRE\_GMRES\ }
        {bHYPRE\_GMRES\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.10.2.12}
\cxxitem{bHYPRE\_GMRES\ }
        {bHYPRE\_GMRES\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_GMRES\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.10.2.13}
\cxxitem{bHYPRE\_GMRES\ }
        {bHYPRE\_GMRES\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {10.2.2}
\cxxitem{bHYPRE\_GMRES\ }
        {bHYPRE\_GMRES\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a GMRES solver}
        {}
\label{cxx.10.2.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetPreconditioner}
        {(\ \ bHYPRE\_GMRES\ self,\ \ bHYPRE\_Solver\ s,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the preconditioner}
        {}
\label{cxx.10.2.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_GetPreconditioner}
        {(\ \ bHYPRE\_GMRES\ self,\ \ bHYPRE\_Solver*\ s,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  GetPreconditioner[]}
        {}
\label{cxx.10.2.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_Clone}
        {(\ \ bHYPRE\_GMRES\ self,\ \ bHYPRE\_PreconditionedSolver*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  Clone[]}
        {}
\label{cxx.10.2.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetOperator}
        {(\ \ bHYPRE\_GMRES\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {10.2.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetTolerance}
        {(\ \ bHYPRE\_GMRES\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {10.2.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetMaxIterations}
        {(\ \ bHYPRE\_GMRES\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {10.2.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetLogging}
        {(\ \ bHYPRE\_GMRES\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {10.2.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetPrintLevel}
        {(\ \ bHYPRE\_GMRES\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {10.2.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_GetNumIterations}
        {(\ \ bHYPRE\_GMRES\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.10.2.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_GetRelResidualNorm}
        {(\ \ bHYPRE\_GMRES\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.10.2.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetCommunicator}
        {(\ \ bHYPRE\_GMRES\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {10.2.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_GMRES\_Destroy}
        {(\ \ bHYPRE\_GMRES\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {10.2.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetIntParameter}
        {(\ \ bHYPRE\_GMRES\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.10.2.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetDoubleParameter}
        {(\ \ bHYPRE\_GMRES\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.10.2.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetStringParameter}
        {(\ \ bHYPRE\_GMRES\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.10.2.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_GMRES\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.2.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_GMRES\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.2.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_GMRES\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.2.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_GMRES\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.2.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_GetIntValue}
        {(\ \ bHYPRE\_GMRES\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.10.2.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_GetDoubleValue}
        {(\ \ bHYPRE\_GMRES\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.10.2.28}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_Setup}
        {(\ \ bHYPRE\_GMRES\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.10.2.29}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_Apply}
        {(\ \ bHYPRE\_GMRES\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.10.2.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_ApplyAdjoint}
        {(\ \ bHYPRE\_GMRES\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.10.2.31}
\cxxitem{\ struct\ \ bHYPRE\_GMRES\_\_object*\ bHYPRE\_GMRES\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.10.2.32}
\cxxitem{void*\ }
        {bHYPRE\_GMRES\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.10.2.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_GMRES\_\_exec}
        {(\ \ bHYPRE\_GMRES\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.10.2.34}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_GMRES\_\_getURL}
        {(\ \ bHYPRE\_GMRES\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.10.2.35}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_GMRES\_\_raddRef}
        {(\ \ bHYPRE\_GMRES\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.10.2.36}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_GMRES\_\_isRemote}
        {(\ \ bHYPRE\_GMRES\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.10.2.37}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_GMRES\_\_isLocal}
        {(\ \ bHYPRE\_GMRES\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.10.2.38}
\cxxitem{\ struct\ \ bHYPRE\_GMRES\_\_object*\ bHYPRE\_GMRES\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.10.2.39}
\cxxitem{\ struct\ \ bHYPRE\_GMRES\_\_object*\ bHYPRE\_GMRES\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {10.2.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_GMRES\_\_object}
        {}
        {
Symbol "bHYPRE}
        {10.2.1}
\begin{cxxdoc}

Symbol "bHYPRE.GMRES" (version 1.0.0)

GMRES solver.
This calls Babel-interface matrix and vector functions, so it will work
with any consistent matrix, vector, and preconditioner classes.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_GMRES\ }
        {bHYPRE\_GMRES\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {10.2.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetOperator}
        {(\ \ bHYPRE\_GMRES\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {10.2.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetTolerance}
        {(\ \ bHYPRE\_GMRES\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {10.2.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetMaxIterations}
        {(\ \ bHYPRE\_GMRES\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {10.2.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetLogging}
        {(\ \ bHYPRE\_GMRES\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {10.2.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetPrintLevel}
        {(\ \ bHYPRE\_GMRES\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {10.2.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_GMRES\_SetCommunicator}
        {(\ \ bHYPRE\_GMRES\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {10.2.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_GMRES\_Destroy}
        {(\ \ bHYPRE\_GMRES\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {10.2.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_GMRES\_\_object*\ bHYPRE\_GMRES\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {10.2.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {BiCGSTAB Preconditioned Solver}
        {}
        {
}
        {10.3}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_BiCGSTAB\_\_object}
        {}
        {
Symbol "bHYPRE}
        {10.3.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_BiCGSTAB\_\_object*\ bHYPRE\_BiCGSTAB\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.10.3.11}
\cxxitem{bHYPRE\_BiCGSTAB\ }
        {bHYPRE\_BiCGSTAB\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.10.3.12}
\cxxitem{bHYPRE\_BiCGSTAB\ }
        {bHYPRE\_BiCGSTAB\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_BiCGSTAB\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.10.3.13}
\cxxitem{bHYPRE\_BiCGSTAB\ }
        {bHYPRE\_BiCGSTAB\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {10.3.2}
\cxxitem{bHYPRE\_BiCGSTAB\ }
        {bHYPRE\_BiCGSTAB\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a BiCGSTAB solver}
        {}
\label{cxx.10.3.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetPreconditioner}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ bHYPRE\_Solver\ s,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the preconditioner}
        {}
\label{cxx.10.3.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_GetPreconditioner}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ bHYPRE\_Solver*\ s,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  GetPreconditioner[]}
        {}
\label{cxx.10.3.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_Clone}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ bHYPRE\_PreconditionedSolver*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  Clone[]}
        {}
\label{cxx.10.3.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetOperator}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {10.3.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetTolerance}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {10.3.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetMaxIterations}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {10.3.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetLogging}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {10.3.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetPrintLevel}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {10.3.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_GetNumIterations}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.10.3.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_GetRelResidualNorm}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.10.3.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetCommunicator}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {10.3.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_BiCGSTAB\_Destroy}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {10.3.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetIntParameter}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.10.3.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetDoubleParameter}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.10.3.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetStringParameter}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.10.3.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.3.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.3.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.3.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.3.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_GetIntValue}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.10.3.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_GetDoubleValue}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.10.3.28}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_Setup}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.10.3.29}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_Apply}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.10.3.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_ApplyAdjoint}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.10.3.31}
\cxxitem{\ struct\ \ bHYPRE\_BiCGSTAB\_\_object*\ bHYPRE\_BiCGSTAB\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.10.3.32}
\cxxitem{void*\ }
        {bHYPRE\_BiCGSTAB\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.10.3.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_BiCGSTAB\_\_exec}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.10.3.34}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_BiCGSTAB\_\_getURL}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.10.3.35}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_BiCGSTAB\_\_raddRef}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.10.3.36}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_BiCGSTAB\_\_isRemote}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.10.3.37}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_BiCGSTAB\_\_isLocal}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.10.3.38}
\cxxitem{\ struct\ \ bHYPRE\_BiCGSTAB\_\_object*\ bHYPRE\_BiCGSTAB\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.10.3.39}
\cxxitem{\ struct\ \ bHYPRE\_BiCGSTAB\_\_object*\ bHYPRE\_BiCGSTAB\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {10.3.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_BiCGSTAB\_\_object}
        {}
        {
Symbol "bHYPRE}
        {10.3.1}
\begin{cxxdoc}

Symbol "bHYPRE.BiCGSTAB" (version 1.0.0)

BiCGSTAB solver.
This calls Babel-interface matrix and vector functions, so it will work
with any consistent matrix, vector, and preconditioner classes.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_BiCGSTAB\ }
        {bHYPRE\_BiCGSTAB\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {10.3.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetOperator}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {10.3.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetTolerance}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {10.3.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetMaxIterations}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {10.3.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetLogging}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {10.3.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetPrintLevel}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {10.3.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_BiCGSTAB\_SetCommunicator}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {10.3.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_BiCGSTAB\_Destroy}
        {(\ \ bHYPRE\_BiCGSTAB\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {10.3.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_BiCGSTAB\_\_object*\ bHYPRE\_BiCGSTAB\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {10.3.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {CGNR Preconditioned Solver}
        {}
        {
}
        {10.4}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_CGNR\_\_object}
        {}
        {
Symbol "bHYPRE}
        {10.4.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_CGNR\_\_object*\ bHYPRE\_CGNR\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.10.4.11}
\cxxitem{bHYPRE\_CGNR\ }
        {bHYPRE\_CGNR\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.10.4.12}
\cxxitem{bHYPRE\_CGNR\ }
        {bHYPRE\_CGNR\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_CGNR\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.10.4.13}
\cxxitem{bHYPRE\_CGNR\ }
        {bHYPRE\_CGNR\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {10.4.2}
\cxxitem{bHYPRE\_CGNR\ }
        {bHYPRE\_CGNR\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a CGNR solver}
        {}
\label{cxx.10.4.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetPreconditioner}
        {(\ \ bHYPRE\_CGNR\ self,\ \ bHYPRE\_Solver\ s,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the preconditioner}
        {}
\label{cxx.10.4.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_GetPreconditioner}
        {(\ \ bHYPRE\_CGNR\ self,\ \ bHYPRE\_Solver*\ s,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  GetPreconditioner[]}
        {}
\label{cxx.10.4.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_Clone}
        {(\ \ bHYPRE\_CGNR\ self,\ \ bHYPRE\_PreconditionedSolver*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  Clone[]}
        {}
\label{cxx.10.4.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetOperator}
        {(\ \ bHYPRE\_CGNR\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {10.4.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetTolerance}
        {(\ \ bHYPRE\_CGNR\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {10.4.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetMaxIterations}
        {(\ \ bHYPRE\_CGNR\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {10.4.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetLogging}
        {(\ \ bHYPRE\_CGNR\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {10.4.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetPrintLevel}
        {(\ \ bHYPRE\_CGNR\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {10.4.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_GetNumIterations}
        {(\ \ bHYPRE\_CGNR\ self,\ \ int32\_t*\ num\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the number of iterations taken}
        {}
\label{cxx.10.4.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_GetRelResidualNorm}
        {(\ \ bHYPRE\_CGNR\ self,\ \ double*\ norm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Return the norm of the relative residual}
        {}
\label{cxx.10.4.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetCommunicator}
        {(\ \ bHYPRE\_CGNR\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {10.4.8}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_CGNR\_Destroy}
        {(\ \ bHYPRE\_CGNR\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {10.4.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetIntParameter}
        {(\ \ bHYPRE\_CGNR\ self,\ \ const\ char*\ name,\ \ int32\_t\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.10.4.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetDoubleParameter}
        {(\ \ bHYPRE\_CGNR\ self,\ \ const\ char*\ name,\ \ double\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double parameter associated with {\tt name}}
        {}
\label{cxx.10.4.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetStringParameter}
        {(\ \ bHYPRE\_CGNR\ self,\ \ const\ char*\ name,\ \ const\ char*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the string parameter associated with {\tt name}}
        {}
\label{cxx.10.4.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetIntArray1Parameter}
        {(\ \ bHYPRE\_CGNR\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.4.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetIntArray2Parameter}
        {(\ \ bHYPRE\_CGNR\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_int\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.4.24}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetDoubleArray1Parameter}
        {(\ \ bHYPRE\_CGNR\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ int32\_t\ nvalues,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 1-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.4.25}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetDoubleArray2Parameter}
        {(\ \ bHYPRE\_CGNR\ self,\ \ const\ char*\ name,\ \ struct\ sidl\_double\_\_array*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the double 2-D array parameter associated with {\tt name}}
        {}
\label{cxx.10.4.26}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_GetIntValue}
        {(\ \ bHYPRE\_CGNR\ self,\ \ const\ char*\ name,\ \ int32\_t*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the int parameter associated with {\tt name}}
        {}
\label{cxx.10.4.27}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_GetDoubleValue}
        {(\ \ bHYPRE\_CGNR\ self,\ \ const\ char*\ name,\ \ double*\ value,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the double parameter associated with {\tt name}}
        {}
\label{cxx.10.4.28}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_Setup}
        {(\ \ bHYPRE\_CGNR\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Do any preprocessing that may be necessary in
order to execute {\tt Apply}}
        {}
\label{cxx.10.4.29}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_Apply}
        {(\ \ bHYPRE\_CGNR\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.10.4.30}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_ApplyAdjoint}
        {(\ \ bHYPRE\_CGNR\ self,\ \ bHYPRE\_Vector\ b,\ \ bHYPRE\_Vector*\ x,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Apply the adjoint of the operator to {\tt b}, returning {\tt x}}
        {}
\label{cxx.10.4.31}
\cxxitem{\ struct\ \ bHYPRE\_CGNR\_\_object*\ bHYPRE\_CGNR\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.10.4.32}
\cxxitem{void*\ }
        {bHYPRE\_CGNR\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.10.4.33}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_CGNR\_\_exec}
        {(\ \ bHYPRE\_CGNR\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.10.4.34}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_CGNR\_\_getURL}
        {(\ \ bHYPRE\_CGNR\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.10.4.35}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_CGNR\_\_raddRef}
        {(\ \ bHYPRE\_CGNR\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.10.4.36}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_CGNR\_\_isRemote}
        {(\ \ bHYPRE\_CGNR\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.10.4.37}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_CGNR\_\_isLocal}
        {(\ \ bHYPRE\_CGNR\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.10.4.38}
\cxxitem{\ struct\ \ bHYPRE\_CGNR\_\_object*\ bHYPRE\_CGNR\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.10.4.39}
\cxxitem{\ struct\ \ bHYPRE\_CGNR\_\_object*\ bHYPRE\_CGNR\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {10.4.10}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_CGNR\_\_object}
        {}
        {
Symbol "bHYPRE}
        {10.4.1}
\begin{cxxdoc}

Symbol "bHYPRE.CGNR" (version 1.0.0)

CGNR solver.
This calls Babel-interface matrix and vector functions, so it will work
with any consistent matrix, vector, and preconditioner classes.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_CGNR\ }
        {bHYPRE\_CGNR\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {10.4.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetOperator}
        {(\ \ bHYPRE\_CGNR\ self,\ \ bHYPRE\_Operator\ A,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the operator for the linear system being solved}
        {10.4.3}
\begin{cxxdoc}

Set the operator for the linear system being solved.
DEPRECATED.  use Create
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetTolerance}
        {(\ \ bHYPRE\_CGNR\ self,\ \ double\ tolerance,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the convergence tolerance}
        {10.4.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance.
DEPRECATED.  use SetDoubleParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetMaxIterations}
        {(\ \ bHYPRE\_CGNR\ self,\ \ int32\_t\ max\_iterations,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set maximum number of iterations}
        {10.4.5}
\begin{cxxdoc}

(Optional) Set maximum number of iterations.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetLogging}
        {(\ \ bHYPRE\_CGNR\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated}
        {10.4.6}
\begin{cxxdoc}

(Optional) Set the {\it logging level}, specifying the degree
of additional informational data to be accumulated.  Does
nothing by default (level = 0).  Other levels (if any) are
implementation-specific.  Must be called before {\tt Setup}
and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetPrintLevel}
        {(\ \ bHYPRE\_CGNR\ self,\ \ int32\_t\ level,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file}
        {10.4.7}
\begin{cxxdoc}

(Optional) Set the {\it print level}, specifying the degree
of informational data to be printed either to the screen or
to a file.  Does nothing by default (level=0).  Other levels
(if any) are implementation-specific.  Must be called before
{\tt Setup} and {\tt Apply}.
DEPRECATED   use SetIntParameter
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_CGNR\_SetCommunicator}
        {(\ \ bHYPRE\_CGNR\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {10.4.8}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_CGNR\_Destroy}
        {(\ \ bHYPRE\_CGNR\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {10.4.9}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_CGNR\_\_object*\ bHYPRE\_CGNR\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {10.4.10}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{}
        {Other}
        {}
        {
}
        {11}
\begin{cxxnames}
\cxxitem{}
        {MPI Communicator}
        {}
        {
}
        {11.1}
\end{cxxnames}
\begin{cxxentry}
{}
        {MPI Communicator}
        {}
        {
}
        {11.1}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_MPICommunicator\_\_object}
        {}
        {
Symbol "bHYPRE}
        {11.1.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_MPICommunicator\_\_object*\ bHYPRE\_MPICommunicator\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.11.1.5}
\cxxitem{bHYPRE\_MPICommunicator\ }
        {bHYPRE\_MPICommunicator\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.11.1.6}
\cxxitem{bHYPRE\_MPICommunicator\ }
        {bHYPRE\_MPICommunicator\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_MPICommunicator\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.11.1.7}
\cxxitem{bHYPRE\_MPICommunicator\ }
        {bHYPRE\_MPICommunicator\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {11.1.2}
\cxxitem{bHYPRE\_MPICommunicator\ }
        {bHYPRE\_MPICommunicator\_CreateC}
        {(\ \ void*\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Create an MPICommunicator object from C code}
        {}
\label{cxx.11.1.8}
\cxxitem{bHYPRE\_MPICommunicator\ }
        {bHYPRE\_MPICommunicator\_CreateF}
        {(\ \ void*\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Create an MPICommunicator object from Fortran code}
        {}
\label{cxx.11.1.9}
\cxxitem{bHYPRE\_MPICommunicator\ }
        {bHYPRE\_MPICommunicator\_Create\_MPICommWorld}
        {(\ \ sidl\_BaseInterface\ *\_ex)}
        {
Create an MPICommunicator object which represents MPI\_Comm\_World}
        {}
\label{cxx.11.1.10}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_MPICommunicator\_Destroy}
        {(\ \ bHYPRE\_MPICommunicator\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {11.1.3}
\cxxitem{void\ }
        {bHYPRE\_MPICommunicator\_Init}
        {(\ \ sidl\_BaseInterface\ *\_ex)}
        {
Init and Finalize are to help debug MPI interfaces;
you should normally use the MPI library more directly:}
        {}
\label{cxx.11.1.11}
\cxxitem{void\ }
        {bHYPRE\_MPICommunicator\_Finalize}
        {(\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  Finalize[]}
        {}
\label{cxx.11.1.12}
\cxxitem{\ struct\ \ bHYPRE\_MPICommunicator\_\_object*\ bHYPRE\_MPICommunicator\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.11.1.13}
\cxxitem{void*\ }
        {bHYPRE\_MPICommunicator\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.11.1.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_MPICommunicator\_\_exec}
        {(\ \ bHYPRE\_MPICommunicator\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.11.1.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_MPICommunicator\_\_getURL}
        {(\ \ bHYPRE\_MPICommunicator\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.11.1.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_MPICommunicator\_\_raddRef}
        {(\ \ bHYPRE\_MPICommunicator\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.11.1.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_MPICommunicator\_\_isRemote}
        {(\ \ bHYPRE\_MPICommunicator\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.11.1.18}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_MPICommunicator\_\_isLocal}
        {(\ \ bHYPRE\_MPICommunicator\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.11.1.19}
\cxxitem{\ struct\ \ bHYPRE\_MPICommunicator\_\_object*\ bHYPRE\_MPICommunicator\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.11.1.20}
\cxxitem{\ struct\ \ bHYPRE\_MPICommunicator\_\_object*\ bHYPRE\_MPICommunicator\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {11.1.4}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_MPICommunicator\_\_object}
        {}
        {
Symbol "bHYPRE}
        {11.1.1}
\begin{cxxdoc}

Symbol "bHYPRE.MPICommunicator" (version 1.0.0)

MPICommunicator class
- two general Create functions: use CreateC if called from C code,
CreateF if called from Fortran code.
- Create\_MPICommWorld will create a MPICommunicator to represent
MPI\_Comm\_World, and can be called from any language.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_MPICommunicator\ }
        {bHYPRE\_MPICommunicator\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {11.1.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_MPICommunicator\_Destroy}
        {(\ \ bHYPRE\_MPICommunicator\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {11.1.3}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_MPICommunicator\_\_object*\ bHYPRE\_MPICommunicator\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {11.1.4}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct Grid, etc.}
        {}
        {
}
        {12}
\begin{cxxnames}
\cxxitem{}
        {Struct Grid}
        {}
        {
}
        {12.1}
\cxxitem{}
        {Struct Stencil}
        {}
        {
}
        {12.2}
\end{cxxnames}
\begin{cxxentry}
{}
        {Struct Grid}
        {}
        {
}
        {12.1}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_StructGrid\_\_object}
        {}
        {
Symbol "bHYPRE}
        {12.1.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_StructGrid\_\_object*\ bHYPRE\_StructGrid\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.12.1.9}
\cxxitem{bHYPRE\_StructGrid\ }
        {bHYPRE\_StructGrid\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.12.1.10}
\cxxitem{bHYPRE\_StructGrid\ }
        {bHYPRE\_StructGrid\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_StructGrid\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.12.1.11}
\cxxitem{bHYPRE\_StructGrid\ }
        {bHYPRE\_StructGrid\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {12.1.2}
\cxxitem{bHYPRE\_StructGrid\ }
        {bHYPRE\_StructGrid\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ int32\_t\ dim,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a Struct Grid}
        {}
\label{cxx.12.1.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructGrid\_SetCommunicator}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {12.1.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructGrid\_Destroy}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {12.1.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructGrid\_SetDimension}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ int32\_t\ dim,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  SetDimension[]}
        {}
\label{cxx.12.1.13}
\cxxitem{int32\_t\ }
        {bHYPRE\_StructGrid\_SetExtents}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Define the lower and upper corners of a box of the grid}
        {12.1.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructGrid\_SetPeriodic}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ int32\_t*\ periodic,\ \ int32\_t\ dim,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the periodicity for the grid}
        {12.1.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructGrid\_SetNumGhost}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ int32\_t*\ num\_ghost,\ \ int32\_t\ dim2,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of ghost zones, separately on the lower and upper sides
for each dimension}
        {12.1.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructGrid\_Assemble}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
final construction of the object before its use }
        {}
\label{cxx.12.1.14}
\cxxitem{\ struct\ \ bHYPRE\_StructGrid\_\_object*\ bHYPRE\_StructGrid\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.12.1.15}
\cxxitem{void*\ }
        {bHYPRE\_StructGrid\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.12.1.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructGrid\_\_exec}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.12.1.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_StructGrid\_\_getURL}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.12.1.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructGrid\_\_raddRef}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.12.1.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_StructGrid\_\_isRemote}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.12.1.20}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_StructGrid\_\_isLocal}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.12.1.21}
\cxxitem{\ struct\ \ bHYPRE\_StructGrid\_\_object*\ bHYPRE\_StructGrid\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.12.1.22}
\cxxitem{\ struct\ \ bHYPRE\_StructGrid\_\_object*\ bHYPRE\_StructGrid\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {12.1.8}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_StructGrid\_\_object}
        {}
        {
Symbol "bHYPRE}
        {12.1.1}
\begin{cxxdoc}

Symbol "bHYPRE.StructGrid" (version 1.0.0)

Define a structured grid class.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_StructGrid\ }
        {bHYPRE\_StructGrid\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {12.1.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructGrid\_SetCommunicator}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {12.1.3}
\begin{cxxdoc}

Set the MPI Communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructGrid\_Destroy}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {12.1.4}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_StructGrid\_SetExtents}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Define the lower and upper corners of a box of the grid}
        {12.1.5}
\begin{cxxdoc}

Define the lower and upper corners of a box of the grid.
"ilower" and "iupper" are arrays of size "dim", the number of spatial
dimensions. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructGrid\_SetPeriodic}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ int32\_t*\ periodic,\ \ int32\_t\ dim,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the periodicity for the grid}
        {12.1.6}
\begin{cxxdoc}

Set the periodicity for the grid.  Default is no periodicity.

The argument {\tt periodic} is an {\tt dim}-dimensional integer array that
contains the periodicity for each dimension.  A zero value for a dimension
means non-periodic, while a nonzero value means periodic and contains the
actual period.  For example, periodicity in the first and third dimensions
for a 10x11x12 grid is indicated by the array [10,0,12].

NOTE: Some of the solvers in hypre have power-of-two restrictions on the size
of the periodic dimensions.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructGrid\_SetNumGhost}
        {(\ \ bHYPRE\_StructGrid\ self,\ \ int32\_t*\ num\_ghost,\ \ int32\_t\ dim2,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of ghost zones, separately on the lower and upper sides
for each dimension}
        {12.1.7}
\begin{cxxdoc}

Set the number of ghost zones, separately on the lower and upper sides
for each dimension.
"num\_ghost" is an array of size "dim2", twice the number of dimensions. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_StructGrid\_\_object*\ bHYPRE\_StructGrid\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {12.1.8}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct Stencil}
        {}
        {
}
        {12.2}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_StructStencil\_\_object}
        {}
        {
Symbol "bHYPRE}
        {12.2.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_StructStencil\_\_object*\ bHYPRE\_StructStencil\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.12.2.9}
\cxxitem{bHYPRE\_StructStencil\ }
        {bHYPRE\_StructStencil\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.12.2.10}
\cxxitem{bHYPRE\_StructStencil\ }
        {bHYPRE\_StructStencil\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_StructStencil\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.12.2.11}
\cxxitem{bHYPRE\_StructStencil\ }
        {bHYPRE\_StructStencil\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {12.2.2}
\cxxitem{bHYPRE\_StructStencil\ }
        {bHYPRE\_StructStencil\_Create}
        {(\ \ int32\_t\ ndim,\ \ int32\_t\ size,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a Struct Stencil}
        {12.2.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructStencil\_Destroy}
        {(\ \ bHYPRE\_StructStencil\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {12.2.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructStencil\_SetDimension}
        {(\ \ bHYPRE\_StructStencil\ self,\ \ int32\_t\ dim,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of dimensions}
        {12.2.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructStencil\_SetSize}
        {(\ \ bHYPRE\_StructStencil\ self,\ \ int32\_t\ size,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of stencil entries}
        {12.2.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructStencil\_SetElement}
        {(\ \ bHYPRE\_StructStencil\ self,\ \ int32\_t\ index,\ \ int32\_t*\ offset,\ \ int32\_t\ dim,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set a stencil element}
        {12.2.7}
\cxxitem{\ struct\ \ bHYPRE\_StructStencil\_\_object*\ bHYPRE\_StructStencil\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.12.2.12}
\cxxitem{void*\ }
        {bHYPRE\_StructStencil\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.12.2.13}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructStencil\_\_exec}
        {(\ \ bHYPRE\_StructStencil\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.12.2.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_StructStencil\_\_getURL}
        {(\ \ bHYPRE\_StructStencil\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.12.2.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructStencil\_\_raddRef}
        {(\ \ bHYPRE\_StructStencil\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.12.2.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_StructStencil\_\_isRemote}
        {(\ \ bHYPRE\_StructStencil\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.12.2.17}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_StructStencil\_\_isLocal}
        {(\ \ bHYPRE\_StructStencil\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.12.2.18}
\cxxitem{\ struct\ \ bHYPRE\_StructStencil\_\_object*\ bHYPRE\_StructStencil\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.12.2.19}
\cxxitem{\ struct\ \ bHYPRE\_StructStencil\_\_object*\ bHYPRE\_StructStencil\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {12.2.8}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_StructStencil\_\_object}
        {}
        {
Symbol "bHYPRE}
        {12.2.1}
\begin{cxxdoc}

Symbol "bHYPRE.StructStencil" (version 1.0.0)

Define a structured stencil for a structured problem
description.  More than one implementation is not envisioned,
thus the decision has been made to make this a class rather than
an interface.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_StructStencil\ }
        {bHYPRE\_StructStencil\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {12.2.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{bHYPRE\_StructStencil\ }
        {bHYPRE\_StructStencil\_Create}
        {(\ \ int32\_t\ ndim,\ \ int32\_t\ size,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a Struct Stencil}
        {12.2.3}
\begin{cxxdoc}

This function is the preferred way to create a Struct Stencil.
You provide the number of spatial dimensions and the number of
stencil entries.  
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_StructStencil\_Destroy}
        {(\ \ bHYPRE\_StructStencil\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {12.2.4}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructStencil\_SetDimension}
        {(\ \ bHYPRE\_StructStencil\ self,\ \ int32\_t\ dim,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of dimensions}
        {12.2.5}
\begin{cxxdoc}

Set the number of dimensions.  DEPRECATED, use StructStencilCreate 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructStencil\_SetSize}
        {(\ \ bHYPRE\_StructStencil\ self,\ \ int32\_t\ size,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of stencil entries}
        {12.2.6}
\begin{cxxdoc}

Set the number of stencil entries.
DEPRECATED, use StructStencilCreate 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_StructStencil\_SetElement}
        {(\ \ bHYPRE\_StructStencil\ self,\ \ int32\_t\ index,\ \ int32\_t*\ offset,\ \ int32\_t\ dim,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set a stencil element}
        {12.2.7}
\begin{cxxdoc}

Set a stencil element.  Specify the stencil index, and an array of
offsets.  "offset" is an array of length "dim", the number of spatial
dimensions. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_StructStencil\_\_object*\ bHYPRE\_StructStencil\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {12.2.8}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{}
        {Semi-Structured Grid, etc.}
        {}
        {
}
        {13}
\begin{cxxnames}
\cxxitem{}
        {Semi-Structured Graph}
        {}
        {
}
        {13.1}
\cxxitem{}
        {Semi-Structured Grid}
        {}
        {
}
        {13.2}
\cxxitem{}
        {Semi-Structured Stencil}
        {}
        {
}
        {13.3}
\cxxitem{}
        {Semi-Structured Variable}
        {}
        {
}
        {13.4}
\end{cxxnames}
\begin{cxxentry}
{}
        {Semi-Structured Graph}
        {}
        {
}
        {13.1}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_SStructGraph\_\_object}
        {}
        {
Symbol "bHYPRE}
        {13.1.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_SStructGraph\_\_object*\ bHYPRE\_SStructGraph\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.13.1.9}
\cxxitem{bHYPRE\_SStructGraph\ }
        {bHYPRE\_SStructGraph\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.13.1.10}
\cxxitem{bHYPRE\_SStructGraph\ }
        {bHYPRE\_SStructGraph\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_SStructGraph\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.13.1.11}
\cxxitem{bHYPRE\_SStructGraph\ }
        {bHYPRE\_SStructGraph\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {13.1.2}
\cxxitem{bHYPRE\_SStructGraph\ }
        {bHYPRE\_SStructGraph\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_SStructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a SStruct Graph}
        {}
\label{cxx.13.1.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGraph\_SetCommGrid}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_SStructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the grid and communicator}
        {13.1.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGraph\_SetStencil}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ int32\_t\ part,\ \ int32\_t\ var,\ \ bHYPRE\_SStructStencil\ stencil,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the stencil for a variable on a structured part of the
grid}
        {}
\label{cxx.13.1.13}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructGraph\_AddEntries}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ to\_part,\ \ int32\_t*\ to\_index,\ \ int32\_t\ to\_var,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add a non-stencil graph entry at a particular index}
        {13.1.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGraph\_SetObjectType}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ int32\_t\ type,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  SetObjectType[]}
        {}
\label{cxx.13.1.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGraph\_SetCommunicator}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {13.1.5}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructGraph\_Destroy}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {13.1.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGraph\_Initialize}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Prepare an object for setting coefficient values, whether for
the first time or subsequently}
        {}
\label{cxx.13.1.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGraph\_Assemble}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {13.1.7}
\cxxitem{\ struct\ \ bHYPRE\_SStructGraph\_\_object*\ bHYPRE\_SStructGraph\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.13.1.16}
\cxxitem{void*\ }
        {bHYPRE\_SStructGraph\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.13.1.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructGraph\_\_exec}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.13.1.18}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_SStructGraph\_\_getURL}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.13.1.19}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructGraph\_\_raddRef}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.13.1.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_SStructGraph\_\_isRemote}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.13.1.21}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_SStructGraph\_\_isLocal}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.13.1.22}
\cxxitem{\ struct\ \ bHYPRE\_SStructGraph\_\_object*\ bHYPRE\_SStructGraph\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.13.1.23}
\cxxitem{\ struct\ \ bHYPRE\_SStructGraph\_\_object*\ bHYPRE\_SStructGraph\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {13.1.8}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_SStructGraph\_\_object}
        {}
        {
Symbol "bHYPRE}
        {13.1.1}
\begin{cxxdoc}

Symbol "bHYPRE.SStructGraph" (version 1.0.0)

The semi-structured grid graph class.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_SStructGraph\ }
        {bHYPRE\_SStructGraph\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {13.1.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGraph\_SetCommGrid}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ bHYPRE\_SStructGrid\ grid,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the grid and communicator}
        {13.1.3}
\begin{cxxdoc}

Set the grid and communicator.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructGraph\_AddEntries}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ int32\_t\ to\_part,\ \ int32\_t*\ to\_index,\ \ int32\_t\ to\_var,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add a non-stencil graph entry at a particular index}
        {13.1.4}
\begin{cxxdoc}

Add a non-stencil graph entry at a particular index.  This
graph entry is appended to the existing graph entries, and is
referenced as such.

NOTE: Users are required to set graph entries on all
processes that own the associated variables.  This means that
some data will be multiply defined.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGraph\_SetCommunicator}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the MPI Communicator}
        {13.1.5}
\begin{cxxdoc}

Set the MPI Communicator.  DEPRECATED, Use Create()
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructGraph\_Destroy}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {13.1.6}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGraph\_Assemble}
        {(\ \ bHYPRE\_SStructGraph\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Finalize the construction of an object before using, either
for the first time or on subsequent uses}
        {13.1.7}
\begin{cxxdoc}

Finalize the construction of an object before using, either
for the first time or on subsequent uses. {\tt Initialize}
and {\tt Assemble} always appear in a matched set, with
Initialize preceding Assemble. Values can only be set in
between a call to Initialize and Assemble.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_SStructGraph\_\_object*\ bHYPRE\_SStructGraph\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {13.1.8}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Semi-Structured Grid}
        {}
        {
}
        {13.2}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_SStructGrid\_\_object}
        {}
        {
Symbol "bHYPRE}
        {13.2.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_SStructGrid\_\_object*\ bHYPRE\_SStructGrid\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.13.2.9}
\cxxitem{bHYPRE\_SStructGrid\ }
        {bHYPRE\_SStructGrid\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.13.2.10}
\cxxitem{bHYPRE\_SStructGrid\ }
        {bHYPRE\_SStructGrid\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_SStructGrid\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.13.2.11}
\cxxitem{bHYPRE\_SStructGrid\ }
        {bHYPRE\_SStructGrid\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {13.2.2}
\cxxitem{bHYPRE\_SStructGrid\ }
        {bHYPRE\_SStructGrid\_Create}
        {(\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ int32\_t\ ndim,\ \ int32\_t\ nparts,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a SStruct Grid}
        {}
\label{cxx.13.2.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGrid\_SetNumDimParts}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ int32\_t\ ndim,\ \ int32\_t\ nparts,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  SetNumDimParts[]}
        {}
\label{cxx.13.2.13}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGrid\_SetCommunicator}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ bHYPRE\_MPICommunicator\ mpi\_comm,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Method:  SetCommunicator[]}
        {}
\label{cxx.13.2.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructGrid\_Destroy}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {13.2.3}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructGrid\_SetExtents}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ dim,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the extents for a box on a structured part of the grid}
        {}
\label{cxx.13.2.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGrid\_SetVariable}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ int32\_t\ part,\ \ int32\_t\ var,\ \ int32\_t\ nvars,\ \ enum\ bHYPRE\_SStructVariable\_\_enum\ vartype,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Describe the variables that live on a structured part of the
grid}
        {13.2.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGrid\_AddVariable}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ enum\ bHYPRE\_SStructVariable\_\_enum\ vartype,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Describe additional variables that live at a particular
index}
        {13.2.5}
\cxxitem{int32\_t\ }
        {bHYPRE\_SStructGrid\_SetNeighborBox}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ nbor\_part,\ \ int32\_t*\ nbor\_ilower,\ \ int32\_t*\ nbor\_iupper,\ \ int32\_t*\ index\_map,\ \ int32\_t\ dim,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Describe how regions just outside of a part relate to other
parts}
        {13.2.6}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGrid\_AddUnstructuredPart}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ int32\_t\ ilower,\ \ int32\_t\ iupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add an unstructured part to the grid}
        {13.2.7}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGrid\_SetPeriodic}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ int32\_t\ part,\ \ int32\_t*\ periodic,\ \ int32\_t\ dim,\ \ sidl\_BaseInterface\ *\_ex)}
        {
(Optional) Set periodic for a particular part}
        {}
\label{cxx.13.2.16}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGrid\_SetNumGhost}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ int32\_t*\ num\_ghost,\ \ int32\_t\ dim2,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Setting ghost in the sgrids}
        {}
\label{cxx.13.2.17}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGrid\_Assemble}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
final construction of the object before its use }
        {}
\label{cxx.13.2.18}
\cxxitem{\ struct\ \ bHYPRE\_SStructGrid\_\_object*\ bHYPRE\_SStructGrid\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.13.2.19}
\cxxitem{void*\ }
        {bHYPRE\_SStructGrid\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.13.2.20}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructGrid\_\_exec}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.13.2.21}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_SStructGrid\_\_getURL}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.13.2.22}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructGrid\_\_raddRef}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.13.2.23}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_SStructGrid\_\_isRemote}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.13.2.24}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_SStructGrid\_\_isLocal}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.13.2.25}
\cxxitem{\ struct\ \ bHYPRE\_SStructGrid\_\_object*\ bHYPRE\_SStructGrid\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.13.2.26}
\cxxitem{\ struct\ \ bHYPRE\_SStructGrid\_\_object*\ bHYPRE\_SStructGrid\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {13.2.8}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_SStructGrid\_\_object}
        {}
        {
Symbol "bHYPRE}
        {13.2.1}
\begin{cxxdoc}

Symbol "bHYPRE.SStructGrid" (version 1.0.0)

The semi-structured grid class.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_SStructGrid\ }
        {bHYPRE\_SStructGrid\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {13.2.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructGrid\_Destroy}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {13.2.3}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGrid\_SetVariable}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ int32\_t\ part,\ \ int32\_t\ var,\ \ int32\_t\ nvars,\ \ enum\ bHYPRE\_SStructVariable\_\_enum\ vartype,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Describe the variables that live on a structured part of the
grid}
        {13.2.4}
\begin{cxxdoc}

Describe the variables that live on a structured part of the
grid.  Input: part number, variable number, total number of
variables on that part (needed for memory allocation),
variable type.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGrid\_AddVariable}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ int32\_t\ part,\ \ int32\_t*\ index,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ enum\ bHYPRE\_SStructVariable\_\_enum\ vartype,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Describe additional variables that live at a particular
index}
        {13.2.5}
\begin{cxxdoc}

Describe additional variables that live at a particular
index.  These variables are appended to the array of
variables set in {\tt SetVariables}, and are referenced as
such.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int32\_t\ }
        {bHYPRE\_SStructGrid\_SetNeighborBox}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ int32\_t\ part,\ \ int32\_t*\ ilower,\ \ int32\_t*\ iupper,\ \ int32\_t\ nbor\_part,\ \ int32\_t*\ nbor\_ilower,\ \ int32\_t*\ nbor\_iupper,\ \ int32\_t*\ index\_map,\ \ int32\_t\ dim,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Describe how regions just outside of a part relate to other
parts}
        {13.2.6}
\begin{cxxdoc}

Describe how regions just outside of a part relate to other
parts.  This is done a box at a time.

The indexes {\tt ilower} and {\tt iupper} map directly to the
indexes {\tt nbor\_ilower} and {\tt nbor\_iupper}.  Although,
it is required that indexes increase from {\tt ilower} to
{\tt iupper}, indexes may increase and/or decrease from {\tt
nbor\_ilower} to {\tt nbor\_iupper}.

The {\tt index\_map} describes the mapping of indexes 0, 1,
and 2 on part {\tt part} to the corresponding indexes on part
{\tt nbor\_part}.  For example, triple (1, 2, 0) means that
indexes 0, 1, and 2 on part {\tt part} map to indexes 1, 2,
and 0 on part {\tt nbor\_part}, respectively.

NOTE: All parts related to each other via this routine must
have an identical list of variables and variable types.  For
example, if part 0 has only two variables on it, a cell
centered variable and a node centered variable, and we
declare part 1 to be a neighbor of part 0, then part 1 must
also have only two variables on it, and they must be of type
cell and node.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructGrid\_AddUnstructuredPart}
        {(\ \ bHYPRE\_SStructGrid\ self,\ \ int32\_t\ ilower,\ \ int32\_t\ iupper,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Add an unstructured part to the grid}
        {13.2.7}
\begin{cxxdoc}

Add an unstructured part to the grid.  The variables in the
unstructured part of the grid are referenced by a global rank
between 0 and the total number of unstructured variables
minus one.  Each process owns some unique consecutive range
of variables, defined by {\tt ilower} and {\tt iupper}.

NOTE: This is just a placeholder.  This part of the interface
is not finished.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_SStructGrid\_\_object*\ bHYPRE\_SStructGrid\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {13.2.8}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Semi-Structured Stencil}
        {}
        {
}
        {13.3}
\begin{cxxnames}
\cxxitem{\ struct\ }
        {bHYPRE\_SStructStencil\_\_object}
        {}
        {
Symbol "bHYPRE}
        {13.3.1}
\cxxitem{extern\ \ C\ \ struct\ \ bHYPRE\_SStructStencil\_\_object*\ bHYPRE\_SStructStencil\_\_create\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Constructor function for the class}
        {}
\label{cxx.13.3.6}
\cxxitem{bHYPRE\_SStructStencil\ }
        {bHYPRE\_SStructStencil\_\_createRemote}
        {(const\ char\ *\ url,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI constructor function for the class}
        {}
\label{cxx.13.3.7}
\cxxitem{bHYPRE\_SStructStencil\ }
        {bHYPRE\_SStructStencil\_\_wrapObj}
        {(void\ *\ data,\ sidl\_BaseInterface\ *\_ex)}
        {
Wraps up the private data struct pointer (struct bHYPRE\_SStructStencil\_\_data) passed in rather than running the constructor}
        {}
\label{cxx.13.3.8}
\cxxitem{bHYPRE\_SStructStencil\ }
        {bHYPRE\_SStructStencil\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {13.3.2}
\cxxitem{bHYPRE\_SStructStencil\ }
        {bHYPRE\_SStructStencil\_Create}
        {(\ \ int32\_t\ ndim,\ \ int32\_t\ size,\ \ sidl\_BaseInterface\ *\_ex)}
        {
This function is the preferred way to create a SStruct Stencil}
        {}
\label{cxx.13.3.9}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructStencil\_Destroy}
        {(\ \ bHYPRE\_SStructStencil\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {13.3.3}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructStencil\_SetNumDimSize}
        {(\ \ bHYPRE\_SStructStencil\ self,\ \ int32\_t\ ndim,\ \ int32\_t\ size,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of spatial dimensions and stencil entries}
        {13.3.4}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructStencil\_SetEntry}
        {(\ \ bHYPRE\_SStructStencil\ self,\ \ int32\_t\ entry,\ \ int32\_t*\ offset,\ \ int32\_t\ dim,\ \ int32\_t\ var,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set a stencil entry}
        {}
\label{cxx.13.3.10}
\cxxitem{\ struct\ \ bHYPRE\_SStructStencil\_\_object*\ bHYPRE\_SStructStencil\_\_cast\ void*\ obj\ sidl\_BaseInterface*}
        {\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.13.3.11}
\cxxitem{void*\ }
        {bHYPRE\_SStructStencil\_\_cast2}
        {(\ void*\ obj,\ const\ char*\ type,\ sidl\_BaseInterface\ *\_ex)}
        {
String cast method for interface and class type conversions}
        {}
\label{cxx.13.3.12}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructStencil\_\_exec}
        {(\ \ bHYPRE\_SStructStencil\ self,\ \ const\ char*\ methodName,\ \ sidl\_rmi\_Call\ inArgs,\ \ sidl\_rmi\_Return\ outArgs,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Select and execute a method by name}
        {}
\label{cxx.13.3.13}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ char*\ }
        {bHYPRE\_SStructStencil\_\_getURL}
        {(\ \ bHYPRE\_SStructStencil\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Get the URL of the Implementation of this object (for RMI)}
        {}
\label{cxx.13.3.14}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructStencil\_\_raddRef}
        {(\ \ bHYPRE\_SStructStencil\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
On a remote object, addrefs the remote instance}
        {}
\label{cxx.13.3.15}
\cxxitem{SIDL\_C\_INLINE\_DECL\ \ sidl\_bool\ }
        {bHYPRE\_SStructStencil\_\_isRemote}
        {(\ \ bHYPRE\_SStructStencil\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.13.3.16}
\cxxitem{sidl\_bool\ }
        {bHYPRE\_SStructStencil\_\_isLocal}
        {(\ \ bHYPRE\_SStructStencil\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
TRUE if this object is remote, false if local}
        {}
\label{cxx.13.3.17}
\cxxitem{\ struct\ \ bHYPRE\_SStructStencil\_\_object*\ bHYPRE\_SStructStencil\_\_rmicast\ void*\ obj\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
Cast method for interface and class type conversions}
        {}
\label{cxx.13.3.18}
\cxxitem{\ struct\ \ bHYPRE\_SStructStencil\_\_object*\ bHYPRE\_SStructStencil\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {13.3.5}
\end{cxxnames}
\begin{cxxvariable}
{\ struct\ }
        {bHYPRE\_SStructStencil\_\_object}
        {}
        {
Symbol "bHYPRE}
        {13.3.1}
\begin{cxxdoc}

Symbol "bHYPRE.SStructStencil" (version 1.0.0)

The semi-structured grid stencil class.
\end{cxxdoc}
\end{cxxvariable}
\begin{cxxfunction}
{bHYPRE\_SStructStencil\ }
        {bHYPRE\_SStructStencil\_\_connect}
        {(const\ char\ *,\ sidl\_BaseInterface\ *\_ex)}
        {
RMI connector function for the class}
        {13.3.2}
\begin{cxxdoc}

RMI connector function for the class.(addrefs)
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ void\ }
        {bHYPRE\_SStructStencil\_Destroy}
        {(\ \ bHYPRE\_SStructStencil\ self,\ \ sidl\_BaseInterface\ *\_ex)}
        {
The Destroy function doesn't necessarily destroy anything}
        {13.3.3}
\begin{cxxdoc}

The Destroy function doesn't necessarily destroy anything.
It is just another name for deleteRef.  Thus it decrements the
object's reference count.  The Babel memory management system will
destroy the object if the reference count goes to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{SIDL\_C\_INLINE\_DECL\ \ int32\_t\ }
        {bHYPRE\_SStructStencil\_SetNumDimSize}
        {(\ \ bHYPRE\_SStructStencil\ self,\ \ int32\_t\ ndim,\ \ int32\_t\ size,\ \ sidl\_BaseInterface\ *\_ex)}
        {
Set the number of spatial dimensions and stencil entries}
        {13.3.4}
\begin{cxxdoc}

Set the number of spatial dimensions and stencil entries.
DEPRECATED, use Create:
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxvariable}
{\ struct\ \ bHYPRE\_SStructStencil\_\_object*\ bHYPRE\_SStructStencil\_\_connectI\ const\ char\ *\ url\ sidl\_bool\ ar\ struct\ sidl\_BaseInterface\_\_object}
        {**\_ex}
        {}
        {
RMI connector function for the class}
        {13.3.5}
\begin{cxxdoc}

RMI connector function for the class. (no addref)
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\begin{cxxentry}
{}
        {Semi-Structured Variable}
        {}
        {
}
        {13.4}
\begin{cxxnames}
\cxxitem{\ enum\ }
        {bHYPRE\_SStructVariable\_\_enum}
        {}
        {
Symbol "bHYPRE}
        {13.4.1}
\end{cxxnames}
\begin{cxxunion}
{\ enum\ }
        {bHYPRE\_SStructVariable\_\_enum}
        {}
        {
Symbol "bHYPRE}
        {13.4.1}
\begin{cxxdoc}

Symbol "bHYPRE.SStructVariable" (version 1.0.0)

The SStructVariable enumerated type.

An enumerated type that supports cell centered, node
centered, face centered, and edge centered variables.  Face
centered variables are split into x-face, y-face, and z-face
variables, and edge centered variables are split into x-edge,
y-edge, and z-edge variables.  The edge centered variable
types are only used in 3D.  In 2D, edge centered variables
are handled by the face centered types.

Variables are referenced relative to an abstract (cell centered)
index in the following way:
\begin{itemize}
\item cell centered variables are aligned with the index;
\item node centered variables are aligned with the cell corner
at relative index (1/2, 1/2, 1/2);
\item x-face, y-face, and z-face centered variables are aligned
with the faces at relative indexes (1/2, 0, 0), (0, 1/2, 0),
and (0, 0, 1/2), respectively;
\item x-edge, y-edge, and z-edge centered variables are aligned
with the edges at relative indexes (0, 1/2, 1/2), (1/2, 0, 1/2),
and (1/2, 1/2, 0), respectively.
\end{itemize}

The supported identifiers are:
\begin{itemize}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_CELL}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_NODE}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_XFACE}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_YFACE}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_ZFACE}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_XEDGE}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_YEDGE}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_ZEDGE}
\end{itemize}

NOTE: Although variables are referenced relative to a unique
abstract cell-centered index, some variables are associated
with multiple grid cells.  For example, node centered
variables in 3D are associated with 8 cells (away from
boundaries).  Although grid cells are distributed uniquely to
different processes, variables may be owned by multiple
processes because they may be associated with multiple cells.
\end{cxxdoc}
\end{cxxunion}
\end{cxxentry}
\end{cxxentry}
\begin{cxxClassGraph}
\label{cxx.}
\end{cxxClassGraph}
\end{document}
