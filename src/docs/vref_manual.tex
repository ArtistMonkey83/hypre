\documentclass{article}
\usepackage{docxx}
\begin{document}
\pagebreak
\sloppy
\cxxVersion{
2.4.0b\strut}
\cxxTitle{}
        {{\it hypre} Reference Manual}
        {}
        {
}
        {}
\begin{cxxContents}
\cxxContentsEntry{1}{Struct System Interface}{A structured-grid conceptual interface}
\begin{cxxContents}
\cxxContentsEntry{1.1}{Struct Grids}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{1.2}{Struct Stencils}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{1.3}{Struct Matrices}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{1.4}{Struct Vectors}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{2}{SStruct System Interface}{A semi-structured-grid conceptual interface}
\begin{cxxContents}
\cxxContentsEntry{2.1}{SStruct Grids}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{2.2}{SStruct Stencils}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{2.3}{SStruct Graphs}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{2.4}{SStruct Matrices}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{2.5}{SStruct Vectors}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{3}{IJ System Interface}{A linear-algebraic conceptual interface}
\begin{cxxContents}
\cxxContentsEntry{3.1}{IJ Matrices}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{3.2}{IJ Vectors}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4}{Struct Solvers}{Linear solvers for structured grids}
\begin{cxxContents}
\cxxContentsEntry{4.1}{Struct Solvers}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.2}{Struct Jacobi Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.3}{Struct PFMG Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.4}{Struct SMG Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.5}{Struct PCG Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.6}{Struct GMRES Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.7}{Struct FlexGMRES Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.8}{Struct LGMRES Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.9}{Struct BiCGSTAB Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{4.10}{Struct Hybrid Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{5}{SStruct Solvers}{Linear solvers for semi-structured grids}
\begin{cxxContents}
\cxxContentsEntry{5.1}{SStruct Solvers}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{5.2}{SStruct PCG Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{5.3}{SStruct GMRES Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{5.4}{SStruct FlexGMRES Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{5.5}{SStruct LGMRES Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{5.6}{SStruct BiCGSTAB Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{5.7}{SStruct SysPFMG Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{5.8}{SStruct Split Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{5.9}{SStruct FAC Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{5.10}{SStruct Maxwell Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6}{ParCSR Solvers}{Linear solvers for sparse matrix systems}
\begin{cxxContents}
\cxxContentsEntry{6.1}{ParCSR Solvers}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.2}{ParCSR BoomerAMG Solver and Preconditioner}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.3}{ParCSR ParaSails Preconditioner}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.4}{ParCSR Euclid Preconditioner }{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.5}{ParCSR Pilut Preconditioner}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.6}{ParCSR AMS Solver and Preconditioner}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.7}{ParCSR Hybrid Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.8}{ParCSR PCG Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.9}{ParCSR GMRES Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.10}{ParCSR FlexGMRES Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.11}{ParCSR LGMRES Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{6.12}{ParCSR BiCGSTAB Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{7}{Krylov Solvers}{A basic interface for Krylov solvers}
\begin{cxxContents}
\cxxContentsEntry{7.1}{Krylov Solvers}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{7.2}{PCG Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{7.3}{GMRES Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{7.4}{FlexGMRES Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{7.5}{BiCGSTAB Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{7.6}{LGMRES Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{7.7}{CGNR Solver}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{8}{Finite Element Interface}{A finite element-based conceptual interface}
\begin{cxxContents}
\cxxContentsEntry{8.1}{FEI Functions }{
}
\begin{cxxContents}
\end{cxxContents}
\cxxContentsEntry{8.2}{FEI Solver Parameters}{
}
\begin{cxxContents}
\end{cxxContents}
\end{cxxContents}
\cxxContentsEntry{}{Class Graph}{}\end{cxxContents}
\clearpage\pagebreak
\begin{cxxdoc}



Copyright (c) 2008,  Lawrence Livermore National Security, LLC.
Produced at the Lawrence Livermore National Laboratory.
This file is part of HYPRE.  See file COPYRIGHT for details.

HYPRE is free software; you can redistribute it and/or modify it under the
terms of the GNU Lesser General Public License (as published by the Free
Software Foundation) version 2.1 dated February 1999.


\end{cxxdoc}
\begin{cxxentry}
{}
        {Struct System Interface}
        {}
        {A structured-grid conceptual interface}
        {1}
\begin{cxxnames}
\cxxitem{}
        {Struct Grids}
        {}
        {
}
        {1.1}
\cxxitem{}
        {Struct Stencils}
        {}
        {
}
        {1.2}
\cxxitem{}
        {Struct Matrices}
        {}
        {
}
        {1.3}
\cxxitem{}
        {Struct Vectors}
        {}
        {
}
        {1.4}
\end{cxxnames}
\begin{cxxdoc}


This interface represents a structured-grid conceptual view of a linear
system.


\end{cxxdoc}
\begin{cxxentry}
{}
        {Struct Grids}
        {}
        {
}
        {1.1}
\begin{cxxnames}
\cxxitem{typedef\ struct\ \ \ hypre\_StructGrid\_struct*\ }
        {HYPRE\_StructGrid}
        {}
        {
A grid object is constructed out of several ``boxes'', defined on a global
abstract index space}
        {}
\label{cxx.1.1.3}
\cxxitem{int\ }
        {HYPRE\_StructGridCreate}
        {(MPI\_Comm\ comm,\ int\ ndim,\ HYPRE\_StructGrid\ *grid)}
        {
Create an {\tt ndim}-dimensional grid object}
        {}
\label{cxx.1.1.4}
\cxxitem{int\ }
        {HYPRE\_StructGridDestroy}
        {(HYPRE\_StructGrid\ grid)}
        {
Destroy a grid object}
        {1.1.1}
\cxxitem{int\ }
        {HYPRE\_StructGridSetExtents}
        {(HYPRE\_StructGrid\ grid,\ int\ *ilower,\ int\ *iupper)}
        {
Set the extents for a box on the grid}
        {}
\label{cxx.1.1.5}
\cxxitem{int\ }
        {HYPRE\_StructGridAssemble}
        {(HYPRE\_StructGrid\ grid)}
        {
Finalize the construction of the grid before using}
        {}
\label{cxx.1.1.6}
\cxxitem{int\ }
        {HYPRE\_StructGridSetPeriodic}
        {(HYPRE\_StructGrid\ grid,\ int\ *periodic)}
        {
Set the periodicity for the grid}
        {1.1.2}
\cxxitem{int\ }
        {HYPRE\_StructGridSetNumGhost}
        {(HYPRE\_StructGrid\ grid,\ int\ *num\_ghost)}
        {
Set the ghost layer in the grid object}
        {}
\label{cxx.1.1.7}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructGridDestroy}
        {(HYPRE\_StructGrid\ grid)}
        {
Destroy a grid object}
        {1.1.1}
\begin{cxxdoc}

Destroy a grid object.  An object should be explicitly destroyed using this
destructor when the user's code no longer needs direct access to it.  Once
destroyed, the object must not be referenced again.  Note that the object may
not be deallocated at the completion of this call, since there may be
internal package references to the object.  The object will then be destroyed
when all internal reference counts go to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructGridSetPeriodic}
        {(HYPRE\_StructGrid\ grid,\ int\ *periodic)}
        {
Set the periodicity for the grid}
        {1.1.2}
\begin{cxxdoc}

Set the periodicity for the grid.

The argument {\tt periodic} is an {\tt ndim}-dimensional integer array that
contains the periodicity for each dimension.  A zero value for a dimension
means non-periodic, while a nonzero value means periodic and contains the
actual period.  For example, periodicity in the first and third dimensions
for a 10x11x12 grid is indicated by the array [10,0,12].

NOTE: Some of the solvers in hypre have power-of-two restrictions on the size
of the periodic dimensions.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct Stencils}
        {}
        {
}
        {1.2}
\begin{cxxnames}
\cxxitem{typedef\ struct\ \ \ hypre\_StructStencil\_struct*\ }
        {HYPRE\_StructStencil}
        {}
        {
The stencil object}
        {}
\label{cxx.1.2.2}
\cxxitem{int\ }
        {HYPRE\_StructStencilCreate}
        {(int\ ndim,\ int\ size,\ HYPRE\_StructStencil\ *stencil)}
        {
Create a stencil object for the specified number of spatial dimensions and
stencil entries}
        {}
\label{cxx.1.2.3}
\cxxitem{int\ }
        {HYPRE\_StructStencilDestroy}
        {(HYPRE\_StructStencil\ stencil)}
        {
Destroy a stencil object}
        {}
\label{cxx.1.2.4}
\cxxitem{int\ }
        {HYPRE\_StructStencilSetElement}
        {(HYPRE\_StructStencil\ stencil,\ int\ entry,\ int\ *offset)}
        {
Set a stencil entry}
        {1.2.1}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructStencilSetElement}
        {(HYPRE\_StructStencil\ stencil,\ int\ entry,\ int\ *offset)}
        {
Set a stencil entry}
        {1.2.1}
\begin{cxxdoc}

Set a stencil entry.

NOTE: The name of this routine will eventually be changed to {\tt
HYPRE\_StructStencilSetEntry}.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct Matrices}
        {}
        {
}
        {1.3}
\begin{cxxnames}
\cxxitem{typedef\ struct\ \ \ hypre\_StructMatrix\_struct*\ }
        {HYPRE\_StructMatrix}
        {}
        {
The matrix object}
        {}
\label{cxx.1.3.13}
\cxxitem{int\ }
        {HYPRE\_StructMatrixCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_StructGrid\ grid,\ HYPRE\_StructStencil\ stencil,\ HYPRE\_StructMatrix\ *matrix)}
        {
Create a matrix object}
        {}
\label{cxx.1.3.14}
\cxxitem{int\ }
        {HYPRE\_StructMatrixDestroy}
        {(HYPRE\_StructMatrix\ matrix)}
        {
Destroy a matrix object}
        {}
\label{cxx.1.3.15}
\cxxitem{int\ }
        {HYPRE\_StructMatrixInitialize}
        {(HYPRE\_StructMatrix\ matrix)}
        {
Prepare a matrix object for setting coefficient values}
        {}
\label{cxx.1.3.16}
\cxxitem{int\ }
        {HYPRE\_StructMatrixSetValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ *index,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Set matrix coefficients index by index}
        {1.3.1}
\cxxitem{int\ }
        {HYPRE\_StructMatrixAddToValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ *index,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Add to matrix coefficients index by index}
        {1.3.2}
\cxxitem{int\ }
        {HYPRE\_StructMatrixSetConstantValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Set matrix coefficients which are constant over the grid}
        {1.3.3}
\cxxitem{int\ }
        {HYPRE\_StructMatrixAddToConstantValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Add to matrix coefficients which are constant over the grid}
        {1.3.4}
\cxxitem{int\ }
        {HYPRE\_StructMatrixSetBoxValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ *ilower,\ int\ *iupper,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Set matrix coefficients a box at a time}
        {1.3.5}
\cxxitem{int\ }
        {HYPRE\_StructMatrixAddToBoxValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ *ilower,\ int\ *iupper,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Add to matrix coefficients a box at a time}
        {1.3.6}
\cxxitem{int\ }
        {HYPRE\_StructMatrixAssemble}
        {(HYPRE\_StructMatrix\ matrix)}
        {
Finalize the construction of the matrix before using}
        {}
\label{cxx.1.3.17}
\cxxitem{int\ }
        {HYPRE\_StructMatrixGetValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ *index,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Get matrix coefficients index by index}
        {1.3.7}
\cxxitem{int\ }
        {HYPRE\_StructMatrixGetBoxValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ *ilower,\ int\ *iupper,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Get matrix coefficients a box at a time}
        {1.3.8}
\cxxitem{int\ }
        {HYPRE\_StructMatrixSetSymmetric}
        {(HYPRE\_StructMatrix\ matrix,\ int\ symmetric)}
        {
Define symmetry properties of the matrix}
        {1.3.9}
\cxxitem{int\ }
        {HYPRE\_StructMatrixSetConstantEntries}
        {(\ HYPRE\_StructMatrix\ matrix,\ int\ nentries,\ int\ *entries\ )}
        {
Specify which stencil entries are constant over the grid}
        {1.3.10}
\cxxitem{int\ }
        {HYPRE\_StructMatrixSetNumGhost}
        {(HYPRE\_StructMatrix\ matrix,\ int\ *num\_ghost)}
        {
Set the ghost layer in the matrix }
        {}
\label{cxx.1.3.18}
\cxxitem{int\ }
        {HYPRE\_StructMatrixPrint}
        {(const\ char\ *filename,\ HYPRE\_StructMatrix\ matrix,\ int\ all)}
        {
Print the matrix to file}
        {1.3.11}
\cxxitem{int\ }
        {HYPRE\_StructMatrixMatvec}
        {(\ double\ alpha,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ x,\ double\ beta,\ HYPRE\_StructVector\ y\ )}
        {
Matvec operator}
        {1.3.12}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructMatrixSetValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ *index,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Set matrix coefficients index by index}
        {1.3.1}
\begin{cxxdoc}

Set matrix coefficients index by index.  The {\tt values} array is of length
{\tt nentries}.

NOTE: For better efficiency, use HYPRE\_StructMatrixSetBoxValues ($\rightarrow$1.3.5, {\em page \pageref{cxx.1.3.5}}) to set
coefficients a box at a time.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructMatrixAddToValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ *index,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Add to matrix coefficients index by index}
        {1.3.2}
\begin{cxxdoc}

Add to matrix coefficients index by index.  The {\tt values} array is of
length {\tt nentries}.

NOTE: For better efficiency, use HYPRE\_StructMatrixAddToBoxValues ($\rightarrow$1.3.6, {\em page \pageref{cxx.1.3.6}}) to
set coefficients a box at a time.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructMatrixSetConstantValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Set matrix coefficients which are constant over the grid}
        {1.3.3}
\begin{cxxdoc}

Set matrix coefficients which are constant over the grid.  The {\tt values}
array is of length {\tt nentries}.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructMatrixAddToConstantValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Add to matrix coefficients which are constant over the grid}
        {1.3.4}
\begin{cxxdoc}

Add to matrix coefficients which are constant over the grid.  The {\tt
values} array is of length {\tt nentries}.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructMatrixSetBoxValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ *ilower,\ int\ *iupper,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Set matrix coefficients a box at a time}
        {1.3.5}
\begin{cxxdoc}

Set matrix coefficients a box at a time.  The data in {\tt values} is ordered
as follows:

\begin{verbatim}
   m = 0;
   for (k = ilower[2]; k <= iupper[2]; k++)
      for (j = ilower[1]; j <= iupper[1]; j++)
         for (i = ilower[0]; i <= iupper[0]; i++)
            for (entry = 0; entry < nentries; entry++)
            {
               values[m] = ...;
               m++;
            }
   \end{verbatim}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructMatrixAddToBoxValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ *ilower,\ int\ *iupper,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Add to matrix coefficients a box at a time}
        {1.3.6}
\begin{cxxdoc}

Add to matrix coefficients a box at a time.  The data in {\tt values} is
ordered as in HYPRE\_StructMatrixSetBoxValues ($\rightarrow$1.3.5, {\em page \pageref{cxx.1.3.5}}).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructMatrixGetValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ *index,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Get matrix coefficients index by index}
        {1.3.7}
\begin{cxxdoc}

Get matrix coefficients index by index.  The {\tt values} array is of length
{\tt nentries}.

NOTE: For better efficiency, use HYPRE\_StructMatrixGetBoxValues ($\rightarrow$1.3.8, {\em page \pageref{cxx.1.3.8}}) to get
coefficients a box at a time.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructMatrixGetBoxValues}
        {(HYPRE\_StructMatrix\ matrix,\ int\ *ilower,\ int\ *iupper,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Get matrix coefficients a box at a time}
        {1.3.8}
\begin{cxxdoc}

Get matrix coefficients a box at a time.  The data in {\tt values} is
ordered as in HYPRE\_StructMatrixSetBoxValues ($\rightarrow$1.3.5, {\em page \pageref{cxx.1.3.5}}).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructMatrixSetSymmetric}
        {(HYPRE\_StructMatrix\ matrix,\ int\ symmetric)}
        {
Define symmetry properties of the matrix}
        {1.3.9}
\begin{cxxdoc}

Define symmetry properties of the matrix.  By default, matrices are assumed
to be nonsymmetric.  Significant storage savings can be made if the matrix is
symmetric.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructMatrixSetConstantEntries}
        {(\ HYPRE\_StructMatrix\ matrix,\ int\ nentries,\ int\ *entries\ )}
        {
Specify which stencil entries are constant over the grid}
        {1.3.10}
\begin{cxxdoc}

Specify which stencil entries are constant over the grid.  Declaring entries
to be ``constant over the grid'' yields significant memory savings because
the value for each declared entry will only be stored once.  However, not all
solvers are able to utilize this feature.

Presently supported:
\begin{itemize}
\item no entries constant (this function need not be called)
\item all entries constant
\item all but the diagonal entry constant
\end{itemize}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructMatrixPrint}
        {(const\ char\ *filename,\ HYPRE\_StructMatrix\ matrix,\ int\ all)}
        {
Print the matrix to file}
        {1.3.11}
\begin{cxxdoc}

Print the matrix to file.  This is mainly for debugging purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructMatrixMatvec}
        {(\ double\ alpha,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ x,\ double\ beta,\ HYPRE\_StructVector\ y\ )}
        {
Matvec operator}
        {1.3.12}
\begin{cxxdoc}

Matvec operator.  This operation is  $y = \alpha A x + \beta y$ .
Note that you can do a simple matrix-vector multiply by setting
$\alpha=1$ and $\beta=0$.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct Vectors}
        {}
        {
}
        {1.4}
\begin{cxxnames}
\cxxitem{typedef\ struct\ \ \ hypre\_StructVector\_struct*\ }
        {HYPRE\_StructVector}
        {}
        {
The vector object}
        {}
\label{cxx.1.4.8}
\cxxitem{int\ }
        {HYPRE\_StructVectorCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_StructGrid\ grid,\ HYPRE\_StructVector\ *vector)}
        {
Create a vector object}
        {}
\label{cxx.1.4.9}
\cxxitem{int\ }
        {HYPRE\_StructVectorDestroy}
        {(HYPRE\_StructVector\ vector)}
        {
Destroy a vector object}
        {}
\label{cxx.1.4.10}
\cxxitem{int\ }
        {HYPRE\_StructVectorInitialize}
        {(HYPRE\_StructVector\ vector)}
        {
Prepare a vector object for setting coefficient values}
        {}
\label{cxx.1.4.11}
\cxxitem{int\ }
        {HYPRE\_StructVectorSetValues}
        {(HYPRE\_StructVector\ vector,\ int\ *index,\ double\ value)}
        {
Set vector coefficients index by index}
        {1.4.1}
\cxxitem{int\ }
        {HYPRE\_StructVectorAddToValues}
        {(HYPRE\_StructVector\ vector,\ int\ *index,\ double\ value)}
        {
Add to vector coefficients index by index}
        {1.4.2}
\cxxitem{int\ }
        {HYPRE\_StructVectorSetBoxValues}
        {(HYPRE\_StructVector\ vector,\ int\ *ilower,\ int\ *iupper,\ double\ *values)}
        {
Set vector coefficients a box at a time}
        {1.4.3}
\cxxitem{int\ }
        {HYPRE\_StructVectorAddToBoxValues}
        {(HYPRE\_StructVector\ vector,\ int\ *ilower,\ int\ *iupper,\ double\ *values)}
        {
Add to vector coefficients a box at a time}
        {1.4.4}
\cxxitem{int\ }
        {HYPRE\_StructVectorAssemble}
        {(HYPRE\_StructVector\ vector)}
        {
Finalize the construction of the vector before using}
        {}
\label{cxx.1.4.12}
\cxxitem{int\ }
        {HYPRE\_StructVectorGetValues}
        {(HYPRE\_StructVector\ vector,\ int\ *index,\ double\ *value)}
        {
Get vector coefficients index by index}
        {1.4.5}
\cxxitem{int\ }
        {HYPRE\_StructVectorGetBoxValues}
        {(HYPRE\_StructVector\ vector,\ int\ *ilower,\ int\ *iupper,\ double\ *values)}
        {
Get vector coefficients a box at a time}
        {1.4.6}
\cxxitem{int\ }
        {HYPRE\_StructVectorPrint}
        {(const\ char\ *filename,\ HYPRE\_StructVector\ vector,\ int\ all)}
        {
Print the vector to file}
        {1.4.7}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructVectorSetValues}
        {(HYPRE\_StructVector\ vector,\ int\ *index,\ double\ value)}
        {
Set vector coefficients index by index}
        {1.4.1}
\begin{cxxdoc}

Set vector coefficients index by index.

NOTE: For better efficiency, use HYPRE\_StructVectorSetBoxValues ($\rightarrow$1.4.3, {\em page \pageref{cxx.1.4.3}}) to set
coefficients a box at a time.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructVectorAddToValues}
        {(HYPRE\_StructVector\ vector,\ int\ *index,\ double\ value)}
        {
Add to vector coefficients index by index}
        {1.4.2}
\begin{cxxdoc}

Add to vector coefficients index by index.

NOTE: For better efficiency, use HYPRE\_StructVectorAddToBoxValues ($\rightarrow$1.4.4, {\em page \pageref{cxx.1.4.4}}) to
set coefficients a box at a time.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructVectorSetBoxValues}
        {(HYPRE\_StructVector\ vector,\ int\ *ilower,\ int\ *iupper,\ double\ *values)}
        {
Set vector coefficients a box at a time}
        {1.4.3}
\begin{cxxdoc}

Set vector coefficients a box at a time.  The data in {\tt values} is ordered
as follows:

\begin{verbatim}
   m = 0;
   for (k = ilower[2]; k <= iupper[2]; k++)
      for (j = ilower[1]; j <= iupper[1]; j++)
         for (i = ilower[0]; i <= iupper[0]; i++)
         {
            values[m] = ...;
            m++;
         }
   \end{verbatim}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructVectorAddToBoxValues}
        {(HYPRE\_StructVector\ vector,\ int\ *ilower,\ int\ *iupper,\ double\ *values)}
        {
Add to vector coefficients a box at a time}
        {1.4.4}
\begin{cxxdoc}

Add to vector coefficients a box at a time.  The data in {\tt values} is
ordered as in HYPRE\_StructVectorSetBoxValues ($\rightarrow$1.4.3, {\em page \pageref{cxx.1.4.3}}).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructVectorGetValues}
        {(HYPRE\_StructVector\ vector,\ int\ *index,\ double\ *value)}
        {
Get vector coefficients index by index}
        {1.4.5}
\begin{cxxdoc}

Get vector coefficients index by index.

NOTE: For better efficiency, use HYPRE\_StructVectorGetBoxValues ($\rightarrow$1.4.6, {\em page \pageref{cxx.1.4.6}}) to get
coefficients a box at a time.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructVectorGetBoxValues}
        {(HYPRE\_StructVector\ vector,\ int\ *ilower,\ int\ *iupper,\ double\ *values)}
        {
Get vector coefficients a box at a time}
        {1.4.6}
\begin{cxxdoc}

Get vector coefficients a box at a time.  The data in {\tt values} is ordered
as in HYPRE\_StructVectorSetBoxValues ($\rightarrow$1.4.3, {\em page \pageref{cxx.1.4.3}}).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructVectorPrint}
        {(const\ char\ *filename,\ HYPRE\_StructVector\ vector,\ int\ all)}
        {
Print the vector to file}
        {1.4.7}
\begin{cxxdoc}

Print the vector to file.  This is mainly for debugging purposes.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{extern }
        {SStruct System Interface}
        {}
        {A semi-structured-grid conceptual interface}
        {2}
\begin{cxxnames}
\cxxitem{}
        {SStruct Grids}
        {}
        {
}
        {2.1}
\cxxitem{}
        {SStruct Stencils}
        {}
        {
}
        {2.2}
\cxxitem{}
        {SStruct Graphs}
        {}
        {
}
        {2.3}
\cxxitem{}
        {SStruct Matrices}
        {}
        {
}
        {2.4}
\cxxitem{}
        {SStruct Vectors}
        {}
        {
}
        {2.5}
\end{cxxnames}
\begin{cxxdoc}


This interface represents a semi-structured-grid conceptual view of a linear
system.


\end{cxxdoc}
\begin{cxxentry}
{}
        {SStruct Grids}
        {}
        {
}
        {2.1}
\begin{cxxnames}
\cxxitem{typedef\ struct\ \ \ hypre\_SStructGrid\_struct*\ }
        {HYPRE\_SStructGrid}
        {}
        {
A grid object is constructed out of several structured ``parts'' and an
optional unstructured ``part''}
        {2.1.1}
\cxxitem{typedef\ enum\ \ \ hypre\_SStructVariable\_enum\ }
        {HYPRE\_SStructVariable}
        {}
        {
An enumerated type that supports cell centered, node centered, face centered,
and edge centered variables}
        {2.1.2}
\cxxitem{int\ }
        {HYPRE\_SStructGridCreate}
        {(MPI\_Comm\ comm,\ int\ ndim,\ int\ nparts,\ HYPRE\_SStructGrid\ *grid)}
        {
Create an {\tt ndim}-dimensional grid object with {\tt nparts} structured
parts}
        {}
\label{cxx.2.1.9}
\cxxitem{int\ }
        {HYPRE\_SStructGridDestroy}
        {(HYPRE\_SStructGrid\ grid)}
        {
Destroy a grid object}
        {2.1.3}
\cxxitem{int\ }
        {HYPRE\_SStructGridSetExtents}
        {(HYPRE\_SStructGrid\ grid,\ int\ part,\ int\ *ilower,\ int\ *iupper)}
        {
Set the extents for a box on a structured part of the grid}
        {}
\label{cxx.2.1.10}
\cxxitem{int\ }
        {HYPRE\_SStructGridSetVariables}
        {(HYPRE\_SStructGrid\ grid,\ int\ part,\ int\ nvars,\ HYPRE\_SStructVariable\ *vartypes)}
        {
Describe the variables that live on a structured part of the grid}
        {}
\label{cxx.2.1.11}
\cxxitem{int\ }
        {HYPRE\_SStructGridAddVariables}
        {(HYPRE\_SStructGrid\ grid,\ int\ part,\ int\ *index,\ int\ nvars,\ HYPRE\_SStructVariable\ *vartypes)}
        {
Describe additional variables that live at a particular index}
        {2.1.4}
\cxxitem{int\ }
        {HYPRE\_SStructGridSetNeighborPart}
        {(HYPRE\_SStructGrid\ grid,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ nbor\_part,\ int\ *nbor\_ilower,\ int\ *nbor\_iupper,\ int\ *index\_map,\ int\ *index\_dir)}
        {
Describe how regions just outside of a part relate to other parts}
        {2.1.5}
\cxxitem{int\ }
        {HYPRE\_SStructGridSetNeighborBox}
        {(HYPRE\_SStructGrid\ grid,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ nbor\_part,\ int\ *nbor\_ilower,\ int\ *nbor\_iupper,\ int\ *index\_map)}
        {
(DEFUNCT) Describe how regions just outside of a part relate to other parts}
        {2.1.6}
\cxxitem{int\ }
        {HYPRE\_SStructGridAddUnstructuredPart}
        {(HYPRE\_SStructGrid\ grid,\ int\ ilower,\ int\ iupper)}
        {
Add an unstructured part to the grid}
        {2.1.7}
\cxxitem{int\ }
        {HYPRE\_SStructGridAssemble}
        {(HYPRE\_SStructGrid\ grid)}
        {
Finalize the construction of the grid before using}
        {}
\label{cxx.2.1.12}
\cxxitem{int\ }
        {HYPRE\_SStructGridSetPeriodic}
        {(HYPRE\_SStructGrid\ grid,\ int\ part,\ int\ *periodic)}
        {
Set the periodicity a particular part}
        {2.1.8}
\cxxitem{int\ }
        {HYPRE\_SStructGridSetNumGhost}
        {(HYPRE\_SStructGrid\ grid,\ int\ *num\_ghost)}
        {
Setting ghost in the sgrids}
        {}
\label{cxx.2.1.13}
\end{cxxnames}
\begin{cxxmacro}
{typedef\ struct\ \ \ hypre\_SStructGrid\_struct*\ }
        {HYPRE\_SStructGrid}
        {}
        {
A grid object is constructed out of several structured ``parts'' and an
optional unstructured ``part''}
        {2.1.1}
\begin{cxxdoc}

A grid object is constructed out of several structured ``parts'' and an
optional unstructured ``part''.  Each structured part has its own abstract
index space.
\end{cxxdoc}
\end{cxxmacro}
\begin{cxxmacro}
{typedef\ enum\ \ \ hypre\_SStructVariable\_enum\ }
        {HYPRE\_SStructVariable}
        {}
        {
An enumerated type that supports cell centered, node centered, face centered,
and edge centered variables}
        {2.1.2}
\begin{cxxdoc}

An enumerated type that supports cell centered, node centered, face centered,
and edge centered variables.  Face centered variables are split into x-face,
y-face, and z-face variables, and edge centered variables are split into
x-edge, y-edge, and z-edge variables.  The edge centered variable types are
only used in 3D.  In 2D, edge centered variables are handled by the face
centered types.

Variables are referenced relative to an abstract (cell centered) index in the
following way:
\begin{itemize}
\item cell centered variables are aligned with the index;
\item node centered variables are aligned with the cell corner
at relative index (1/2, 1/2, 1/2);
\item x-face, y-face, and z-face centered variables are aligned
with the faces at relative indexes (1/2, 0, 0), (0, 1/2, 0),
and (0, 0, 1/2), respectively;
\item x-edge, y-edge, and z-edge centered variables are aligned
with the edges at relative indexes (0, 1/2, 1/2), (1/2, 0, 1/2),
and (1/2, 1/2, 0), respectively.
\end{itemize}

The supported identifiers are:
\begin{itemize}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_CELL}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_NODE}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_XFACE}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_YFACE}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_ZFACE}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_XEDGE}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_YEDGE}
\item {\tt HYPRE\_SSTRUCT\_VARIABLE\_ZEDGE}
\end{itemize}

NOTE: Although variables are referenced relative to a unique abstract
cell-centered index, some variables are associated with multiple grid cells.
For example, node centered variables in 3D are associated with 8 cells (away
from boundaries).  Although grid cells are distributed uniquely to different
processes, variables may be owned by multiple processes because they may be
associated with multiple cells.
\end{cxxdoc}
\end{cxxmacro}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructGridDestroy}
        {(HYPRE\_SStructGrid\ grid)}
        {
Destroy a grid object}
        {2.1.3}
\begin{cxxdoc}

Destroy a grid object.  An object should be explicitly destroyed using this
destructor when the user's code no longer needs direct access to it.  Once
destroyed, the object must not be referenced again.  Note that the object may
not be deallocated at the completion of this call, since there may be
internal package references to the object.  The object will then be destroyed
when all internal reference counts go to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructGridAddVariables}
        {(HYPRE\_SStructGrid\ grid,\ int\ part,\ int\ *index,\ int\ nvars,\ HYPRE\_SStructVariable\ *vartypes)}
        {
Describe additional variables that live at a particular index}
        {2.1.4}
\begin{cxxdoc}

Describe additional variables that live at a particular index.  These
variables are appended to the array of variables set in
HYPRE\_SStructGridSetVariables ($\rightarrow$ {\em page \pageref{cxx.2.1.11}}), and are referenced as such.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructGridSetNeighborPart}
        {(HYPRE\_SStructGrid\ grid,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ nbor\_part,\ int\ *nbor\_ilower,\ int\ *nbor\_iupper,\ int\ *index\_map,\ int\ *index\_dir)}
        {
Describe how regions just outside of a part relate to other parts}
        {2.1.5}
\begin{cxxdoc}

Describe how regions just outside of a part relate to other parts.  This is
done a box at a time.

Parts {\tt part} and {\tt nbor\_part} must be different, except in the case
where only cell-centered data is used.

Indexes should increase from {\tt ilower} to {\tt iupper}.  It is not
necessary that indexes increase from {\tt nbor\_ilower} to {\tt
nbor\_iupper}.  This is to ease the transition from the old {\tt
SetNeighborBox} function, and to provide some flexibility for users.

The {\tt index\_map} describes the mapping of indexes 0, 1, and 2 on part
{\tt part} to the corresponding indexes on part {\tt nbor\_part}.  For
example, triple (1, 2, 0) means that indexes 0, 1, and 2 on part {\tt part}
map to indexes 1, 2, and 0 on part {\tt nbor\_part}, respectively.

The {\tt index\_dir} describes the direction of the mapping in {\tt
index\_map}.  For example, triple (1, 1, -1) means that for indexes 0 and 1,
increasing values map to increasing values on {\tt nbor\_part}, while for
index 2, decreasing values map to increasing values.

NOTE: All parts related to each other via this routine must have an identical
list of variables and variable types.  For example, if part 0 has only two
variables on it, a cell centered variable and a node centered variable, and
we declare part 1 to be a neighbor of part 0, then part 1 must also have only
two variables on it, and they must be of type cell and node.  In addition,
variables associated with FACEs or EDGEs must be grouped together and listed
in X, Y, Z order.  This is to enable the code to correctly associate
variables on one part with variables on its neighbor part when a coordinate
transformation is specified.  For example, an XFACE variable on one part may
correspond to a YFACE variable on a neighbor part under a particular
tranformation, and the code determines this association by assuming that the
variable lists are as noted here.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructGridSetNeighborBox}
        {(HYPRE\_SStructGrid\ grid,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ nbor\_part,\ int\ *nbor\_ilower,\ int\ *nbor\_iupper,\ int\ *index\_map)}
        {
(DEFUNCT) Describe how regions just outside of a part relate to other parts}
        {2.1.6}
\begin{cxxdoc}

(DEFUNCT) Describe how regions just outside of a part relate to other parts.
This is done a box at a time.  SHOULD USE {\tt SetNeighborPart} INSTEAD!

Parts {\tt part} and {\tt nbor\_part} must be different, except in the case
where only cell-centered data is used.

The indexes {\tt ilower} and {\tt iupper} map directly to the indexes {\tt
nbor\_ilower} and {\tt nbor\_iupper}.  Although, it is required that indexes
increase from {\tt ilower} to {\tt iupper}, indexes may increase and/or
decrease from {\tt nbor\_ilower} to {\tt nbor\_iupper}.

The {\tt index\_map} describes the mapping of indexes 0, 1, and 2 on part
{\tt part} to the corresponding indexes on part {\tt nbor\_part}.  For
example, triple (1, 2, 0) means that indexes 0, 1, and 2 on part {\tt part}
map to indexes 1, 2, and 0 on part {\tt nbor\_part}, respectively.

NOTE: All parts related to each other via this routine must have an identical
list of variables and variable types.  For example, if part 0 has only two
variables on it, a cell centered variable and a node centered variable, and
we declare part 1 to be a neighbor of part 0, then part 1 must also have only
two variables on it, and they must be of type cell and node.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructGridAddUnstructuredPart}
        {(HYPRE\_SStructGrid\ grid,\ int\ ilower,\ int\ iupper)}
        {
Add an unstructured part to the grid}
        {2.1.7}
\begin{cxxdoc}

Add an unstructured part to the grid.  The variables in the unstructured part
of the grid are referenced by a global rank between 0 and the total number of
unstructured variables minus one.  Each process owns some unique consecutive
range of variables, defined by {\tt ilower} and {\tt iupper}.

NOTE: This is just a placeholder.  This part of the interface is not finished.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructGridSetPeriodic}
        {(HYPRE\_SStructGrid\ grid,\ int\ part,\ int\ *periodic)}
        {
Set the periodicity a particular part}
        {2.1.8}
\begin{cxxdoc}

Set the periodicity a particular part.

The argument {\tt periodic} is an {\tt ndim}-dimensional integer array that
contains the periodicity for each dimension.  A zero value for a dimension
means non-periodic, while a nonzero value means periodic and contains the
actual period.  For example, periodicity in the first and third dimensions
for a 10x11x12 part is indicated by the array [10,0,12].

NOTE: Some of the solvers in hypre have power-of-two restrictions on the size
of the periodic dimensions.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {SStruct Stencils}
        {}
        {
}
        {2.2}
\begin{cxxnames}
\cxxitem{typedef\ struct\ \ \ hypre\_SStructStencil\_struct*\ }
        {HYPRE\_SStructStencil}
        {}
        {
The stencil object}
        {}
\label{cxx.2.2.1}
\cxxitem{int\ }
        {HYPRE\_SStructStencilCreate}
        {(int\ ndim,\ int\ size,\ HYPRE\_SStructStencil\ *stencil)}
        {
Create a stencil object for the specified number of spatial dimensions and
stencil entries}
        {}
\label{cxx.2.2.2}
\cxxitem{int\ }
        {HYPRE\_SStructStencilDestroy}
        {(HYPRE\_SStructStencil\ stencil)}
        {
Destroy a stencil object}
        {}
\label{cxx.2.2.3}
\cxxitem{int\ }
        {HYPRE\_SStructStencilSetEntry}
        {(HYPRE\_SStructStencil\ stencil,\ int\ entry,\ int\ *offset,\ int\ var)}
        {
Set a stencil entry}
        {}
\label{cxx.2.2.4}
\end{cxxnames}
\end{cxxentry}
\begin{cxxentry}
{}
        {SStruct Graphs}
        {}
        {
}
        {2.3}
\begin{cxxnames}
\cxxitem{typedef\ struct\ \ \ hypre\_SStructGraph\_struct*\ }
        {HYPRE\_SStructGraph}
        {}
        {
The graph object is used to describe the nonzero structure of a matrix}
        {}
\label{cxx.2.3.3}
\cxxitem{int\ }
        {HYPRE\_SStructGraphCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_SStructGrid\ grid,\ HYPRE\_SStructGraph\ *graph)}
        {
Create a graph object}
        {}
\label{cxx.2.3.4}
\cxxitem{int\ }
        {HYPRE\_SStructGraphDestroy}
        {(HYPRE\_SStructGraph\ graph)}
        {
Destroy a graph object}
        {}
\label{cxx.2.3.5}
\cxxitem{int\ }
        {HYPRE\_SStructGraphSetStencil}
        {(HYPRE\_SStructGraph\ graph,\ int\ part,\ int\ var,\ HYPRE\_SStructStencil\ stencil)}
        {
Set the stencil for a variable on a structured part of the grid}
        {}
\label{cxx.2.3.6}
\cxxitem{int\ }
        {HYPRE\_SStructGraphAddEntries}
        {(HYPRE\_SStructGraph\ graph,\ int\ part,\ int\ *index,\ int\ var,\ int\ to\_part,\ int\ *to\_index,\ int\ to\_var)}
        {
Add a non-stencil graph entry at a particular index}
        {2.3.1}
\cxxitem{int\ }
        {HYPRE\_SStructGraphSetObjectType}
        {(HYPRE\_SStructGraph\ graph,\ int\ type)}
        {
Set the storage type of the associated matrix object}
        {2.3.2}
\cxxitem{int\ }
        {HYPRE\_SStructGraphAssemble}
        {(HYPRE\_SStructGraph\ graph)}
        {
Finalize the construction of the graph before using}
        {}
\label{cxx.2.3.7}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructGraphAddEntries}
        {(HYPRE\_SStructGraph\ graph,\ int\ part,\ int\ *index,\ int\ var,\ int\ to\_part,\ int\ *to\_index,\ int\ to\_var)}
        {
Add a non-stencil graph entry at a particular index}
        {2.3.1}
\begin{cxxdoc}

Add a non-stencil graph entry at a particular index.  This graph entry is
appended to the existing graph entries, and is referenced as such.

NOTE: Users are required to set graph entries on all processes that own the
associated variables.  This means that some data will be multiply defined.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructGraphSetObjectType}
        {(HYPRE\_SStructGraph\ graph,\ int\ type)}
        {
Set the storage type of the associated matrix object}
        {2.3.2}
\cxxSee{
HYPRE\_SStructMatrixSetObjectType ($\rightarrow$2.4.8, {\em page \pageref{cxx.2.4.8}})\strut}
\begin{cxxdoc}

Set the storage type of the associated matrix object.  It is used before
AddEntries and Assemble to compute the right ranks in the graph.

NOTE: This routine is only necessary for implementation reasons, and will
eventually be removed.


\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {SStruct Matrices}
        {}
        {
}
        {2.4}
\begin{cxxnames}
\cxxitem{typedef\ struct\ \ \ hypre\_SStructMatrix\_struct*\ }
        {HYPRE\_SStructMatrix}
        {}
        {
The matrix object}
        {}
\label{cxx.2.4.11}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_SStructGraph\ graph,\ HYPRE\_SStructMatrix\ *matrix)}
        {
Create a matrix object}
        {}
\label{cxx.2.4.12}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixDestroy}
        {(HYPRE\_SStructMatrix\ matrix)}
        {
Destroy a matrix object}
        {}
\label{cxx.2.4.13}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixInitialize}
        {(HYPRE\_SStructMatrix\ matrix)}
        {
Prepare a matrix object for setting coefficient values}
        {}
\label{cxx.2.4.14}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixSetValues}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ part,\ int\ *index,\ int\ var,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Set matrix coefficients index by index}
        {2.4.1}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixAddToValues}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ part,\ int\ *index,\ int\ var,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Add to matrix coefficients index by index}
        {2.4.2}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixSetBoxValues}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ var,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Set matrix coefficients a box at a time}
        {2.4.3}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixAddToBoxValues}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ var,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Add to matrix coefficients a box at a time}
        {2.4.4}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixAssemble}
        {(HYPRE\_SStructMatrix\ matrix)}
        {
Finalize the construction of the matrix before using}
        {}
\label{cxx.2.4.15}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixGetValues}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ part,\ int\ *index,\ int\ var,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Get matrix coefficients index by index}
        {2.4.5}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixGetBoxValues}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ var,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Get matrix coefficients a box at a time}
        {2.4.6}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixSetSymmetric}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ part,\ int\ var,\ int\ to\_var,\ int\ symmetric)}
        {
Define symmetry properties for the stencil entries in the matrix}
        {2.4.7}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixSetNSSymmetric}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ symmetric)}
        {
Define symmetry properties for all non-stencil matrix entries}
        {}
\label{cxx.2.4.16}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixSetObjectType}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ type)}
        {
Set the storage type of the matrix object to be constructed}
        {2.4.8}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixGetObject}
        {(HYPRE\_SStructMatrix\ matrix,\ void\ **object)}
        {
Get a reference to the constructed matrix object}
        {2.4.9}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixSetComplex}
        {(HYPRE\_SStructMatrix\ matrix)}
        {
Set the matrix to be complex}
        {}
\label{cxx.2.4.17}
\cxxitem{int\ }
        {HYPRE\_SStructMatrixPrint}
        {(const\ char\ *filename,\ HYPRE\_SStructMatrix\ matrix,\ int\ all)}
        {
Print the matrix to file}
        {2.4.10}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMatrixSetValues}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ part,\ int\ *index,\ int\ var,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Set matrix coefficients index by index}
        {2.4.1}
\cxxSee{
HYPRE\_SStructMatrixSetComplex ($\rightarrow$ {\em page \pageref{cxx.2.4.17}})\strut}
\begin{cxxdoc}

Set matrix coefficients index by index.  The {\tt values} array is of length
{\tt nentries}.

NOTE: For better efficiency, use HYPRE\_SStructMatrixSetBoxValues ($\rightarrow$2.4.3, {\em page \pageref{cxx.2.4.3}}) to set
coefficients a box at a time.

NOTE: Users are required to set values on all processes that own the
associated variables.  This means that some data will be multiply defined.

NOTE: The entries in this routine must all be of the same type: either
stencil or non-stencil, but not both.  Also, if they are stencil entries,
they must all represent couplings to the same variable type (there are no
such restrictions for non-stencil entries).

If the matrix is complex, then {\tt values} consists of pairs of doubles
representing the real and imaginary parts of each complex value.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMatrixAddToValues}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ part,\ int\ *index,\ int\ var,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Add to matrix coefficients index by index}
        {2.4.2}
\cxxSee{
HYPRE\_SStructMatrixSetComplex ($\rightarrow$ {\em page \pageref{cxx.2.4.17}})\strut}
\begin{cxxdoc}

Add to matrix coefficients index by index.  The {\tt values} array is of
length {\tt nentries}.

NOTE: For better efficiency, use HYPRE\_SStructMatrixAddToBoxValues ($\rightarrow$2.4.4, {\em page \pageref{cxx.2.4.4}}) to
set coefficients a box at a time.

NOTE: Users are required to set values on all processes that own the
associated variables.  This means that some data will be multiply defined.

NOTE: The entries in this routine must all be of the same type: either
stencil or non-stencil, but not both.  Also, if they are stencil entries,
they must all represent couplings to the same variable type.

If the matrix is complex, then {\tt values} consists of pairs of doubles
representing the real and imaginary parts of each complex value.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMatrixSetBoxValues}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ var,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Set matrix coefficients a box at a time}
        {2.4.3}
\cxxSee{
HYPRE\_SStructMatrixSetComplex ($\rightarrow$ {\em page \pageref{cxx.2.4.17}})\strut}
\begin{cxxdoc}

Set matrix coefficients a box at a time.  The data in {\tt values} is ordered
as follows:

\begin{verbatim}
   m = 0;
   for (k = ilower[2]; k <= iupper[2]; k++)
      for (j = ilower[1]; j <= iupper[1]; j++)
         for (i = ilower[0]; i <= iupper[0]; i++)
            for (entry = 0; entry < nentries; entry++)
            {
               values[m] = ...;
               m++;
            }
   \end{verbatim}

NOTE: Users are required to set values on all processes that own the
associated variables.  This means that some data will be multiply defined.

NOTE: The entries in this routine must all be of the same type: either
stencil or non-stencil, but not both.  Also, if they are stencil entries,
they must all represent couplings to the same variable type (there are no
such restrictions for non-stencil entries).

If the matrix is complex, then {\tt values} consists of pairs of doubles
representing the real and imaginary parts of each complex value.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMatrixAddToBoxValues}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ var,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Add to matrix coefficients a box at a time}
        {2.4.4}
\cxxSee{
HYPRE\_SStructMatrixSetComplex ($\rightarrow$ {\em page \pageref{cxx.2.4.17}})\strut}
\begin{cxxdoc}

Add to matrix coefficients a box at a time.  The data in {\tt values} is
ordered as in HYPRE\_SStructMatrixSetBoxValues ($\rightarrow$2.4.3, {\em page \pageref{cxx.2.4.3}}).

NOTE: Users are required to set values on all processes that own the
associated variables.  This means that some data will be multiply defined.

NOTE: The entries in this routine must all be of stencil type.  Also, they
must all represent couplings to the same variable type.

If the matrix is complex, then {\tt values} consists of pairs of doubles
representing the real and imaginary parts of each complex value.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMatrixGetValues}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ part,\ int\ *index,\ int\ var,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Get matrix coefficients index by index}
        {2.4.5}
\cxxSee{
HYPRE\_SStructMatrixSetComplex ($\rightarrow$ {\em page \pageref{cxx.2.4.17}})\strut}
\begin{cxxdoc}

Get matrix coefficients index by index.  The {\tt values} array is of length
{\tt nentries}.

NOTE: For better efficiency, use HYPRE\_SStructMatrixGetBoxValues ($\rightarrow$2.4.6, {\em page \pageref{cxx.2.4.6}}) to get
coefficients a box at a time.

NOTE: Users may get values on any process that owns the associated variables.

NOTE: The entries in this routine must all be of the same type: either
stencil or non-stencil, but not both.  Also, if they are stencil entries,
they must all represent couplings to the same variable type (there are no
such restrictions for non-stencil entries).

If the matrix is complex, then {\tt values} consists of pairs of doubles
representing the real and imaginary parts of each complex value.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMatrixGetBoxValues}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ var,\ int\ nentries,\ int\ *entries,\ double\ *values)}
        {
Get matrix coefficients a box at a time}
        {2.4.6}
\cxxSee{
HYPRE\_SStructMatrixSetComplex ($\rightarrow$ {\em page \pageref{cxx.2.4.17}})\strut}
\begin{cxxdoc}

Get matrix coefficients a box at a time.  The data in {\tt values} is
ordered as in HYPRE\_SStructMatrixSetBoxValues ($\rightarrow$2.4.3, {\em page \pageref{cxx.2.4.3}}).

NOTE: Users may get values on any process that owns the associated variables.

NOTE: The entries in this routine must all be of stencil type.  Also, they
must all represent couplings to the same variable type.

If the matrix is complex, then {\tt values} consists of pairs of doubles
representing the real and imaginary parts of each complex value.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMatrixSetSymmetric}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ part,\ int\ var,\ int\ to\_var,\ int\ symmetric)}
        {
Define symmetry properties for the stencil entries in the matrix}
        {2.4.7}
\begin{cxxdoc}

Define symmetry properties for the stencil entries in the matrix.  The
boolean argument {\tt symmetric} is applied to stencil entries on part {\tt
part} that couple variable {\tt var} to variable {\tt to\_var}.  A value of
-1 may be used for {\tt part}, {\tt var}, or {\tt to\_var} to specify
``all''.  For example, if {\tt part} and {\tt to\_var} are set to -1, then
the boolean is applied to stencil entries on all parts that couple variable
{\tt var} to all other variables.

By default, matrices are assumed to be nonsymmetric.  Significant
storage savings can be made if the matrix is symmetric.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMatrixSetObjectType}
        {(HYPRE\_SStructMatrix\ matrix,\ int\ type)}
        {
Set the storage type of the matrix object to be constructed}
        {2.4.8}
\cxxSee{
HYPRE\_SStructMatrixGetObject ($\rightarrow$2.4.9, {\em page \pageref{cxx.2.4.9}})\strut}
\begin{cxxdoc}

Set the storage type of the matrix object to be constructed.  Currently, {\tt
type} can be either {\tt HYPRE\_SSTRUCT} (the default), {\tt HYPRE\_STRUCT},
or {\tt HYPRE\_PARCSR}.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMatrixGetObject}
        {(HYPRE\_SStructMatrix\ matrix,\ void\ **object)}
        {
Get a reference to the constructed matrix object}
        {2.4.9}
\cxxSee{
HYPRE\_SStructMatrixSetObjectType ($\rightarrow$2.4.8, {\em page \pageref{cxx.2.4.8}})\strut}
\begin{cxxdoc}

Get a reference to the constructed matrix object.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMatrixPrint}
        {(const\ char\ *filename,\ HYPRE\_SStructMatrix\ matrix,\ int\ all)}
        {
Print the matrix to file}
        {2.4.10}
\begin{cxxdoc}

Print the matrix to file.  This is mainly for debugging purposes.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {SStruct Vectors}
        {}
        {
}
        {2.5}
\begin{cxxnames}
\cxxitem{typedef\ struct\ \ \ hypre\_SStructVector\_struct*\ }
        {HYPRE\_SStructVector}
        {}
        {
The vector object}
        {}
\label{cxx.2.5.11}
\cxxitem{int\ }
        {HYPRE\_SStructVectorCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_SStructGrid\ grid,\ HYPRE\_SStructVector\ *vector)}
        {
Create a vector object}
        {}
\label{cxx.2.5.12}
\cxxitem{int\ }
        {HYPRE\_SStructVectorDestroy}
        {(HYPRE\_SStructVector\ vector)}
        {
Destroy a vector object}
        {}
\label{cxx.2.5.13}
\cxxitem{int\ }
        {HYPRE\_SStructVectorInitialize}
        {(HYPRE\_SStructVector\ vector)}
        {
Prepare a vector object for setting coefficient values}
        {}
\label{cxx.2.5.14}
\cxxitem{int\ }
        {HYPRE\_SStructVectorSetValues}
        {(HYPRE\_SStructVector\ vector,\ int\ part,\ int\ *index,\ int\ var,\ double\ *value)}
        {
Set vector coefficients index by index}
        {2.5.1}
\cxxitem{int\ }
        {HYPRE\_SStructVectorAddToValues}
        {(HYPRE\_SStructVector\ vector,\ int\ part,\ int\ *index,\ int\ var,\ double\ *value)}
        {
Add to vector coefficients index by index}
        {2.5.2}
\cxxitem{int\ }
        {HYPRE\_SStructVectorSetBoxValues}
        {(HYPRE\_SStructVector\ vector,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ var,\ double\ *values)}
        {
Set vector coefficients a box at a time}
        {2.5.3}
\cxxitem{int\ }
        {HYPRE\_SStructVectorAddToBoxValues}
        {(HYPRE\_SStructVector\ vector,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ var,\ double\ *values)}
        {
Add to vector coefficients a box at a time}
        {2.5.4}
\cxxitem{int\ }
        {HYPRE\_SStructVectorAssemble}
        {(HYPRE\_SStructVector\ vector)}
        {
Finalize the construction of the vector before using}
        {}
\label{cxx.2.5.15}
\cxxitem{int\ }
        {HYPRE\_SStructVectorGather}
        {(HYPRE\_SStructVector\ vector)}
        {
Gather vector data so that efficient {\tt GetValues} can be done}
        {2.5.5}
\cxxitem{int\ }
        {HYPRE\_SStructVectorGetValues}
        {(HYPRE\_SStructVector\ vector,\ int\ part,\ int\ *index,\ int\ var,\ double\ *value)}
        {
Get vector coefficients index by index}
        {2.5.6}
\cxxitem{int\ }
        {HYPRE\_SStructVectorGetBoxValues}
        {(HYPRE\_SStructVector\ vector,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ var,\ double\ *values)}
        {
Get vector coefficients a box at a time}
        {2.5.7}
\cxxitem{int\ }
        {HYPRE\_SStructVectorSetObjectType}
        {(HYPRE\_SStructVector\ vector,\ int\ type)}
        {
Set the storage type of the vector object to be constructed}
        {2.5.8}
\cxxitem{int\ }
        {HYPRE\_SStructVectorGetObject}
        {(HYPRE\_SStructVector\ vector,\ void\ **object)}
        {
Get a reference to the constructed vector object}
        {2.5.9}
\cxxitem{int\ }
        {HYPRE\_SStructVectorSetComplex}
        {(HYPRE\_SStructVector\ vector)}
        {
Set the vector to be complex}
        {}
\label{cxx.2.5.16}
\cxxitem{int\ }
        {HYPRE\_SStructVectorPrint}
        {(const\ char\ *filename,\ HYPRE\_SStructVector\ vector,\ int\ all)}
        {
Print the vector to file}
        {2.5.10}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructVectorSetValues}
        {(HYPRE\_SStructVector\ vector,\ int\ part,\ int\ *index,\ int\ var,\ double\ *value)}
        {
Set vector coefficients index by index}
        {2.5.1}
\cxxSee{
HYPRE\_SStructVectorSetComplex ($\rightarrow$ {\em page \pageref{cxx.2.5.16}})\strut}
\begin{cxxdoc}

Set vector coefficients index by index.

NOTE: For better efficiency, use HYPRE\_SStructVectorSetBoxValues ($\rightarrow$2.5.3, {\em page \pageref{cxx.2.5.3}}) to set
coefficients a box at a time.

NOTE: Users are required to set values on all processes that own the
associated variables.  This means that some data will be multiply defined.

If the vector is complex, then {\tt value} consists of a pair of doubles
representing the real and imaginary parts of the complex value.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructVectorAddToValues}
        {(HYPRE\_SStructVector\ vector,\ int\ part,\ int\ *index,\ int\ var,\ double\ *value)}
        {
Add to vector coefficients index by index}
        {2.5.2}
\cxxSee{
HYPRE\_SStructVectorSetComplex ($\rightarrow$ {\em page \pageref{cxx.2.5.16}})\strut}
\begin{cxxdoc}

Add to vector coefficients index by index.

NOTE: For better efficiency, use HYPRE\_SStructVectorAddToBoxValues ($\rightarrow$2.5.4, {\em page \pageref{cxx.2.5.4}}) to
set coefficients a box at a time.

NOTE: Users are required to set values on all processes that own the
associated variables.  This means that some data will be multiply defined.

If the vector is complex, then {\tt value} consists of a pair of doubles
representing the real and imaginary parts of the complex value.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructVectorSetBoxValues}
        {(HYPRE\_SStructVector\ vector,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ var,\ double\ *values)}
        {
Set vector coefficients a box at a time}
        {2.5.3}
\cxxSee{
HYPRE\_SStructVectorSetComplex ($\rightarrow$ {\em page \pageref{cxx.2.5.16}})\strut}
\begin{cxxdoc}

Set vector coefficients a box at a time.  The data in {\tt values} is ordered
as follows:

\begin{verbatim}
   m = 0;
   for (k = ilower[2]; k <= iupper[2]; k++)
      for (j = ilower[1]; j <= iupper[1]; j++)
         for (i = ilower[0]; i <= iupper[0]; i++)
         {
            values[m] = ...;
            m++;
         }
   \end{verbatim}

NOTE: Users are required to set values on all processes that own the
associated variables.  This means that some data will be multiply defined.

If the vector is complex, then {\tt values} consists of pairs of doubles
representing the real and imaginary parts of each complex value.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructVectorAddToBoxValues}
        {(HYPRE\_SStructVector\ vector,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ var,\ double\ *values)}
        {
Add to vector coefficients a box at a time}
        {2.5.4}
\cxxSee{
HYPRE\_SStructVectorSetComplex ($\rightarrow$ {\em page \pageref{cxx.2.5.16}})\strut}
\begin{cxxdoc}

Add to vector coefficients a box at a time.  The data in {\tt values} is
ordered as in HYPRE\_SStructVectorSetBoxValues ($\rightarrow$2.5.3, {\em page \pageref{cxx.2.5.3}}).

NOTE: Users are required to set values on all processes that own the
associated variables.  This means that some data will be multiply defined.

If the vector is complex, then {\tt values} consists of pairs of doubles
representing the real and imaginary parts of each complex value.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructVectorGather}
        {(HYPRE\_SStructVector\ vector)}
        {
Gather vector data so that efficient {\tt GetValues} can be done}
        {2.5.5}
\begin{cxxdoc}

Gather vector data so that efficient {\tt GetValues} can be done.  This
routine must be called prior to calling {\tt GetValues} to insure that
correct and consistent values are returned, especially for non cell-centered
data that is shared between more than one processor.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructVectorGetValues}
        {(HYPRE\_SStructVector\ vector,\ int\ part,\ int\ *index,\ int\ var,\ double\ *value)}
        {
Get vector coefficients index by index}
        {2.5.6}
\cxxSee{
HYPRE\_SStructVectorSetComplex ($\rightarrow$ {\em page \pageref{cxx.2.5.16}})\strut}
\begin{cxxdoc}

Get vector coefficients index by index.

NOTE: For better efficiency, use HYPRE\_SStructVectorGetBoxValues ($\rightarrow$2.5.7, {\em page \pageref{cxx.2.5.7}}) to get
coefficients a box at a time.

NOTE: Users may only get values on processes that own the associated
variables.

If the vector is complex, then {\tt value} consists of a pair of doubles
representing the real and imaginary parts of the complex value.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructVectorGetBoxValues}
        {(HYPRE\_SStructVector\ vector,\ int\ part,\ int\ *ilower,\ int\ *iupper,\ int\ var,\ double\ *values)}
        {
Get vector coefficients a box at a time}
        {2.5.7}
\cxxSee{
HYPRE\_SStructVectorSetComplex ($\rightarrow$ {\em page \pageref{cxx.2.5.16}})\strut}
\begin{cxxdoc}

Get vector coefficients a box at a time.  The data in {\tt values} is ordered
as in HYPRE\_SStructVectorSetBoxValues ($\rightarrow$2.5.3, {\em page \pageref{cxx.2.5.3}}).

NOTE: Users may only get values on processes that own the associated
variables.

If the vector is complex, then {\tt values} consists of pairs of doubles
representing the real and imaginary parts of each complex value.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructVectorSetObjectType}
        {(HYPRE\_SStructVector\ vector,\ int\ type)}
        {
Set the storage type of the vector object to be constructed}
        {2.5.8}
\cxxSee{
HYPRE\_SStructVectorGetObject ($\rightarrow$2.5.9, {\em page \pageref{cxx.2.5.9}})\strut}
\begin{cxxdoc}

Set the storage type of the vector object to be constructed.  Currently, {\tt
type} can be either {\tt HYPRE\_SSTRUCT} (the default), {\tt HYPRE\_STRUCT},
or {\tt HYPRE\_PARCSR}.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructVectorGetObject}
        {(HYPRE\_SStructVector\ vector,\ void\ **object)}
        {
Get a reference to the constructed vector object}
        {2.5.9}
\cxxSee{
HYPRE\_SStructVectorSetObjectType ($\rightarrow$2.5.8, {\em page \pageref{cxx.2.5.8}})\strut}
\begin{cxxdoc}

Get a reference to the constructed vector object.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructVectorPrint}
        {(const\ char\ *filename,\ HYPRE\_SStructVector\ vector,\ int\ all)}
        {
Print the vector to file}
        {2.5.10}
\begin{cxxdoc}

Print the vector to file.  This is mainly for debugging purposes.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{extern }
        {IJ System Interface}
        {}
        {A linear-algebraic conceptual interface}
        {3}
\begin{cxxnames}
\cxxitem{}
        {IJ Matrices}
        {}
        {
}
        {3.1}
\cxxitem{}
        {IJ Vectors}
        {}
        {
}
        {3.2}
\end{cxxnames}
\begin{cxxdoc}


This interface represents a linear-algebraic conceptual view of a
linear system.  The 'I' and 'J' in the name are meant to be
mnemonic for the traditional matrix notation A(I,J).


\end{cxxdoc}
\begin{cxxentry}
{}
        {IJ Matrices}
        {}
        {
}
        {3.1}
\begin{cxxnames}
\cxxitem{typedef\ struct\ \ \ hypre\_IJMatrix\_struct*\ }
        {HYPRE\_IJMatrix}
        {}
        {
The matrix object}
        {}
\label{cxx.3.1.14}
\cxxitem{int\ }
        {HYPRE\_IJMatrixCreate}
        {(MPI\_Comm\ comm,\ int\ ilower,\ int\ iupper,\ int\ jlower,\ int\ jupper,\ HYPRE\_IJMatrix\ *matrix)}
        {
Create a matrix object}
        {3.1.1}
\cxxitem{int\ }
        {HYPRE\_IJMatrixDestroy}
        {(HYPRE\_IJMatrix\ matrix)}
        {
Destroy a matrix object}
        {3.1.2}
\cxxitem{int\ }
        {HYPRE\_IJMatrixInitialize}
        {(HYPRE\_IJMatrix\ matrix)}
        {
Prepare a matrix object for setting coefficient values}
        {3.1.3}
\cxxitem{int\ }
        {HYPRE\_IJMatrixSetValues}
        {(HYPRE\_IJMatrix\ matrix,\ int\ nrows,\ int\ *ncols,\ const\ int\ *rows,\ const\ int\ *cols,\ const\ double\ *values)}
        {
Sets values for {\tt nrows} rows or partial rows of the matrix}
        {3.1.4}
\cxxitem{int\ }
        {HYPRE\_IJMatrixAddToValues}
        {(HYPRE\_IJMatrix\ matrix,\ int\ nrows,\ int\ *ncols,\ const\ int\ *rows,\ const\ int\ *cols,\ const\ double\ *values)}
        {
Adds to values for {\tt nrows} rows or partial rows of the matrix}
        {3.1.5}
\cxxitem{int\ }
        {HYPRE\_IJMatrixAssemble}
        {(HYPRE\_IJMatrix\ matrix)}
        {
Finalize the construction of the matrix before using}
        {}
\label{cxx.3.1.15}
\cxxitem{int\ }
        {HYPRE\_IJMatrixGetRowCounts}
        {(HYPRE\_IJMatrix\ matrix,\ int\ nrows,\ int\ *rows,\ int\ *ncols)}
        {
Gets number of nonzeros elements for {\tt nrows} rows specified in {\tt rows}
and returns them in {\tt ncols}, which needs to be allocated by the
user}
        {}
\label{cxx.3.1.16}
\cxxitem{int\ }
        {HYPRE\_IJMatrixGetValues}
        {(HYPRE\_IJMatrix\ matrix,\ int\ nrows,\ int\ *ncols,\ int\ *rows,\ int\ *cols,\ double\ *values)}
        {
Gets values for {\tt nrows} rows or partial rows of the matrix}
        {3.1.6}
\cxxitem{int\ }
        {HYPRE\_IJMatrixSetObjectType}
        {(HYPRE\_IJMatrix\ matrix,\ int\ type)}
        {
Set the storage type of the matrix object to be constructed}
        {3.1.7}
\cxxitem{int\ }
        {HYPRE\_IJMatrixGetObjectType}
        {(HYPRE\_IJMatrix\ matrix,\ int\ *type)}
        {
Get the storage type of the constructed matrix object}
        {}
\label{cxx.3.1.17}
\cxxitem{int\ }
        {HYPRE\_IJMatrixGetLocalRange}
        {(HYPRE\_IJMatrix\ matrix,\ int\ *ilower,\ int\ *iupper,\ int\ *jlower,\ int\ *jupper)}
        {
Gets range of rows owned by this processor and range
of column partitioning for this processor}
        {}
\label{cxx.3.1.18}
\cxxitem{int\ }
        {HYPRE\_IJMatrixGetObject}
        {(HYPRE\_IJMatrix\ matrix,\ void\ **object)}
        {
Get a reference to the constructed matrix object}
        {3.1.8}
\cxxitem{int\ }
        {HYPRE\_IJMatrixSetRowSizes}
        {(HYPRE\_IJMatrix\ matrix,\ const\ int\ *sizes)}
        {
(Optional) Set the max number of nonzeros to expect in each row}
        {3.1.9}
\cxxitem{int\ }
        {HYPRE\_IJMatrixSetDiagOffdSizes}
        {(HYPRE\_IJMatrix\ matrix,\ const\ int\ *diag\_sizes,\ const\ int\ *offdiag\_sizes)}
        {
(Optional) Set the max number of nonzeros to expect in each row of
the diagonal and off-diagonal blocks}
        {3.1.10}
\cxxitem{int\ }
        {HYPRE\_IJMatrixSetMaxOffProcElmts}
        {(HYPRE\_IJMatrix\ matrix,\ int\ max\_off\_proc\_elmts)}
        {
(Optional) Sets the maximum number of elements that are expected to be set
(or added) on other processors from this processor
This routine can significantly improve the efficiency of matrix
construction, and should always be utilized if possible}
        {3.1.11}
\cxxitem{int\ }
        {HYPRE\_IJMatrixRead}
        {(const\ char\ *filename,\ MPI\_Comm\ comm,\ int\ type,\ HYPRE\_IJMatrix\ *matrix)}
        {
Read the matrix from file}
        {3.1.12}
\cxxitem{int\ }
        {HYPRE\_IJMatrixPrint}
        {(HYPRE\_IJMatrix\ matrix,\ const\ char\ *filename)}
        {
Print the matrix to file}
        {3.1.13}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJMatrixCreate}
        {(MPI\_Comm\ comm,\ int\ ilower,\ int\ iupper,\ int\ jlower,\ int\ jupper,\ HYPRE\_IJMatrix\ *matrix)}
        {
Create a matrix object}
        {3.1.1}
\begin{cxxdoc}

Create a matrix object.  Each process owns some unique consecutive
range of rows, indicated by the global row indices {\tt ilower} and
{\tt iupper}.  The row data is required to be such that the value
of {\tt ilower} on any process $p$ be exactly one more than the
value of {\tt iupper} on process $p-1$.  Note that the first row of
the global matrix may start with any integer value.  In particular,
one may use zero- or one-based indexing.

For square matrices, {\tt jlower} and {\tt jupper} typically should
match {\tt ilower} and {\tt iupper}, respectively.  For rectangular
matrices, {\tt jlower} and {\tt jupper} should define a
partitioning of the columns.  This partitioning must be used for
any vector $v$ that will be used in matrix-vector products with the
rectangular matrix.  The matrix data structure may use {\tt jlower}
and {\tt jupper} to store the diagonal blocks (rectangular in
general) of the matrix separately from the rest of the matrix.

Collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJMatrixDestroy}
        {(HYPRE\_IJMatrix\ matrix)}
        {
Destroy a matrix object}
        {3.1.2}
\begin{cxxdoc}

Destroy a matrix object.  An object should be explicitly destroyed
using this destructor when the user's code no longer needs direct
access to it.  Once destroyed, the object must not be referenced
again.  Note that the object may not be deallocated at the
completion of this call, since there may be internal package
references to the object.  The object will then be destroyed when
all internal reference counts go to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJMatrixInitialize}
        {(HYPRE\_IJMatrix\ matrix)}
        {
Prepare a matrix object for setting coefficient values}
        {3.1.3}
\begin{cxxdoc}

Prepare a matrix object for setting coefficient values.  This
routine will also re-initialize an already assembled matrix,
allowing users to modify coefficient values.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJMatrixSetValues}
        {(HYPRE\_IJMatrix\ matrix,\ int\ nrows,\ int\ *ncols,\ const\ int\ *rows,\ const\ int\ *cols,\ const\ double\ *values)}
        {
Sets values for {\tt nrows} rows or partial rows of the matrix}
        {3.1.4}
\begin{cxxdoc}

Sets values for {\tt nrows} rows or partial rows of the matrix.  
The arrays {\tt ncols}
and {\tt rows} are of dimension {\tt nrows} and contain the number
of columns in each row and the row indices, respectively.  The
array {\tt cols} contains the column indices for each of the {\tt
rows}, and is ordered by rows.  The data in the {\tt values} array
corresponds directly to the column entries in {\tt cols}.  Erases
any previous values at the specified locations and replaces them
with new ones, or, if there was no value there before, inserts a
new one.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJMatrixAddToValues}
        {(HYPRE\_IJMatrix\ matrix,\ int\ nrows,\ int\ *ncols,\ const\ int\ *rows,\ const\ int\ *cols,\ const\ double\ *values)}
        {
Adds to values for {\tt nrows} rows or partial rows of the matrix}
        {3.1.5}
\begin{cxxdoc}

Adds to values for {\tt nrows} rows or partial rows of the matrix.  
Usage details are
analogous to HYPRE\_IJMatrixSetValues ($\rightarrow$3.1.4, {\em page \pageref{cxx.3.1.4}}).  Adds to any previous
values at the specified locations, or, if there was no value there
before, inserts a new one.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJMatrixGetValues}
        {(HYPRE\_IJMatrix\ matrix,\ int\ nrows,\ int\ *ncols,\ int\ *rows,\ int\ *cols,\ double\ *values)}
        {
Gets values for {\tt nrows} rows or partial rows of the matrix}
        {3.1.6}
\begin{cxxdoc}

Gets values for {\tt nrows} rows or partial rows of the matrix.  
Usage details are
analogous to HYPRE\_IJMatrixSetValues ($\rightarrow$3.1.4, {\em page \pageref{cxx.3.1.4}}).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJMatrixSetObjectType}
        {(HYPRE\_IJMatrix\ matrix,\ int\ type)}
        {
Set the storage type of the matrix object to be constructed}
        {3.1.7}
\cxxSee{
HYPRE\_IJMatrixGetObject ($\rightarrow$3.1.8, {\em page \pageref{cxx.3.1.8}})\strut}
\begin{cxxdoc}

Set the storage type of the matrix object to be constructed.
Currently, {\tt type} can only be {\tt HYPRE\_PARCSR}.

Not collective, but must be the same on all processes.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJMatrixGetObject}
        {(HYPRE\_IJMatrix\ matrix,\ void\ **object)}
        {
Get a reference to the constructed matrix object}
        {3.1.8}
\cxxSee{
HYPRE\_IJMatrixSetObjectType ($\rightarrow$3.1.7, {\em page \pageref{cxx.3.1.7}})\strut}
\begin{cxxdoc}

Get a reference to the constructed matrix object.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJMatrixSetRowSizes}
        {(HYPRE\_IJMatrix\ matrix,\ const\ int\ *sizes)}
        {
(Optional) Set the max number of nonzeros to expect in each row}
        {3.1.9}
\begin{cxxdoc}

(Optional) Set the max number of nonzeros to expect in each row.
The array {\tt sizes} contains estimated sizes for each row on this
process.  This call can significantly improve the efficiency of
matrix construction, and should always be utilized if possible.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJMatrixSetDiagOffdSizes}
        {(HYPRE\_IJMatrix\ matrix,\ const\ int\ *diag\_sizes,\ const\ int\ *offdiag\_sizes)}
        {
(Optional) Set the max number of nonzeros to expect in each row of
the diagonal and off-diagonal blocks}
        {3.1.10}
\begin{cxxdoc}

(Optional) Set the max number of nonzeros to expect in each row of
the diagonal and off-diagonal blocks.  The diagonal block is the
submatrix whose column numbers correspond to rows owned by this
process, and the off-diagonal block is everything else.  The arrays
{\tt diag\_sizes} and {\tt offdiag\_sizes} contain estimated sizes
for each row of the diagonal and off-diagonal blocks, respectively.
This routine can significantly improve the efficiency of matrix
construction, and should always be utilized if possible.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJMatrixSetMaxOffProcElmts}
        {(HYPRE\_IJMatrix\ matrix,\ int\ max\_off\_proc\_elmts)}
        {
(Optional) Sets the maximum number of elements that are expected to be set
(or added) on other processors from this processor
This routine can significantly improve the efficiency of matrix
construction, and should always be utilized if possible}
        {3.1.11}
\begin{cxxdoc}

(Optional) Sets the maximum number of elements that are expected to be set
(or added) on other processors from this processor
This routine can significantly improve the efficiency of matrix
construction, and should always be utilized if possible.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJMatrixRead}
        {(const\ char\ *filename,\ MPI\_Comm\ comm,\ int\ type,\ HYPRE\_IJMatrix\ *matrix)}
        {
Read the matrix from file}
        {3.1.12}
\begin{cxxdoc}

Read the matrix from file.  This is mainly for debugging purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJMatrixPrint}
        {(HYPRE\_IJMatrix\ matrix,\ const\ char\ *filename)}
        {
Print the matrix to file}
        {3.1.13}
\begin{cxxdoc}

Print the matrix to file.  This is mainly for debugging purposes.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {IJ Vectors}
        {}
        {
}
        {3.2}
\begin{cxxnames}
\cxxitem{typedef\ struct\ \ \ hypre\_IJVector\_struct*\ }
        {HYPRE\_IJVector}
        {}
        {
The vector object}
        {}
\label{cxx.3.2.12}
\cxxitem{int\ }
        {HYPRE\_IJVectorCreate}
        {(MPI\_Comm\ comm,\ int\ jlower,\ int\ jupper,\ HYPRE\_IJVector\ *vector)}
        {
Create a vector object}
        {3.2.1}
\cxxitem{int\ }
        {HYPRE\_IJVectorDestroy}
        {(HYPRE\_IJVector\ vector)}
        {
Destroy a vector object}
        {3.2.2}
\cxxitem{int\ }
        {HYPRE\_IJVectorInitialize}
        {(HYPRE\_IJVector\ vector)}
        {
Prepare a vector object for setting coefficient values}
        {3.2.3}
\cxxitem{int\ }
        {HYPRE\_IJVectorSetMaxOffProcElmts}
        {(HYPRE\_IJVector\ vector,\ int\ max\_off\_proc\_elmts)}
        {
(Optional) Sets the maximum number of elements that are expected to be set
(or added) on other processors from this processor
This routine can significantly improve the efficiency of matrix
construction, and should always be utilized if possible}
        {3.2.4}
\cxxitem{int\ }
        {HYPRE\_IJVectorSetValues}
        {(HYPRE\_IJVector\ vector,\ int\ nvalues,\ const\ int\ *indices,\ const\ double\ *values)}
        {
Sets values in vector}
        {3.2.5}
\cxxitem{int\ }
        {HYPRE\_IJVectorAddToValues}
        {(HYPRE\_IJVector\ vector,\ int\ nvalues,\ const\ int\ *indices,\ const\ double\ *values)}
        {
Adds to values in vector}
        {3.2.6}
\cxxitem{int\ }
        {HYPRE\_IJVectorAssemble}
        {(HYPRE\_IJVector\ vector)}
        {
Finalize the construction of the vector before using}
        {}
\label{cxx.3.2.13}
\cxxitem{int\ }
        {HYPRE\_IJVectorGetValues}
        {(HYPRE\_IJVector\ vector,\ int\ nvalues,\ const\ int\ *indices,\ double\ *values)}
        {
Gets values in vector}
        {3.2.7}
\cxxitem{int\ }
        {HYPRE\_IJVectorSetObjectType}
        {(HYPRE\_IJVector\ vector,\ int\ type)}
        {
Set the storage type of the vector object to be constructed}
        {3.2.8}
\cxxitem{int\ }
        {HYPRE\_IJVectorGetObjectType}
        {(HYPRE\_IJVector\ vector,\ int\ *type)}
        {
Get the storage type of the constructed vector object}
        {}
\label{cxx.3.2.14}
\cxxitem{int\ }
        {HYPRE\_IJVectorGetLocalRange}
        {(HYPRE\_IJVector\ vector,\ int\ *jlower,\ int\ *jupper)}
        {
Returns range of the part of the vector owned by this processor}
        {}
\label{cxx.3.2.15}
\cxxitem{int\ }
        {HYPRE\_IJVectorGetObject}
        {(HYPRE\_IJVector\ vector,\ void\ **object)}
        {
Get a reference to the constructed vector object}
        {3.2.9}
\cxxitem{int\ }
        {HYPRE\_IJVectorRead}
        {(const\ char\ *filename,\ MPI\_Comm\ comm,\ int\ type,\ HYPRE\_IJVector\ *vector)}
        {
Read the vector from file}
        {3.2.10}
\cxxitem{int\ }
        {HYPRE\_IJVectorPrint}
        {(HYPRE\_IJVector\ vector,\ const\ char\ *filename)}
        {
Print the vector to file}
        {3.2.11}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJVectorCreate}
        {(MPI\_Comm\ comm,\ int\ jlower,\ int\ jupper,\ HYPRE\_IJVector\ *vector)}
        {
Create a vector object}
        {3.2.1}
\begin{cxxdoc}

Create a vector object.  Each process owns some unique consecutive
range of vector unknowns, indicated by the global indices {\tt
jlower} and {\tt jupper}.  The data is required to be such that the
value of {\tt jlower} on any process $p$ be exactly one more than
the value of {\tt jupper} on process $p-1$.  Note that the first
index of the global vector may start with any integer value.  In
particular, one may use zero- or one-based indexing.

Collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJVectorDestroy}
        {(HYPRE\_IJVector\ vector)}
        {
Destroy a vector object}
        {3.2.2}
\begin{cxxdoc}

Destroy a vector object.  An object should be explicitly destroyed
using this destructor when the user's code no longer needs direct
access to it.  Once destroyed, the object must not be referenced
again.  Note that the object may not be deallocated at the
completion of this call, since there may be internal package
references to the object.  The object will then be destroyed when
all internal reference counts go to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJVectorInitialize}
        {(HYPRE\_IJVector\ vector)}
        {
Prepare a vector object for setting coefficient values}
        {3.2.3}
\begin{cxxdoc}

Prepare a vector object for setting coefficient values.  This
routine will also re-initialize an already assembled vector,
allowing users to modify coefficient values.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJVectorSetMaxOffProcElmts}
        {(HYPRE\_IJVector\ vector,\ int\ max\_off\_proc\_elmts)}
        {
(Optional) Sets the maximum number of elements that are expected to be set
(or added) on other processors from this processor
This routine can significantly improve the efficiency of matrix
construction, and should always be utilized if possible}
        {3.2.4}
\begin{cxxdoc}

(Optional) Sets the maximum number of elements that are expected to be set
(or added) on other processors from this processor
This routine can significantly improve the efficiency of matrix
construction, and should always be utilized if possible.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJVectorSetValues}
        {(HYPRE\_IJVector\ vector,\ int\ nvalues,\ const\ int\ *indices,\ const\ double\ *values)}
        {
Sets values in vector}
        {3.2.5}
\begin{cxxdoc}

Sets values in vector.  The arrays {\tt values} and {\tt indices}
are of dimension {\tt nvalues} and contain the vector values to be
set and the corresponding global vector indices, respectively.
Erases any previous values at the specified locations and replaces
them with new ones.

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJVectorAddToValues}
        {(HYPRE\_IJVector\ vector,\ int\ nvalues,\ const\ int\ *indices,\ const\ double\ *values)}
        {
Adds to values in vector}
        {3.2.6}
\begin{cxxdoc}

Adds to values in vector.  Usage details are analogous to
HYPRE\_IJVectorSetValues ($\rightarrow$3.2.5, {\em page \pageref{cxx.3.2.5}}).

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJVectorGetValues}
        {(HYPRE\_IJVector\ vector,\ int\ nvalues,\ const\ int\ *indices,\ double\ *values)}
        {
Gets values in vector}
        {3.2.7}
\begin{cxxdoc}

Gets values in vector.  Usage details are analogous to
HYPRE\_IJVectorSetValues ($\rightarrow$3.2.5, {\em page \pageref{cxx.3.2.5}}).

Not collective.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJVectorSetObjectType}
        {(HYPRE\_IJVector\ vector,\ int\ type)}
        {
Set the storage type of the vector object to be constructed}
        {3.2.8}
\cxxSee{
HYPRE\_IJVectorGetObject ($\rightarrow$3.2.9, {\em page \pageref{cxx.3.2.9}})\strut}
\begin{cxxdoc}

Set the storage type of the vector object to be constructed.
Currently, {\tt type} can only be {\tt HYPRE\_PARCSR}.

Not collective, but must be the same on all processes.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJVectorGetObject}
        {(HYPRE\_IJVector\ vector,\ void\ **object)}
        {
Get a reference to the constructed vector object}
        {3.2.9}
\cxxSee{
HYPRE\_IJVectorSetObjectType ($\rightarrow$3.2.8, {\em page \pageref{cxx.3.2.8}})\strut}
\begin{cxxdoc}

Get a reference to the constructed vector object.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJVectorRead}
        {(const\ char\ *filename,\ MPI\_Comm\ comm,\ int\ type,\ HYPRE\_IJVector\ *vector)}
        {
Read the vector from file}
        {3.2.10}
\begin{cxxdoc}

Read the vector from file.  This is mainly for debugging purposes.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_IJVectorPrint}
        {(HYPRE\_IJVector\ vector,\ const\ char\ *filename)}
        {
Print the vector to file}
        {3.2.11}
\begin{cxxdoc}

Print the vector to file.  This is mainly for debugging purposes.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{extern }
        {Struct Solvers}
        {}
        {Linear solvers for structured grids}
        {4}
\begin{cxxnames}
\cxxitem{}
        {Struct Solvers}
        {}
        {
}
        {4.1}
\cxxitem{}
        {Struct Jacobi Solver}
        {}
        {
}
        {4.2}
\cxxitem{}
        {Struct PFMG Solver}
        {}
        {
}
        {4.3}
\cxxitem{}
        {Struct SMG Solver}
        {}
        {
}
        {4.4}
\cxxitem{}
        {Struct PCG Solver}
        {}
        {
}
        {4.5}
\cxxitem{}
        {Struct GMRES Solver}
        {}
        {
}
        {4.6}
\cxxitem{}
        {Struct FlexGMRES Solver}
        {}
        {
}
        {4.7}
\cxxitem{}
        {Struct LGMRES Solver}
        {}
        {
}
        {4.8}
\cxxitem{}
        {Struct BiCGSTAB Solver}
        {}
        {
}
        {4.9}
\cxxitem{}
        {Struct Hybrid Solver}
        {}
        {
}
        {4.10}
\end{cxxnames}
\begin{cxxdoc}


These solvers use matrix/vector storage schemes that are tailored
to structured grid problems.


\end{cxxdoc}
\begin{cxxentry}
{}
        {Struct Solvers}
        {}
        {
}
        {4.1}
\begin{cxxnames}
\cxxitem{typedef\ struct\ \ \ hypre\_StructSolver\_struct*\ }
        {HYPRE\_StructSolver}
        {}
        {
The solver object}
        {}
\label{cxx.4.1.1}
\end{cxxnames}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct Jacobi Solver}
        {}
        {
}
        {4.2}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_StructJacobiCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_StructSolver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.4.2.5}
\cxxitem{int\ }
        {HYPRE\_StructJacobiDestroy}
        {(HYPRE\_StructSolver\ solver)}
        {
Destroy a solver object}
        {4.2.1}
\cxxitem{int\ }
        {HYPRE\_StructJacobiSetup}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Prepare to solve the system}
        {4.2.2}
\cxxitem{int\ }
        {HYPRE\_StructJacobiSolve}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Solve the system}
        {}
\label{cxx.4.2.6}
\cxxitem{int\ }
        {HYPRE\_StructJacobiSetTol}
        {(HYPRE\_StructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.4.2.7}
\cxxitem{int\ }
        {HYPRE\_StructJacobiSetMaxIter}
        {(HYPRE\_StructSolver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.4.2.8}
\cxxitem{int\ }
        {HYPRE\_StructJacobiSetZeroGuess}
        {(HYPRE\_StructSolver\ solver)}
        {
(Optional) Use a zero initial guess}
        {4.2.3}
\cxxitem{int\ }
        {HYPRE\_StructJacobiSetNonZeroGuess}
        {(HYPRE\_StructSolver\ solver)}
        {
(Optional) Use a nonzero initial guess}
        {4.2.4}
\cxxitem{int\ }
        {HYPRE\_StructJacobiGetNumIterations}
        {(HYPRE\_StructSolver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.4.2.9}
\cxxitem{int\ }
        {HYPRE\_StructJacobiGetFinalRelativeResidualNorm}
        {(HYPRE\_StructSolver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.4.2.10}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructJacobiDestroy}
        {(HYPRE\_StructSolver\ solver)}
        {
Destroy a solver object}
        {4.2.1}
\begin{cxxdoc}

Destroy a solver object.  An object should be explicitly destroyed
using this destructor when the user's code no longer needs direct
access to it.  Once destroyed, the object must not be referenced
again.  Note that the object may not be deallocated at the
completion of this call, since there may be internal package
references to the object.  The object will then be destroyed when
all internal reference counts go to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructJacobiSetup}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Prepare to solve the system}
        {4.2.2}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructJacobiSetZeroGuess}
        {(HYPRE\_StructSolver\ solver)}
        {
(Optional) Use a zero initial guess}
        {4.2.3}
\begin{cxxdoc}

(Optional) Use a zero initial guess.  This allows the solver to cut corners
in the case where a zero initial guess is needed (e.g., for preconditioning)
to reduce compuational cost.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructJacobiSetNonZeroGuess}
        {(HYPRE\_StructSolver\ solver)}
        {
(Optional) Use a nonzero initial guess}
        {4.2.4}
\begin{cxxdoc}

(Optional) Use a nonzero initial guess.  This is the default behavior, but
this routine allows the user to switch back after using {\tt SetZeroGuess}.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct PFMG Solver}
        {}
        {
}
        {4.3}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_StructPFMGCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_StructSolver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.4.3.7}
\cxxitem{int\ }
        {HYPRE\_StructPFMGDestroy}
        {(HYPRE\_StructSolver\ solver)}
        {
Destroy a solver object}
        {}
\label{cxx.4.3.8}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSetup}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Prepare to solve the system}
        {4.3.1}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSolve}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Solve the system}
        {}
\label{cxx.4.3.9}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSetTol}
        {(HYPRE\_StructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.4.3.10}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSetMaxIter}
        {(HYPRE\_StructSolver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.4.3.11}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSetMaxLevels}
        {(HYPRE\_StructSolver\ solver,\ int\ max\_levels)}
        {
(Optional) Set maximum number of multigrid grid levels}
        {}
\label{cxx.4.3.12}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSetRelChange}
        {(HYPRE\_StructSolver\ solver,\ int\ rel\_change)}
        {
(Optional) Additionally require that the relative difference in
successive iterates be small}
        {}
\label{cxx.4.3.13}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSetZeroGuess}
        {(HYPRE\_StructSolver\ solver)}
        {
(Optional) Use a zero initial guess}
        {4.3.2}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSetNonZeroGuess}
        {(HYPRE\_StructSolver\ solver)}
        {
(Optional) Use a nonzero initial guess}
        {4.3.3}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSetRelaxType}
        {(HYPRE\_StructSolver\ solver,\ int\ relax\_type)}
        {
(Optional) Set relaxation type}
        {4.3.4}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSetRAPType}
        {(HYPRE\_StructSolver\ solver,\ int\ rap\_type)}
        {
(Optional) Set type of coarse-grid operator to use}
        {4.3.5}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSetNumPreRelax}
        {(HYPRE\_StructSolver\ solver,\ int\ num\_pre\_relax)}
        {
(Optional) Set number of relaxation sweeps before coarse-grid correction}
        {}
\label{cxx.4.3.14}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSetNumPostRelax}
        {(HYPRE\_StructSolver\ solver,\ int\ num\_post\_relax)}
        {
(Optional) Set number of relaxation sweeps after coarse-grid correction}
        {}
\label{cxx.4.3.15}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSetSkipRelax}
        {(HYPRE\_StructSolver\ solver,\ int\ skip\_relax)}
        {
(Optional) Skip relaxation on certain grids for isotropic problems}
        {4.3.6}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSetLogging}
        {(HYPRE\_StructSolver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.4.3.16}
\cxxitem{int\ }
        {HYPRE\_StructPFMGSetPrintLevel}
        {(HYPRE\_StructSolver\ solver,\ int\ print\_level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.4.3.17}
\cxxitem{int\ }
        {HYPRE\_StructPFMGGetNumIterations}
        {(HYPRE\_StructSolver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.4.3.18}
\cxxitem{int\ }
        {HYPRE\_StructPFMGGetFinalRelativeResidualNorm}
        {(HYPRE\_StructSolver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.4.3.19}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructPFMGSetup}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Prepare to solve the system}
        {4.3.1}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructPFMGSetZeroGuess}
        {(HYPRE\_StructSolver\ solver)}
        {
(Optional) Use a zero initial guess}
        {4.3.2}
\begin{cxxdoc}

(Optional) Use a zero initial guess.  This allows the solver to cut corners
in the case where a zero initial guess is needed (e.g., for preconditioning)
to reduce compuational cost.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructPFMGSetNonZeroGuess}
        {(HYPRE\_StructSolver\ solver)}
        {
(Optional) Use a nonzero initial guess}
        {4.3.3}
\begin{cxxdoc}

(Optional) Use a nonzero initial guess.  This is the default behavior, but
this routine allows the user to switch back after using {\tt SetZeroGuess}.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructPFMGSetRelaxType}
        {(HYPRE\_StructSolver\ solver,\ int\ relax\_type)}
        {
(Optional) Set relaxation type}
        {4.3.4}
\begin{cxxdoc}

(Optional) Set relaxation type.

Current relaxation methods set by {\tt relax\_type} are:

\begin{tabular}{l@{ -- }l}
0 & Jacobi \\
1 & Weighted Jacobi (default) \\
2 & Red/Black Gauss-Seidel (symmetric: RB pre-relaxation, BR post-relaxation) \\
3 & Red/Black Gauss-Seidel (nonsymmetric: RB pre- and post-relaxation) \\
\end{tabular}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructPFMGSetRAPType}
        {(HYPRE\_StructSolver\ solver,\ int\ rap\_type)}
        {
(Optional) Set type of coarse-grid operator to use}
        {4.3.5}
\begin{cxxdoc}

(Optional) Set type of coarse-grid operator to use.

Current operators set by {\tt rap\_type} are:

\begin{tabular}{l@{ -- }l}
0 & Galerkin (default) \\
1 & non-Galerkin 5-pt or 7-pt stencils \\
\end{tabular}

Both operators are constructed algebraically.  The non-Galerkin option
maintains a 5-pt stencil in 2D and a 7-pt stencil in 3D on all grid levels.
The stencil coefficients are computed by averaging techniques.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructPFMGSetSkipRelax}
        {(HYPRE\_StructSolver\ solver,\ int\ skip\_relax)}
        {
(Optional) Skip relaxation on certain grids for isotropic problems}
        {4.3.6}
\begin{cxxdoc}

(Optional) Skip relaxation on certain grids for isotropic problems.  This can
greatly improve efficiency by eliminating unnecessary relaxations when the
underlying problem is isotropic.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct SMG Solver}
        {}
        {
}
        {4.4}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_StructSMGCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_StructSolver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.4.4.4}
\cxxitem{int\ }
        {HYPRE\_StructSMGDestroy}
        {(HYPRE\_StructSolver\ solver)}
        {
Destroy a solver object}
        {}
\label{cxx.4.4.5}
\cxxitem{int\ }
        {HYPRE\_StructSMGSetup}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Prepare to solve the system}
        {4.4.1}
\cxxitem{int\ }
        {HYPRE\_StructSMGSolve}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Solve the system}
        {}
\label{cxx.4.4.6}
\cxxitem{int\ }
        {HYPRE\_StructSMGSetTol}
        {(HYPRE\_StructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.4.4.7}
\cxxitem{int\ }
        {HYPRE\_StructSMGSetMaxIter}
        {(HYPRE\_StructSolver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.4.4.8}
\cxxitem{int\ }
        {HYPRE\_StructSMGSetRelChange}
        {(HYPRE\_StructSolver\ solver,\ int\ rel\_change)}
        {
(Optional) Additionally require that the relative difference in
successive iterates be small}
        {}
\label{cxx.4.4.9}
\cxxitem{int\ }
        {HYPRE\_StructSMGSetZeroGuess}
        {(HYPRE\_StructSolver\ solver)}
        {
(Optional) Use a zero initial guess}
        {4.4.2}
\cxxitem{int\ }
        {HYPRE\_StructSMGSetNonZeroGuess}
        {(HYPRE\_StructSolver\ solver)}
        {
(Optional) Use a nonzero initial guess}
        {4.4.3}
\cxxitem{int\ }
        {HYPRE\_StructSMGSetNumPreRelax}
        {(HYPRE\_StructSolver\ solver,\ int\ num\_pre\_relax)}
        {
(Optional) Set number of relaxation sweeps before coarse-grid correction}
        {}
\label{cxx.4.4.10}
\cxxitem{int\ }
        {HYPRE\_StructSMGSetNumPostRelax}
        {(HYPRE\_StructSolver\ solver,\ int\ num\_post\_relax)}
        {
(Optional) Set number of relaxation sweeps after coarse-grid correction}
        {}
\label{cxx.4.4.11}
\cxxitem{int\ }
        {HYPRE\_StructSMGSetLogging}
        {(HYPRE\_StructSolver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.4.4.12}
\cxxitem{int\ }
        {HYPRE\_StructSMGSetPrintLevel}
        {(HYPRE\_StructSolver\ solver,\ int\ print\_level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.4.4.13}
\cxxitem{int\ }
        {HYPRE\_StructSMGGetNumIterations}
        {(HYPRE\_StructSolver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.4.4.14}
\cxxitem{int\ }
        {HYPRE\_StructSMGGetFinalRelativeResidualNorm}
        {(HYPRE\_StructSolver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.4.4.15}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructSMGSetup}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Prepare to solve the system}
        {4.4.1}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructSMGSetZeroGuess}
        {(HYPRE\_StructSolver\ solver)}
        {
(Optional) Use a zero initial guess}
        {4.4.2}
\begin{cxxdoc}

(Optional) Use a zero initial guess.  This allows the solver to cut corners
in the case where a zero initial guess is needed (e.g., for preconditioning)
to reduce compuational cost.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructSMGSetNonZeroGuess}
        {(HYPRE\_StructSolver\ solver)}
        {
(Optional) Use a nonzero initial guess}
        {4.4.3}
\begin{cxxdoc}

(Optional) Use a nonzero initial guess.  This is the default behavior, but
this routine allows the user to switch back after using {\tt SetZeroGuess}.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct PCG Solver}
        {}
        {
}
        {4.5}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_StructPCGCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_StructSolver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.4.5.3}
\cxxitem{int\ }
        {HYPRE\_StructPCGDestroy}
        {(HYPRE\_StructSolver\ solver)}
        {
Destroy a solver object}
        {}
\label{cxx.4.5.4}
\cxxitem{int\ }
        {HYPRE\_StructPCGSetup}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Prepare to solve the system}
        {4.5.1}
\cxxitem{int\ }
        {HYPRE\_StructPCGSolve}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Solve the system}
        {}
\label{cxx.4.5.5}
\cxxitem{int\ }
        {HYPRE\_StructPCGSetTol}
        {(HYPRE\_StructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.4.5.6}
\cxxitem{int\ }
        {HYPRE\_StructPCGSetAbsoluteTol}
        {(HYPRE\_StructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the absolute convergence tolerance (default is
0)}
        {4.5.2}
\cxxitem{int\ }
        {HYPRE\_StructPCGSetMaxIter}
        {(HYPRE\_StructSolver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.4.5.7}
\cxxitem{int\ }
        {HYPRE\_StructPCGSetTwoNorm}
        {(HYPRE\_StructSolver\ solver,\ int\ two\_norm)}
        {
(Optional) Use the two-norm in stopping criteria}
        {}
\label{cxx.4.5.8}
\cxxitem{int\ }
        {HYPRE\_StructPCGSetRelChange}
        {(HYPRE\_StructSolver\ solver,\ int\ rel\_change)}
        {
(Optional) Additionally require that the relative difference in
successive iterates be small}
        {}
\label{cxx.4.5.9}
\cxxitem{int\ }
        {HYPRE\_StructPCGSetPrecond}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_PtrToStructSolverFcn\ precond,\ HYPRE\_PtrToStructSolverFcn\ precond\_setup,\ HYPRE\_StructSolver\ precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.4.5.10}
\cxxitem{int\ }
        {HYPRE\_StructPCGSetLogging}
        {(HYPRE\_StructSolver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.4.5.11}
\cxxitem{int\ }
        {HYPRE\_StructPCGSetPrintLevel}
        {(HYPRE\_StructSolver\ solver,\ int\ level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.4.5.12}
\cxxitem{int\ }
        {HYPRE\_StructPCGGetNumIterations}
        {(HYPRE\_StructSolver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.4.5.13}
\cxxitem{int\ }
        {HYPRE\_StructPCGGetFinalRelativeResidualNorm}
        {(HYPRE\_StructSolver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.4.5.14}
\cxxitem{int\ }
        {HYPRE\_StructPCGGetResidual}
        {(HYPRE\_StructSolver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.4.5.15}
\cxxitem{int\ }
        {HYPRE\_StructDiagScaleSetup}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ y,\ HYPRE\_StructVector\ x)}
        {
Setup routine for diagonal preconditioning}
        {}
\label{cxx.4.5.16}
\cxxitem{int\ }
        {HYPRE\_StructDiagScale}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ HA,\ HYPRE\_StructVector\ Hy,\ HYPRE\_StructVector\ Hx)}
        {
Solve routine for diagonal preconditioning}
        {}
\label{cxx.4.5.17}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructPCGSetup}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Prepare to solve the system}
        {4.5.1}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructPCGSetAbsoluteTol}
        {(HYPRE\_StructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the absolute convergence tolerance (default is
0)}
        {4.5.2}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default is
0). If one desires the convergence test to check the absolute
convergence tolerance {\it only}, then set the relative convergence
tolerance to 0.0.  (The default convergence test is $ \<C*r,r\> \leq$
max(relative$\_$tolerance$^{2} \ast \<C*b, b\>$, absolute$\_$tolerance$^2$).)
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct GMRES Solver}
        {}
        {
}
        {4.6}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_StructGMRESCreate}
        {(\ MPI\_Comm\ comm,\ HYPRE\_StructSolver\ *solver\ )}
        {
Create a solver object}
        {}
\label{cxx.4.6.3}
\cxxitem{int\ }
        {HYPRE\_StructGMRESDestroy}
        {(\ HYPRE\_StructSolver\ solver\ )}
        {
Destroy a solver object}
        {}
\label{cxx.4.6.4}
\cxxitem{int\ }
        {HYPRE\_StructGMRESSetup}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x\ )}
        {
Prepare to solve the system}
        {4.6.1}
\cxxitem{int\ }
        {HYPRE\_StructGMRESSolve}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x\ )}
        {
Solve the system}
        {}
\label{cxx.4.6.5}
\cxxitem{int\ }
        {HYPRE\_StructGMRESSetTol}
        {(\ HYPRE\_StructSolver\ solver,\ double\ tol\ )}
        {
(Optional) Set the relative convergence tolerance}
        {}
\label{cxx.4.6.6}
\cxxitem{int\ }
        {HYPRE\_StructGMRESSetAbsoluteTol}
        {(\ HYPRE\_StructSolver\ solver,\ double\ tol\ )}
        {
(Optional) Set the absolute convergence tolerance  (default: 0)}
        {4.6.2}
\cxxitem{int\ }
        {HYPRE\_StructGMRESSetMaxIter}
        {(\ HYPRE\_StructSolver\ solver,\ int\ max\_iter\ )}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.4.6.7}
\cxxitem{int\ }
        {HYPRE\_StructGMRESSetKDim}
        {(\ HYPRE\_StructSolver\ solver,\ int\ k\_dim\ )}
        {
(Optional) Set the dimension of the Krylov subspace}
        {}
\label{cxx.4.6.8}
\cxxitem{int\ }
        {HYPRE\_StructGMRESSetPrecond}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_PtrToStructSolverFcn\ precond,\ HYPRE\_PtrToStructSolverFcn\ precond\_setup,\ HYPRE\_StructSolver\ precond\_solver\ )}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.4.6.9}
\cxxitem{int\ }
        {HYPRE\_StructGMRESSetLogging}
        {(\ HYPRE\_StructSolver\ solver,\ int\ logging\ )}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.4.6.10}
\cxxitem{int\ }
        {HYPRE\_StructGMRESSetPrintLevel}
        {(\ HYPRE\_StructSolver\ solver,\ int\ level\ )}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.4.6.11}
\cxxitem{int\ }
        {HYPRE\_StructGMRESGetNumIterations}
        {(\ HYPRE\_StructSolver\ solver,\ int\ *num\_iterations\ )}
        {
Return the number of iterations taken}
        {}
\label{cxx.4.6.12}
\cxxitem{int\ }
        {HYPRE\_StructGMRESGetFinalRelativeResidualNorm}
        {(\ HYPRE\_StructSolver\ solver,\ double\ *norm\ )}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.4.6.13}
\cxxitem{int\ }
        {HYPRE\_StructGMRESGetResidual}
        {(\ HYPRE\_StructSolver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.4.6.14}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructGMRESSetup}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x\ )}
        {
Prepare to solve the system}
        {4.6.1}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructGMRESSetAbsoluteTol}
        {(\ HYPRE\_StructSolver\ solver,\ double\ tol\ )}
        {
(Optional) Set the absolute convergence tolerance  (default: 0)}
        {4.6.2}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance  (default: 0).
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance$\ast \|b\|$, absolute$\_$tolerance).)
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct FlexGMRES Solver}
        {}
        {
}
        {4.7}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESCreate}
        {(\ MPI\_Comm\ comm,\ HYPRE\_StructSolver\ *solver\ )}
        {
Create a solver object}
        {}
\label{cxx.4.7.3}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESDestroy}
        {(\ HYPRE\_StructSolver\ solver\ )}
        {
Destroy a solver object}
        {}
\label{cxx.4.7.4}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESSetup}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x\ )}
        {
Prepare to solve the system}
        {4.7.1}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESSolve}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x\ )}
        {
Solve the system}
        {}
\label{cxx.4.7.5}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESSetTol}
        {(\ HYPRE\_StructSolver\ solver,\ double\ tol\ )}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.4.7.6}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESSetAbsoluteTol}
        {(\ HYPRE\_StructSolver\ solver,\ double\ tol\ )}
        {
(Optional) Set the absolute convergence tolerance (default: 0)}
        {4.7.2}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESSetMaxIter}
        {(\ HYPRE\_StructSolver\ solver,\ int\ max\_iter\ )}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.4.7.7}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESSetKDim}
        {(\ HYPRE\_StructSolver\ solver,\ int\ k\_dim\ )}
        {
(Optional) Set the dimension of the Krylov subspace}
        {}
\label{cxx.4.7.8}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESSetPrecond}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_PtrToStructSolverFcn\ precond,\ HYPRE\_PtrToStructSolverFcn\ precond\_setup,\ HYPRE\_StructSolver\ precond\_solver\ )}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.4.7.9}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESSetLogging}
        {(\ HYPRE\_StructSolver\ solver,\ int\ logging\ )}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.4.7.10}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESSetPrintLevel}
        {(\ HYPRE\_StructSolver\ solver,\ int\ level\ )}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.4.7.11}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESGetNumIterations}
        {(\ HYPRE\_StructSolver\ solver,\ int\ *num\_iterations\ )}
        {
Return the number of iterations taken}
        {}
\label{cxx.4.7.12}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESGetFinalRelativeResidualNorm}
        {(\ HYPRE\_StructSolver\ solver,\ double\ *norm\ )}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.4.7.13}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESGetResidual}
        {(\ HYPRE\_StructSolver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.4.7.14}
\cxxitem{int\ }
        {HYPRE\_StructFlexGMRESSetModifyPC}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_PtrToModifyPCFcn\ modify\_pc)}
        {
Set a user-defined function to modify solve-time preconditioner attributes}
        {}
\label{cxx.4.7.15}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructFlexGMRESSetup}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x\ )}
        {
Prepare to solve the system}
        {4.7.1}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructFlexGMRESSetAbsoluteTol}
        {(\ HYPRE\_StructSolver\ solver,\ double\ tol\ )}
        {
(Optional) Set the absolute convergence tolerance (default: 0)}
        {4.7.2}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default: 0).
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance$\ast \|b\|$, absolute$\_$tolerance).)
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct LGMRES Solver}
        {}
        {
}
        {4.8}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESCreate}
        {(\ MPI\_Comm\ comm,\ HYPRE\_StructSolver\ *solver\ )}
        {
Create a solver object}
        {}
\label{cxx.4.8.4}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESDestroy}
        {(\ HYPRE\_StructSolver\ solver\ )}
        {
Destroy a solver object}
        {}
\label{cxx.4.8.5}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESSetup}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x\ )}
        {
Prepare to solve the system}
        {4.8.1}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESSolve}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x\ )}
        {
Solve the system}
        {4.8.2}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESSetTol}
        {(\ HYPRE\_StructSolver\ solver,\ double\ tol\ )}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.4.8.6}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESSetAbsoluteTol}
        {(\ HYPRE\_StructSolver\ solver,\ double\ tol\ )}
        {
(Optional) Set the absolute convergence tolerance (default: 0) }
        {4.8.3}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESSetMaxIter}
        {(\ HYPRE\_StructSolver\ solver,\ int\ max\_iter\ )}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.4.8.7}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESSetKDim}
        {(\ HYPRE\_StructSolver\ solver,\ int\ k\_dim\ )}
        {
(Optional) Set the dimension of the approximation subspace}
        {}
\label{cxx.4.8.8}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESSetAugDim}
        {(\ HYPRE\_StructSolver\ solver,\ int\ aug\_dim\ )}
        {
(Optional) Set the number of augmentation vectors  (default: 2)}
        {}
\label{cxx.4.8.9}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESSetPrecond}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_PtrToStructSolverFcn\ precond,\ HYPRE\_PtrToStructSolverFcn\ precond\_setup,\ HYPRE\_StructSolver\ precond\_solver\ )}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.4.8.10}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESSetLogging}
        {(\ HYPRE\_StructSolver\ solver,\ int\ logging\ )}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.4.8.11}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESSetPrintLevel}
        {(\ HYPRE\_StructSolver\ solver,\ int\ level\ )}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.4.8.12}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESGetNumIterations}
        {(\ HYPRE\_StructSolver\ solver,\ int\ *num\_iterations\ )}
        {
Return the number of iterations taken}
        {}
\label{cxx.4.8.13}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESGetFinalRelativeResidualNorm}
        {(\ HYPRE\_StructSolver\ solver,\ double\ *norm\ )}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.4.8.14}
\cxxitem{int\ }
        {HYPRE\_StructLGMRESGetResidual}
        {(\ HYPRE\_StructSolver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.4.8.15}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructLGMRESSetup}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x\ )}
        {
Prepare to solve the system}
        {4.8.1}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructLGMRESSolve}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x\ )}
        {
Solve the system}
        {4.8.2}
\begin{cxxdoc}

Solve the system. Details on LGMRES may be found in A. H. Baker,
E.R. Jessup, and T.A. Manteuffel. A technique for accelerating the
convergence of restarted GMRES. SIAM Journal on Matrix Analysis and
Applications, 26 (2005), pp. 962-984. LGMRES(m,k) in the paper
corresponds to LGMRES(Kdim+AugDim, AugDim).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructLGMRESSetAbsoluteTol}
        {(\ HYPRE\_StructSolver\ solver,\ double\ tol\ )}
        {
(Optional) Set the absolute convergence tolerance (default: 0) }
        {4.8.3}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default: 0) .
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance$\ast \|b\|$, absolute$\_$tolerance).)
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct BiCGSTAB Solver}
        {}
        {
}
        {4.9}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_StructBiCGSTABCreate}
        {(\ MPI\_Comm\ comm,\ HYPRE\_StructSolver\ *solver\ )}
        {
Create a solver object}
        {}
\label{cxx.4.9.3}
\cxxitem{int\ }
        {HYPRE\_StructBiCGSTABDestroy}
        {(\ HYPRE\_StructSolver\ solver\ )}
        {
Destroy a solver object}
        {}
\label{cxx.4.9.4}
\cxxitem{int\ }
        {HYPRE\_StructBiCGSTABSetup}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x\ )}
        {
Prepare to solve the system}
        {4.9.1}
\cxxitem{int\ }
        {HYPRE\_StructBiCGSTABSolve}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x\ )}
        {
Solve the system}
        {}
\label{cxx.4.9.5}
\cxxitem{int\ }
        {HYPRE\_StructBiCGSTABSetTol}
        {(\ HYPRE\_StructSolver\ solver,\ double\ tol\ )}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.4.9.6}
\cxxitem{int\ }
        {HYPRE\_StructBiCGSTABSetAbsoluteTol}
        {(\ HYPRE\_StructSolver\ solver,\ double\ tol\ )}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {4.9.2}
\cxxitem{int\ }
        {HYPRE\_StructBiCGSTABSetMaxIter}
        {(\ HYPRE\_StructSolver\ solver,\ int\ max\_iter\ )}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.4.9.7}
\cxxitem{int\ }
        {HYPRE\_StructBiCGSTABSetPrecond}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_PtrToStructSolverFcn\ precond,\ HYPRE\_PtrToStructSolverFcn\ precond\_setup,\ HYPRE\_StructSolver\ precond\_solver\ )}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.4.9.8}
\cxxitem{int\ }
        {HYPRE\_StructBiCGSTABSetLogging}
        {(\ HYPRE\_StructSolver\ solver,\ int\ logging\ )}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.4.9.9}
\cxxitem{int\ }
        {HYPRE\_StructBiCGSTABSetPrintLevel}
        {(\ HYPRE\_StructSolver\ solver,\ int\ level\ )}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.4.9.10}
\cxxitem{int\ }
        {HYPRE\_StructBiCGSTABGetNumIterations}
        {(\ HYPRE\_StructSolver\ solver,\ int\ *num\_iterations\ )}
        {
Return the number of iterations taken}
        {}
\label{cxx.4.9.11}
\cxxitem{int\ }
        {HYPRE\_StructBiCGSTABGetFinalRelativeResidualNorm}
        {(\ HYPRE\_StructSolver\ solver,\ double\ *norm\ )}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.4.9.12}
\cxxitem{int\ }
        {HYPRE\_StructBiCGSTABGetResidual}
        {(\ HYPRE\_StructSolver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.4.9.13}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructBiCGSTABSetup}
        {(\ HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x\ )}
        {
Prepare to solve the system}
        {4.9.1}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructBiCGSTABSetAbsoluteTol}
        {(\ HYPRE\_StructSolver\ solver,\ double\ tol\ )}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {4.9.2}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default is 0). 
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance $\ast \|b\|$, absolute$\_$tolerance).)

\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {Struct Hybrid Solver}
        {}
        {
}
        {4.10}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_StructHybridCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_StructSolver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.4.10.6}
\cxxitem{int\ }
        {HYPRE\_StructHybridDestroy}
        {(HYPRE\_StructSolver\ solver)}
        {
Destroy a solver object}
        {}
\label{cxx.4.10.7}
\cxxitem{int\ }
        {HYPRE\_StructHybridSetup}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Prepare to solve the system}
        {4.10.1}
\cxxitem{int\ }
        {HYPRE\_StructHybridSolve}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Solve the system}
        {}
\label{cxx.4.10.8}
\cxxitem{int\ }
        {HYPRE\_StructHybridSetTol}
        {(HYPRE\_StructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.4.10.9}
\cxxitem{int\ }
        {HYPRE\_StructHybridSetConvergenceTol}
        {(HYPRE\_StructSolver\ solver,\ double\ cf\_tol)}
        {
(Optional) Set an accepted convergence tolerance for diagonal scaling (DS)}
        {4.10.2}
\cxxitem{int\ }
        {HYPRE\_StructHybridSetDSCGMaxIter}
        {(HYPRE\_StructSolver\ solver,\ int\ ds\_max\_its)}
        {
(Optional) Set maximum number of iterations for diagonal scaling (DS)}
        {4.10.3}
\cxxitem{int\ }
        {HYPRE\_StructHybridSetPCGMaxIter}
        {(HYPRE\_StructSolver\ solver,\ int\ pre\_max\_its)}
        {
(Optional) Set maximum number of iterations for general preconditioner (PRE)}
        {4.10.4}
\cxxitem{int\ }
        {HYPRE\_StructHybridSetTwoNorm}
        {(HYPRE\_StructSolver\ solver,\ int\ two\_norm)}
        {
(Optional) Use the two-norm in stopping criteria}
        {}
\label{cxx.4.10.10}
\cxxitem{int\ }
        {HYPRE\_StructHybridSetRelChange}
        {(HYPRE\_StructSolver\ solver,\ int\ rel\_change)}
        {
(Optional) Additionally require that the relative difference in
successive iterates be small}
        {}
\label{cxx.4.10.11}
\cxxitem{int\ }
        {HYPRE\_StructHybridSetSolverType}
        {(HYPRE\_StructSolver\ solver,\ int\ solver\_type)}
        {
(Optional) Set the type of Krylov solver to use}
        {4.10.5}
\cxxitem{int\ }
        {HYPRE\_StructHybridSetKDim}
        {(HYPRE\_StructSolver\ solver,\ int\ k\_dim)}
        {
(Optional) Set the maximum size of the Krylov space when using GMRES}
        {}
\label{cxx.4.10.12}
\cxxitem{int\ }
        {HYPRE\_StructHybridSetPrecond}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_PtrToStructSolverFcn\ precond,\ HYPRE\_PtrToStructSolverFcn\ precond\_setup,\ HYPRE\_StructSolver\ precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.4.10.13}
\cxxitem{int\ }
        {HYPRE\_StructHybridSetLogging}
        {(HYPRE\_StructSolver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.4.10.14}
\cxxitem{int\ }
        {HYPRE\_StructHybridSetPrintLevel}
        {(HYPRE\_StructSolver\ solver,\ int\ print\_level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.4.10.15}
\cxxitem{int\ }
        {HYPRE\_StructHybridGetNumIterations}
        {(HYPRE\_StructSolver\ solver,\ int\ *num\_its)}
        {
Return the number of iterations taken}
        {}
\label{cxx.4.10.16}
\cxxitem{int\ }
        {HYPRE\_StructHybridGetDSCGNumIterations}
        {(HYPRE\_StructSolver\ solver,\ int\ *ds\_num\_its)}
        {
Return the number of diagonal scaling iterations taken}
        {}
\label{cxx.4.10.17}
\cxxitem{int\ }
        {HYPRE\_StructHybridGetPCGNumIterations}
        {(HYPRE\_StructSolver\ solver,\ int\ *pre\_num\_its)}
        {
Return the number of general preconditioning iterations taken}
        {}
\label{cxx.4.10.18}
\cxxitem{int\ }
        {HYPRE\_StructHybridGetFinalRelativeResidualNorm}
        {(HYPRE\_StructSolver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.4.10.19}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructHybridSetup}
        {(HYPRE\_StructSolver\ solver,\ HYPRE\_StructMatrix\ A,\ HYPRE\_StructVector\ b,\ HYPRE\_StructVector\ x)}
        {
Prepare to solve the system}
        {4.10.1}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructHybridSetConvergenceTol}
        {(HYPRE\_StructSolver\ solver,\ double\ cf\_tol)}
        {
(Optional) Set an accepted convergence tolerance for diagonal scaling (DS)}
        {4.10.2}
\begin{cxxdoc}

(Optional) Set an accepted convergence tolerance for diagonal scaling (DS).
The solver will switch preconditioners if the convergence of DS is slower
than {\tt cf\_tol}.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructHybridSetDSCGMaxIter}
        {(HYPRE\_StructSolver\ solver,\ int\ ds\_max\_its)}
        {
(Optional) Set maximum number of iterations for diagonal scaling (DS)}
        {4.10.3}
\begin{cxxdoc}

(Optional) Set maximum number of iterations for diagonal scaling (DS).  The
solver will switch preconditioners if DS reaches {\tt ds\_max\_its}.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructHybridSetPCGMaxIter}
        {(HYPRE\_StructSolver\ solver,\ int\ pre\_max\_its)}
        {
(Optional) Set maximum number of iterations for general preconditioner (PRE)}
        {4.10.4}
\begin{cxxdoc}

(Optional) Set maximum number of iterations for general preconditioner (PRE).
The solver will stop if PRE reaches {\tt pre\_max\_its}.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_StructHybridSetSolverType}
        {(HYPRE\_StructSolver\ solver,\ int\ solver\_type)}
        {
(Optional) Set the type of Krylov solver to use}
        {4.10.5}
\begin{cxxdoc}

(Optional) Set the type of Krylov solver to use.

Current krylov methods set by {\tt solver\_type} are:

\begin{tabular}{l@{ -- }l}
0 & PCG (default) \\
1 & GMRES \\
2 & BiCGSTAB \\
\end{tabular}
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{extern }
        {SStruct Solvers}
        {}
        {Linear solvers for semi-structured grids}
        {5}
\begin{cxxnames}
\cxxitem{}
        {SStruct Solvers}
        {}
        {
}
        {5.1}
\cxxitem{}
        {SStruct PCG Solver}
        {}
        {
}
        {5.2}
\cxxitem{}
        {SStruct GMRES Solver}
        {}
        {
}
        {5.3}
\cxxitem{}
        {SStruct FlexGMRES Solver}
        {}
        {
}
        {5.4}
\cxxitem{}
        {SStruct LGMRES Solver}
        {}
        {
}
        {5.5}
\cxxitem{}
        {SStruct BiCGSTAB Solver}
        {}
        {
}
        {5.6}
\cxxitem{}
        {SStruct SysPFMG Solver}
        {}
        {
}
        {5.7}
\cxxitem{}
        {SStruct Split Solver}
        {}
        {
}
        {5.8}
\cxxitem{}
        {SStruct FAC Solver}
        {}
        {
}
        {5.9}
\cxxitem{}
        {SStruct Maxwell Solver}
        {}
        {
}
        {5.10}
\end{cxxnames}
\begin{cxxdoc}


These solvers use matrix/vector storage schemes that are taylored
to semi-structured grid problems.


\end{cxxdoc}
\begin{cxxentry}
{}
        {SStruct Solvers}
        {}
        {
}
        {5.1}
\begin{cxxnames}
\cxxitem{typedef\ struct\ \ \ hypre\_SStructSolver\_struct*\ }
        {HYPRE\_SStructSolver}
        {}
        {
The solver object}
        {}
\label{cxx.5.1.1}
\end{cxxnames}
\end{cxxentry}
\begin{cxxentry}
{}
        {SStruct PCG Solver}
        {}
        {
}
        {5.2}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_SStructPCGCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_SStructSolver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.5.2.4}
\cxxitem{int\ }
        {HYPRE\_SStructPCGDestroy}
        {(HYPRE\_SStructSolver\ solver)}
        {
Destroy a solver object}
        {5.2.1}
\cxxitem{int\ }
        {HYPRE\_SStructPCGSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.2.2}
\cxxitem{int\ }
        {HYPRE\_SStructPCGSolve}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Solve the system}
        {}
\label{cxx.5.2.5}
\cxxitem{int\ }
        {HYPRE\_SStructPCGSetTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.5.2.6}
\cxxitem{int\ }
        {HYPRE\_SStructPCGSetAbsoluteTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the absolute convergence tolerance (default is
0)}
        {5.2.3}
\cxxitem{int\ }
        {HYPRE\_SStructPCGSetMaxIter}
        {(HYPRE\_SStructSolver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.5.2.7}
\cxxitem{int\ }
        {HYPRE\_SStructPCGSetTwoNorm}
        {(\ HYPRE\_SStructSolver\ solver,\ int\ two\_norm\ )}
        {
(Optional) Use the two-norm in stopping criteria}
        {}
\label{cxx.5.2.8}
\cxxitem{int\ }
        {HYPRE\_SStructPCGSetRelChange}
        {(\ HYPRE\_SStructSolver\ solver,\ int\ rel\_change\ )}
        {
(Optional) Additionally require that the relative difference in
successive iterates be small}
        {}
\label{cxx.5.2.9}
\cxxitem{int\ }
        {HYPRE\_SStructPCGSetPrecond}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_PtrToSStructSolverFcn\ precond,\ HYPRE\_PtrToSStructSolverFcn\ precond\_setup,\ void\ *precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.5.2.10}
\cxxitem{int\ }
        {HYPRE\_SStructPCGSetLogging}
        {(HYPRE\_SStructSolver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.5.2.11}
\cxxitem{int\ }
        {HYPRE\_SStructPCGSetPrintLevel}
        {(HYPRE\_SStructSolver\ solver,\ int\ level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.5.2.12}
\cxxitem{int\ }
        {HYPRE\_SStructPCGGetNumIterations}
        {(HYPRE\_SStructSolver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.5.2.13}
\cxxitem{int\ }
        {HYPRE\_SStructPCGGetFinalRelativeResidualNorm}
        {(HYPRE\_SStructSolver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.5.2.14}
\cxxitem{int\ }
        {HYPRE\_SStructPCGGetResidual}
        {(HYPRE\_SStructSolver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.5.2.15}
\cxxitem{int\ }
        {HYPRE\_SStructDiagScaleSetup}
        {(\ HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ y,\ HYPRE\_SStructVector\ x\ )}
        {
Setup routine for diagonal preconditioning}
        {}
\label{cxx.5.2.16}
\cxxitem{int\ }
        {HYPRE\_SStructDiagScale}
        {(\ HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ y,\ HYPRE\_SStructVector\ x\ )}
        {
Solve routine for diagonal preconditioning}
        {}
\label{cxx.5.2.17}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructPCGDestroy}
        {(HYPRE\_SStructSolver\ solver)}
        {
Destroy a solver object}
        {5.2.1}
\begin{cxxdoc}

Destroy a solver object.  An object should be explicitly destroyed
using this destructor when the user's code no longer needs direct
access to it.  Once destroyed, the object must not be referenced
again.  Note that the object may not be deallocated at the
completion of this call, since there may be internal package
references to the object.  The object will then be destroyed when
all internal reference counts go to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructPCGSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.2.2}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructPCGSetAbsoluteTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the absolute convergence tolerance (default is
0)}
        {5.2.3}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default is
0). If one desires the convergence test to check the absolute
convergence tolerance {\it only}, then set the relative convergence
tolerance to 0.0.  (The default convergence test is $ \<C*r,r\> \leq$
max(relative$\_$tolerance$^{2} \ast \<C*b, b\>$, absolute$\_$tolerance$^2$).)
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {SStruct GMRES Solver}
        {}
        {
}
        {5.3}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_SStructGMRESCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_SStructSolver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.5.3.4}
\cxxitem{int\ }
        {HYPRE\_SStructGMRESDestroy}
        {(HYPRE\_SStructSolver\ solver)}
        {
Destroy a solver object}
        {5.3.1}
\cxxitem{int\ }
        {HYPRE\_SStructGMRESSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.3.2}
\cxxitem{int\ }
        {HYPRE\_SStructGMRESSolve}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Solve the system}
        {}
\label{cxx.5.3.5}
\cxxitem{int\ }
        {HYPRE\_SStructGMRESSetTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the relative convergence tolerance}
        {}
\label{cxx.5.3.6}
\cxxitem{int\ }
        {HYPRE\_SStructGMRESSetAbsoluteTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the absolute convergence tolerance  (default: 0)}
        {5.3.3}
\cxxitem{int\ }
        {HYPRE\_SStructGMRESSetMaxIter}
        {(HYPRE\_SStructSolver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.5.3.7}
\cxxitem{int\ }
        {HYPRE\_SStructGMRESSetKDim}
        {(HYPRE\_SStructSolver\ solver,\ int\ k\_dim)}
        {
(Optional) Set the maximum size of the Krylov space}
        {}
\label{cxx.5.3.8}
\cxxitem{int\ }
        {HYPRE\_SStructGMRESSetPrecond}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_PtrToSStructSolverFcn\ precond,\ HYPRE\_PtrToSStructSolverFcn\ precond\_setup,\ void\ *precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.5.3.9}
\cxxitem{int\ }
        {HYPRE\_SStructGMRESSetLogging}
        {(HYPRE\_SStructSolver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.5.3.10}
\cxxitem{int\ }
        {HYPRE\_SStructGMRESSetPrintLevel}
        {(HYPRE\_SStructSolver\ solver,\ int\ print\_level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.5.3.11}
\cxxitem{int\ }
        {HYPRE\_SStructGMRESGetNumIterations}
        {(HYPRE\_SStructSolver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.5.3.12}
\cxxitem{int\ }
        {HYPRE\_SStructGMRESGetFinalRelativeResidualNorm}
        {(HYPRE\_SStructSolver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.5.3.13}
\cxxitem{int\ }
        {HYPRE\_SStructGMRESGetResidual}
        {(HYPRE\_SStructSolver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.5.3.14}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructGMRESDestroy}
        {(HYPRE\_SStructSolver\ solver)}
        {
Destroy a solver object}
        {5.3.1}
\begin{cxxdoc}

Destroy a solver object.  An object should be explicitly destroyed
using this destructor when the user's code no longer needs direct
access to it.  Once destroyed, the object must not be referenced
again.  Note that the object may not be deallocated at the
completion of this call, since there may be internal package
references to the object.  The object will then be destroyed when
all internal reference counts go to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructGMRESSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.3.2}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructGMRESSetAbsoluteTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the absolute convergence tolerance  (default: 0)}
        {5.3.3}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance  (default: 0).
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance$\ast \|b\|$, absolute$\_$tolerance).)
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {SStruct FlexGMRES Solver}
        {}
        {
}
        {5.4}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_SStructSolver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.5.4.4}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESDestroy}
        {(HYPRE\_SStructSolver\ solver)}
        {
Destroy a solver object}
        {5.4.1}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.4.2}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESSolve}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Solve the system}
        {}
\label{cxx.5.4.5}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESSetTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the relative convergence tolerance}
        {}
\label{cxx.5.4.6}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESSetAbsoluteTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the absolute convergence tolerance (default: 0)}
        {5.4.3}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESSetMaxIter}
        {(HYPRE\_SStructSolver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.5.4.7}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESSetKDim}
        {(HYPRE\_SStructSolver\ solver,\ int\ k\_dim)}
        {
(Optional) Set the maximum size of the Krylov space}
        {}
\label{cxx.5.4.8}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESSetPrecond}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_PtrToSStructSolverFcn\ precond,\ HYPRE\_PtrToSStructSolverFcn\ precond\_setup,\ void\ *precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.5.4.9}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESSetLogging}
        {(HYPRE\_SStructSolver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.5.4.10}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESSetPrintLevel}
        {(HYPRE\_SStructSolver\ solver,\ int\ print\_level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.5.4.11}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESGetNumIterations}
        {(HYPRE\_SStructSolver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.5.4.12}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESGetFinalRelativeResidualNorm}
        {(HYPRE\_SStructSolver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.5.4.13}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESGetResidual}
        {(HYPRE\_SStructSolver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.5.4.14}
\cxxitem{int\ }
        {HYPRE\_SStructFlexGMRESSetModifyPC}
        {(\ HYPRE\_SStructSolver\ solver,\ HYPRE\_PtrToModifyPCFcn\ modify\_pc)}
        {
Set a user-defined function to modify solve-time preconditioner attributes}
        {}
\label{cxx.5.4.15}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructFlexGMRESDestroy}
        {(HYPRE\_SStructSolver\ solver)}
        {
Destroy a solver object}
        {5.4.1}
\begin{cxxdoc}

Destroy a solver object.  An object should be explicitly destroyed
using this destructor when the user's code no longer needs direct
access to it.  Once destroyed, the object must not be referenced
again.  Note that the object may not be deallocated at the
completion of this call, since there may be internal package
references to the object.  The object will then be destroyed when
all internal reference counts go to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructFlexGMRESSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.4.2}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructFlexGMRESSetAbsoluteTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the absolute convergence tolerance (default: 0)}
        {5.4.3}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default: 0).
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance$\ast \|b\|$, absolute$\_$tolerance).)
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {SStruct LGMRES Solver}
        {}
        {
}
        {5.5}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_SStructSolver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.5.5.5}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESDestroy}
        {(HYPRE\_SStructSolver\ solver)}
        {
Destroy a solver object}
        {5.5.1}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.5.2}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESSolve}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Solve the system}
        {5.5.3}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESSetTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the relative convergence tolerance}
        {}
\label{cxx.5.5.6}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESSetAbsoluteTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the absolute convergence tolerance  (default: 0)}
        {5.5.4}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESSetMaxIter}
        {(HYPRE\_SStructSolver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.5.5.7}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESSetKDim}
        {(HYPRE\_SStructSolver\ solver,\ int\ k\_dim)}
        {
(Optional) Set the maximum size of the approximation space}
        {}
\label{cxx.5.5.8}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESSetAugDim}
        {(HYPRE\_SStructSolver\ solver,\ int\ aug\_dim)}
        {
(Optional) Set the number of augmentation vectors(default: 2)}
        {}
\label{cxx.5.5.9}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESSetPrecond}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_PtrToSStructSolverFcn\ precond,\ HYPRE\_PtrToSStructSolverFcn\ precond\_setup,\ void\ *precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.5.5.10}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESSetLogging}
        {(HYPRE\_SStructSolver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.5.5.11}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESSetPrintLevel}
        {(HYPRE\_SStructSolver\ solver,\ int\ print\_level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.5.5.12}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESGetNumIterations}
        {(HYPRE\_SStructSolver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.5.5.13}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESGetFinalRelativeResidualNorm}
        {(HYPRE\_SStructSolver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.5.5.14}
\cxxitem{int\ }
        {HYPRE\_SStructLGMRESGetResidual}
        {(HYPRE\_SStructSolver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.5.5.15}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructLGMRESDestroy}
        {(HYPRE\_SStructSolver\ solver)}
        {
Destroy a solver object}
        {5.5.1}
\begin{cxxdoc}

Destroy a solver object.  An object should be explicitly destroyed
using this destructor when the user's code no longer needs direct
access to it.  Once destroyed, the object must not be referenced
again.  Note that the object may not be deallocated at the
completion of this call, since there may be internal package
references to the object.  The object will then be destroyed when
all internal reference counts go to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructLGMRESSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.5.2}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructLGMRESSolve}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Solve the system}
        {5.5.3}
\begin{cxxdoc}

Solve the system.Details on LGMRES may be found in A. H. Baker,
E.R. Jessup, and T.A. Manteuffel. A technique for accelerating the
convergence of restarted GMRES. SIAM Journal on Matrix Analysis and
Applications, 26 (2005), pp. 962-984. LGMRES(m,k) in the paper
corresponds to LGMRES(Kdim+AugDim, AugDim).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructLGMRESSetAbsoluteTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the absolute convergence tolerance  (default: 0)}
        {5.5.4}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance  (default: 0).
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance$\ast \|b\|$, absolute$\_$tolerance).)
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {SStruct BiCGSTAB Solver}
        {}
        {
}
        {5.6}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_SStructBiCGSTABCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_SStructSolver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.5.6.4}
\cxxitem{int\ }
        {HYPRE\_SStructBiCGSTABDestroy}
        {(HYPRE\_SStructSolver\ solver)}
        {
Destroy a solver object}
        {5.6.1}
\cxxitem{int\ }
        {HYPRE\_SStructBiCGSTABSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.6.2}
\cxxitem{int\ }
        {HYPRE\_SStructBiCGSTABSolve}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Solve the system}
        {}
\label{cxx.5.6.5}
\cxxitem{int\ }
        {HYPRE\_SStructBiCGSTABSetTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.5.6.6}
\cxxitem{int\ }
        {HYPRE\_SStructBiCGSTABSetAbsoluteTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {5.6.3}
\cxxitem{int\ }
        {HYPRE\_SStructBiCGSTABSetMaxIter}
        {(HYPRE\_SStructSolver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.5.6.7}
\cxxitem{int\ }
        {HYPRE\_SStructBiCGSTABSetPrecond}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_PtrToSStructSolverFcn\ precond,\ HYPRE\_PtrToSStructSolverFcn\ precond\_setup,\ void\ *precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.5.6.8}
\cxxitem{int\ }
        {HYPRE\_SStructBiCGSTABSetLogging}
        {(HYPRE\_SStructSolver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.5.6.9}
\cxxitem{int\ }
        {HYPRE\_SStructBiCGSTABSetPrintLevel}
        {(HYPRE\_SStructSolver\ solver,\ int\ level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.5.6.10}
\cxxitem{int\ }
        {HYPRE\_SStructBiCGSTABGetNumIterations}
        {(HYPRE\_SStructSolver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.5.6.11}
\cxxitem{int\ }
        {HYPRE\_SStructBiCGSTABGetFinalRelativeResidualNorm}
        {(HYPRE\_SStructSolver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.5.6.12}
\cxxitem{int\ }
        {HYPRE\_SStructBiCGSTABGetResidual}
        {(HYPRE\_SStructSolver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.5.6.13}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructBiCGSTABDestroy}
        {(HYPRE\_SStructSolver\ solver)}
        {
Destroy a solver object}
        {5.6.1}
\begin{cxxdoc}

Destroy a solver object.  An object should be explicitly destroyed
using this destructor when the user's code no longer needs direct
access to it.  Once destroyed, the object must not be referenced
again.  Note that the object may not be deallocated at the
completion of this call, since there may be internal package
references to the object.  The object will then be destroyed when
all internal reference counts go to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructBiCGSTABSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.6.2}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructBiCGSTABSetAbsoluteTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {5.6.3}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default is 0). 
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance $\ast \|b\|$, absolute$\_$tolerance).)

\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {SStruct SysPFMG Solver}
        {}
        {
}
        {5.7}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGCreate}
        {(\ MPI\_Comm\ comm,\ HYPRE\_SStructSolver\ *solver\ )}
        {
Create a solver object}
        {}
\label{cxx.5.7.7}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGDestroy}
        {(HYPRE\_SStructSolver\ solver)}
        {
Destroy a solver object}
        {5.7.1}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.7.2}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGSolve}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Solve the system}
        {}
\label{cxx.5.7.8}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGSetTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.5.7.9}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGSetMaxIter}
        {(HYPRE\_SStructSolver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.5.7.10}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGSetRelChange}
        {(HYPRE\_SStructSolver\ solver,\ int\ rel\_change)}
        {
(Optional) Additionally require that the relative difference in
successive iterates be small}
        {}
\label{cxx.5.7.11}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGSetZeroGuess}
        {(HYPRE\_SStructSolver\ solver)}
        {
(Optional) Use a zero initial guess}
        {5.7.3}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGSetNonZeroGuess}
        {(HYPRE\_SStructSolver\ solver)}
        {
(Optional) Use a nonzero initial guess}
        {5.7.4}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGSetRelaxType}
        {(HYPRE\_SStructSolver\ solver,\ int\ relax\_type)}
        {
(Optional) Set relaxation type}
        {5.7.5}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGSetJacobiWeight}
        {(HYPRE\_SStructSolver\ solver,\ double\ weight)}
        {
(Optional) Set Jacobi Weight}
        {}
\label{cxx.5.7.12}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGSetNumPreRelax}
        {(HYPRE\_SStructSolver\ solver,\ int\ num\_pre\_relax)}
        {
(Optional) Set number of relaxation sweeps before coarse-grid correction}
        {}
\label{cxx.5.7.13}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGSetNumPostRelax}
        {(HYPRE\_SStructSolver\ solver,\ int\ num\_post\_relax)}
        {
(Optional) Set number of relaxation sweeps after coarse-grid correction}
        {}
\label{cxx.5.7.14}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGSetSkipRelax}
        {(HYPRE\_SStructSolver\ solver,\ int\ skip\_relax)}
        {
(Optional) Skip relaxation on certain grids for isotropic problems}
        {5.7.6}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGSetLogging}
        {(HYPRE\_SStructSolver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.5.7.15}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGSetPrintLevel}
        {(HYPRE\_SStructSolver\ solver,\ int\ print\_level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.5.7.16}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGGetNumIterations}
        {(HYPRE\_SStructSolver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.5.7.17}
\cxxitem{int\ }
        {HYPRE\_SStructSysPFMGGetFinalRelativeResidualNorm}
        {(\ HYPRE\_SStructSolver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.5.7.18}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructSysPFMGDestroy}
        {(HYPRE\_SStructSolver\ solver)}
        {
Destroy a solver object}
        {5.7.1}
\begin{cxxdoc}

Destroy a solver object.  An object should be explicitly destroyed
using this destructor when the user's code no longer needs direct
access to it.  Once destroyed, the object must not be referenced
again.  Note that the object may not be deallocated at the
completion of this call, since there may be internal package
references to the object.  The object will then be destroyed when
all internal reference counts go to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructSysPFMGSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.7.2}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructSysPFMGSetZeroGuess}
        {(HYPRE\_SStructSolver\ solver)}
        {
(Optional) Use a zero initial guess}
        {5.7.3}
\begin{cxxdoc}

(Optional) Use a zero initial guess.  This allows the solver to cut corners
in the case where a zero initial guess is needed (e.g., for preconditioning)
to reduce compuational cost.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructSysPFMGSetNonZeroGuess}
        {(HYPRE\_SStructSolver\ solver)}
        {
(Optional) Use a nonzero initial guess}
        {5.7.4}
\begin{cxxdoc}

(Optional) Use a nonzero initial guess.  This is the default behavior, but
this routine allows the user to switch back after using {\tt SetZeroGuess}.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructSysPFMGSetRelaxType}
        {(HYPRE\_SStructSolver\ solver,\ int\ relax\_type)}
        {
(Optional) Set relaxation type}
        {5.7.5}
\begin{cxxdoc}

(Optional) Set relaxation type.

Current relaxation methods set by {\tt relax\_type} are:

\begin{tabular}{l@{ -- }l}
0 & Jacobi \\
1 & Weighted Jacobi (default) \\
2 & Red/Black Gauss-Seidel (symmetric: RB pre-relaxation, BR post-relaxation) \\
\end{tabular}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructSysPFMGSetSkipRelax}
        {(HYPRE\_SStructSolver\ solver,\ int\ skip\_relax)}
        {
(Optional) Skip relaxation on certain grids for isotropic problems}
        {5.7.6}
\begin{cxxdoc}

(Optional) Skip relaxation on certain grids for isotropic problems.  This can
greatly improve efficiency by eliminating unnecessary relaxations when the
underlying problem is isotropic.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {SStruct Split Solver}
        {}
        {
}
        {5.8}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_SStructSplitCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_SStructSolver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.5.8.6}
\cxxitem{int\ }
        {HYPRE\_SStructSplitDestroy}
        {(HYPRE\_SStructSolver\ solver)}
        {
Destroy a solver object}
        {5.8.1}
\cxxitem{int\ }
        {HYPRE\_SStructSplitSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.8.2}
\cxxitem{int\ }
        {HYPRE\_SStructSplitSolve}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Solve the system}
        {}
\label{cxx.5.8.7}
\cxxitem{int\ }
        {HYPRE\_SStructSplitSetTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.5.8.8}
\cxxitem{int\ }
        {HYPRE\_SStructSplitSetMaxIter}
        {(HYPRE\_SStructSolver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.5.8.9}
\cxxitem{int\ }
        {HYPRE\_SStructSplitSetZeroGuess}
        {(HYPRE\_SStructSolver\ solver)}
        {
(Optional) Use a zero initial guess}
        {5.8.3}
\cxxitem{int\ }
        {HYPRE\_SStructSplitSetNonZeroGuess}
        {(HYPRE\_SStructSolver\ solver)}
        {
(Optional) Use a nonzero initial guess}
        {5.8.4}
\cxxitem{int\ }
        {HYPRE\_SStructSplitSetStructSolver}
        {(HYPRE\_SStructSolver\ solver,\ int\ ssolver\ )}
        {
(Optional) Set up the type of diagonal struct solver}
        {5.8.5}
\cxxitem{int\ }
        {HYPRE\_SStructSplitGetNumIterations}
        {(HYPRE\_SStructSolver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.5.8.10}
\cxxitem{int\ }
        {HYPRE\_SStructSplitGetFinalRelativeResidualNorm}
        {(HYPRE\_SStructSolver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.5.8.11}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructSplitDestroy}
        {(HYPRE\_SStructSolver\ solver)}
        {
Destroy a solver object}
        {5.8.1}
\begin{cxxdoc}

Destroy a solver object.  An object should be explicitly destroyed
using this destructor when the user's code no longer needs direct
access to it.  Once destroyed, the object must not be referenced
again.  Note that the object may not be deallocated at the
completion of this call, since there may be internal package
references to the object.  The object will then be destroyed when
all internal reference counts go to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructSplitSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.8.2}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructSplitSetZeroGuess}
        {(HYPRE\_SStructSolver\ solver)}
        {
(Optional) Use a zero initial guess}
        {5.8.3}
\begin{cxxdoc}

(Optional) Use a zero initial guess.  This allows the solver to cut corners
in the case where a zero initial guess is needed (e.g., for preconditioning)
to reduce compuational cost.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructSplitSetNonZeroGuess}
        {(HYPRE\_SStructSolver\ solver)}
        {
(Optional) Use a nonzero initial guess}
        {5.8.4}
\begin{cxxdoc}

(Optional) Use a nonzero initial guess.  This is the default behavior, but
this routine allows the user to switch back after using {\tt SetZeroGuess}.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructSplitSetStructSolver}
        {(HYPRE\_SStructSolver\ solver,\ int\ ssolver\ )}
        {
(Optional) Set up the type of diagonal struct solver}
        {5.8.5}
\begin{cxxdoc}

(Optional) Set up the type of diagonal struct solver.  Either {\tt ssolver} is
set to {\tt HYPRE\_SMG} or {\tt HYPRE\_PFMG}.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {SStruct FAC Solver}
        {}
        {
}
        {5.9}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_SStructFACCreate}
        {(\ MPI\_Comm\ comm,\ HYPRE\_SStructSolver\ *solver\ )}
        {
Create a solver object}
        {}
\label{cxx.5.9.11}
\cxxitem{int\ }
        {HYPRE\_SStructFACDestroy2}
        {(\ HYPRE\_SStructSolver\ solver\ )}
        {
Destroy a solver object}
        {5.9.1}
\cxxitem{int\ }
        {HYPRE\_SStructFACAMR\_RAP}
        {(\ HYPRE\_SStructMatrix\ A,\ int\ (*rfactors)[3],\ HYPRE\_SStructMatrix\ *fac\_A\ )}
        {
Re-distribute the composite matrix so that the amr hierachy is approximately
nested}
        {5.9.2}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetup2}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Set up the FAC solver structure }
        {}
\label{cxx.5.9.12}
\cxxitem{int\ }
        {HYPRE\_SStructFACSolve3}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Solve the system}
        {}
\label{cxx.5.9.13}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetPLevels}
        {(HYPRE\_SStructSolver\ solver,\ int\ nparts,\ int\ *plevels)}
        {
Set up amr structure}
        {}
\label{cxx.5.9.14}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetPRefinements}
        {(HYPRE\_SStructSolver\ solver,\ int\ nparts,\ int\ (*rfactors)[3]\ )}
        {
Set up amr refinement factors}
        {}
\label{cxx.5.9.15}
\cxxitem{int\ }
        {HYPRE\_SStructFACZeroCFSten}
        {(HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructGrid\ grid,\ int\ part,\ int\ rfactors[3])}
        {
(Optional, but user must make sure that they do this function otherwise}
        {5.9.3}
\cxxitem{int\ }
        {HYPRE\_SStructFACZeroFCSten}
        {(HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructGrid\ grid,\ int\ part)}
        {
(Optional, but user must make sure that they do this function otherwise}
        {5.9.4}
\cxxitem{int\ }
        {HYPRE\_SStructFACZeroAMRMatrixData}
        {(HYPRE\_SStructMatrix\ A,\ int\ part\_crse,\ int\ rfactors[3])}
        {
(Optional, but user must make sure that they do this function otherwise}
        {5.9.5}
\cxxitem{int\ }
        {HYPRE\_SStructFACZeroAMRVectorData}
        {(HYPRE\_SStructVector\ b,\ int\ *plevels,\ int\ (*rfactors)[3]\ )}
        {
(Optional, but user must make sure that they do this function otherwise}
        {5.9.6}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetMaxLevels}
        {(\ HYPRE\_SStructSolver\ solver,\ int\ max\_levels\ )}
        {
(Optional) Set maximum number of FAC levels}
        {}
\label{cxx.5.9.16}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.5.9.17}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetMaxIter}
        {(HYPRE\_SStructSolver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.5.9.18}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetRelChange}
        {(HYPRE\_SStructSolver\ solver,\ int\ rel\_change)}
        {
(Optional) Additionally require that the relative difference in
successive iterates be small}
        {}
\label{cxx.5.9.19}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetZeroGuess}
        {(HYPRE\_SStructSolver\ solver)}
        {
(Optional) Use a zero initial guess}
        {5.9.7}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetNonZeroGuess}
        {(HYPRE\_SStructSolver\ solver)}
        {
(Optional) Use a nonzero initial guess}
        {5.9.8}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetRelaxType}
        {(HYPRE\_SStructSolver\ solver,\ int\ relax\_type)}
        {
(Optional) Set relaxation type}
        {5.9.9}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetJacobiWeight}
        {(HYPRE\_SStructSolver\ solver,\ double\ weight)}
        {
(Optional) Set Jacobi weight if weighted Jacobi is used}
        {}
\label{cxx.5.9.20}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetNumPreRelax}
        {(HYPRE\_SStructSolver\ solver,\ int\ num\_pre\_relax)}
        {
(Optional) Set number of relaxation sweeps before coarse-grid correction}
        {}
\label{cxx.5.9.21}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetNumPostRelax}
        {(HYPRE\_SStructSolver\ solver,\ int\ num\_post\_relax)}
        {
(Optional) Set number of relaxation sweeps after coarse-grid correction}
        {}
\label{cxx.5.9.22}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetCoarseSolverType}
        {(HYPRE\_SStructSolver\ solver,\ int\ csolver\_type)}
        {
(Optional) Set coarsest solver type}
        {5.9.10}
\cxxitem{int\ }
        {HYPRE\_SStructFACSetLogging}
        {(HYPRE\_SStructSolver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.5.9.23}
\cxxitem{int\ }
        {HYPRE\_SStructFACGetNumIterations}
        {(HYPRE\_SStructSolver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.5.9.24}
\cxxitem{int\ }
        {HYPRE\_SStructFACGetFinalRelativeResidualNorm}
        {(HYPRE\_SStructSolver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.5.9.25}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructFACDestroy2}
        {(\ HYPRE\_SStructSolver\ solver\ )}
        {
Destroy a solver object}
        {5.9.1}
\begin{cxxdoc}

Destroy a solver object.  An object should be explicitly destroyed
using this destructor when the user's code no longer needs direct
access to it.  Once destroyed, the object must not be referenced
again.  Note that the object may not be deallocated at the
completion of this call, since there may be internal package
references to the object.  The object will then be destroyed when
all internal reference counts go to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructFACAMR\_RAP}
        {(\ HYPRE\_SStructMatrix\ A,\ int\ (*rfactors)[3],\ HYPRE\_SStructMatrix\ *fac\_A\ )}
        {
Re-distribute the composite matrix so that the amr hierachy is approximately
nested}
        {5.9.2}
\begin{cxxdoc}

Re-distribute the composite matrix so that the amr hierachy is approximately
nested. Coarse underlying operators are also formed.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructFACZeroCFSten}
        {(HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructGrid\ grid,\ int\ part,\ int\ rfactors[3])}
        {
(Optional, but user must make sure that they do this function otherwise}
        {5.9.3}
\begin{cxxdoc}

(Optional, but user must make sure that they do this function otherwise.)
Zero off the coarse level stencils reaching into a fine level grid.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructFACZeroFCSten}
        {(HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructGrid\ grid,\ int\ part)}
        {
(Optional, but user must make sure that they do this function otherwise}
        {5.9.4}
\begin{cxxdoc}

(Optional, but user must make sure that they do this function otherwise.)
Zero off the fine level stencils reaching into a coarse level grid.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructFACZeroAMRMatrixData}
        {(HYPRE\_SStructMatrix\ A,\ int\ part\_crse,\ int\ rfactors[3])}
        {
(Optional, but user must make sure that they do this function otherwise}
        {5.9.5}
\begin{cxxdoc}

(Optional, but user must make sure that they do this function otherwise.)
Places the identity in the coarse grid matrix underlying the fine patches.
Required between each pair of amr levels.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructFACZeroAMRVectorData}
        {(HYPRE\_SStructVector\ b,\ int\ *plevels,\ int\ (*rfactors)[3]\ )}
        {
(Optional, but user must make sure that they do this function otherwise}
        {5.9.6}
\begin{cxxdoc}

(Optional, but user must make sure that they do this function otherwise.)
Places zeros in the coarse grid vector underlying the fine patches.
Required between each pair of amr levels.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructFACSetZeroGuess}
        {(HYPRE\_SStructSolver\ solver)}
        {
(Optional) Use a zero initial guess}
        {5.9.7}
\begin{cxxdoc}

(Optional) Use a zero initial guess.  This allows the solver to cut corners
in the case where a zero initial guess is needed (e.g., for preconditioning)
to reduce compuational cost.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructFACSetNonZeroGuess}
        {(HYPRE\_SStructSolver\ solver)}
        {
(Optional) Use a nonzero initial guess}
        {5.9.8}
\begin{cxxdoc}

(Optional) Use a nonzero initial guess.  This is the default behavior, but
this routine allows the user to switch back after using {\tt SetZeroGuess}.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructFACSetRelaxType}
        {(HYPRE\_SStructSolver\ solver,\ int\ relax\_type)}
        {
(Optional) Set relaxation type}
        {5.9.9}
\begin{cxxdoc}

(Optional) Set relaxation type.  See HYPRE\_SStructSysPFMGSetRelaxType ($\rightarrow$5.7.5, {\em page \pageref{cxx.5.7.5}})
for appropriate values of {\tt relax\_type}.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructFACSetCoarseSolverType}
        {(HYPRE\_SStructSolver\ solver,\ int\ csolver\_type)}
        {
(Optional) Set coarsest solver type}
        {5.9.10}
\begin{cxxdoc}

(Optional) Set coarsest solver type.

Current solver types set by {\tt csolver\_type} are:

\begin{tabular}{l@{ -- }l}
1 & SysPFMG-PCG (default) \\
2 & SysPFMG \\
\end{tabular}
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {SStruct Maxwell Solver}
        {}
        {
}
        {5.10}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellCreate}
        {(\ MPI\_Comm\ comm,\ HYPRE\_SStructSolver\ *solver\ )}
        {
Create a solver object}
        {}
\label{cxx.5.10.6}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellDestroy}
        {(\ HYPRE\_SStructSolver\ solver\ )}
        {
Destroy a solver object}
        {5.10.1}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.10.2}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellSolve}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Solve the system}
        {5.10.3}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellSolve2}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Solve the system}
        {5.10.4}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellSetGrad}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_ParCSRMatrix\ T)}
        {
Sets the gradient operator in the Maxwell solver}
        {}
\label{cxx.5.10.7}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellSetRfactors}
        {(HYPRE\_SStructSolver\ solver,\ int\ rfactors[3])}
        {
Sets the coarsening factor}
        {}
\label{cxx.5.10.8}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellPhysBdy}
        {(HYPRE\_SStructGrid\ *grid\_l,\ int\ num\_levels,\ int\ rfactors[3],\ int\ ***BdryRanks\_ptr,\ int\ **BdryRanksCnt\_ptr\ )}
        {
Finds the physical boundary row ranks on all levels}
        {}
\label{cxx.5.10.9}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellEliminateRowsCols}
        {(HYPRE\_ParCSRMatrix\ parA,\ int\ nrows,\ int\ *rows\ )}
        {
Eliminates the rows and cols corresponding to the physical boundary in
a parcsr matrix}
        {}
\label{cxx.5.10.10}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellZeroVector}
        {(HYPRE\_ParVector\ b,\ int\ *rows,\ int\ nrows\ )}
        {
Zeros the rows corresponding to the physical boundary in
a par vector}
        {}
\label{cxx.5.10.11}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellSetSetConstantCoef}
        {(HYPRE\_SStructSolver\ solver,\ int\ flag)}
        {
(Optional) Set the constant coefficient flag- Nedelec interpolation
used}
        {}
\label{cxx.5.10.12}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellGrad}
        {(HYPRE\_SStructGrid\ grid,\ HYPRE\_ParCSRMatrix\ *T)}
        {
(Optional) Creates a gradient matrix from the grid}
        {5.10.5}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellSetTol}
        {(HYPRE\_SStructSolver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.5.10.13}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellSetMaxIter}
        {(HYPRE\_SStructSolver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.5.10.14}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellSetRelChange}
        {(HYPRE\_SStructSolver\ solver,\ int\ rel\_change)}
        {
(Optional) Additionally require that the relative difference in
successive iterates be small}
        {}
\label{cxx.5.10.15}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellSetNumPreRelax}
        {(HYPRE\_SStructSolver\ solver,\ int\ num\_pre\_relax)}
        {
(Optional) Set number of relaxation sweeps before coarse-grid correction}
        {}
\label{cxx.5.10.16}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellSetNumPostRelax}
        {(HYPRE\_SStructSolver\ solver,\ int\ num\_post\_relax)}
        {
(Optional) Set number of relaxation sweeps after coarse-grid correction}
        {}
\label{cxx.5.10.17}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellSetLogging}
        {(HYPRE\_SStructSolver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.5.10.18}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellGetNumIterations}
        {(HYPRE\_SStructSolver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.5.10.19}
\cxxitem{int\ }
        {HYPRE\_SStructMaxwellGetFinalRelativeResidualNorm}
        {(HYPRE\_SStructSolver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.5.10.20}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMaxwellDestroy}
        {(\ HYPRE\_SStructSolver\ solver\ )}
        {
Destroy a solver object}
        {5.10.1}
\begin{cxxdoc}

Destroy a solver object.  An object should be explicitly destroyed
using this destructor when the user's code no longer needs direct
access to it.  Once destroyed, the object must not be referenced
again.  Note that the object may not be deallocated at the
completion of this call, since there may be internal package
references to the object.  The object will then be destroyed when
all internal reference counts go to zero.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMaxwellSetup}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Prepare to solve the system}
        {5.10.2}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMaxwellSolve}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Solve the system}
        {5.10.3}
\begin{cxxdoc}

Solve the system. Full coupling of the augmented system used
throughout the multigrid hierarchy.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMaxwellSolve2}
        {(HYPRE\_SStructSolver\ solver,\ HYPRE\_SStructMatrix\ A,\ HYPRE\_SStructVector\ b,\ HYPRE\_SStructVector\ x)}
        {
Solve the system}
        {5.10.4}
\begin{cxxdoc}

Solve the system. Full coupling of the augmented system used
only on the finest level, i.e., the node and edge multigrid
cycles are coupled only on the finest level.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_SStructMaxwellGrad}
        {(HYPRE\_SStructGrid\ grid,\ HYPRE\_ParCSRMatrix\ *T)}
        {
(Optional) Creates a gradient matrix from the grid}
        {5.10.5}
\begin{cxxdoc}

(Optional) Creates a gradient matrix from the grid. This presupposes
a particular orientation of the edge elements.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{extern }
        {ParCSR Solvers}
        {}
        {Linear solvers for sparse matrix systems}
        {6}
\begin{cxxnames}
\cxxitem{}
        {ParCSR Solvers}
        {}
        {
}
        {6.1}
\cxxitem{}
        {ParCSR BoomerAMG Solver and Preconditioner}
        {}
        {
}
        {6.2}
\cxxitem{}
        {ParCSR ParaSails Preconditioner}
        {}
        {
}
        {6.3}
\cxxitem{}
        {ParCSR Euclid Preconditioner }
        {}
        {
}
        {6.4}
\cxxitem{}
        {ParCSR Pilut Preconditioner}
        {}
        {
}
        {6.5}
\cxxitem{}
        {ParCSR AMS Solver and Preconditioner}
        {}
        {
}
        {6.6}
\cxxitem{}
        {ParCSR Hybrid Solver}
        {}
        {
}
        {6.7}
\cxxitem{}
        {ParCSR PCG Solver}
        {}
        {
}
        {6.8}
\cxxitem{}
        {ParCSR GMRES Solver}
        {}
        {
}
        {6.9}
\cxxitem{}
        {ParCSR FlexGMRES Solver}
        {}
        {
}
        {6.10}
\cxxitem{}
        {ParCSR LGMRES Solver}
        {}
        {
}
        {6.11}
\cxxitem{}
        {ParCSR BiCGSTAB Solver}
        {}
        {
}
        {6.12}
\end{cxxnames}
\begin{cxxdoc}


These solvers use matrix/vector storage schemes that are taylored
for general sparse matrix systems.


\end{cxxdoc}
\begin{cxxentry}
{}
        {ParCSR Solvers}
        {}
        {
}
        {6.1}
\begin{cxxnames}
\cxxitem{\#define}
        {HYPRE\_SOLVER\_STRUCT}
        {}
        {
The solver object}
        {}
\label{cxx.6.1.1}
\end{cxxnames}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR BoomerAMG Solver and Preconditioner}
        {}
        {
}
        {6.2}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGCreate}
        {(HYPRE\_Solver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.6.2.55}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGDestroy}
        {(HYPRE\_Solver\ solver)}
        {
Destroy a solver object}
        {}
\label{cxx.6.2.56}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Set up the BoomerAMG solver or preconditioner}
        {6.2.1}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Solve the system or apply AMG as a preconditioner}
        {6.2.2}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSolveT}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Solve the transpose system $A^T x = b$ or apply AMG as a preconditioner
to the transpose system }
        {6.2.3}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance, if BoomerAMG is used
as a solver}
        {6.2.4}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ max\_iter)}
        {
(Optional) Sets maximum number of iterations, if BoomerAMG is used
as a solver}
        {6.2.5}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetMaxLevels}
        {(HYPRE\_Solver\ solver,\ int\ max\_levels)}
        {
(Optional) Sets maximum number of multigrid levels}
        {6.2.6}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetStrongThreshold}
        {(HYPRE\_Solver\ solver,\ double\ strong\_threshold)}
        {
(Optional) Sets AMG strength threshold}
        {6.2.7}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetMaxRowSum}
        {(HYPRE\_Solver\ solver,\ double\ max\_row\_sum)}
        {
(Optional) Sets a parameter to modify the definition of strength for
diagonal dominant portions of the matrix}
        {6.2.8}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetCoarsenType}
        {(HYPRE\_Solver\ solver,\ int\ coarsen\_type)}
        {
(Optional) Defines which parallel coarsening algorithm is used}
        {6.2.9}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetMeasureType}
        {(HYPRE\_Solver\ solver,\ int\ measure\_type)}
        {
(Optional) Defines whether local or global measures are used}
        {}
\label{cxx.6.2.57}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetCycleType}
        {(HYPRE\_Solver\ solver,\ int\ cycle\_type)}
        {
(Optional) Defines the type of cycle}
        {6.2.10}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetNumGridSweeps}
        {(HYPRE\_Solver\ solver,\ int\ *num\_grid\_sweeps)}
        {
(Optional) Defines the number of sweeps for the fine and coarse grid, 
the up and down cycle}
        {6.2.11}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetNumSweeps}
        {(HYPRE\_Solver\ solver,\ int\ num\_sweeps)}
        {
(Optional) Sets the number of sweeps}
        {6.2.12}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetCycleNumSweeps}
        {(HYPRE\_Solver\ solver,\ int\ num\_sweeps,\ int\ k)}
        {
(Optional) Sets the number of sweeps at a specified cycle}
        {6.2.13}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetGridRelaxType}
        {(HYPRE\_Solver\ solver,\ int\ *grid\_relax\_type)}
        {
(Optional) Defines which smoother is used on the fine and coarse grid, 
the up and down cycle}
        {6.2.14}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetRelaxType}
        {(HYPRE\_Solver\ solver,\ int\ relax\_type)}
        {
(Optional) Defines the smoother to be used}
        {6.2.15}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetCycleRelaxType}
        {(HYPRE\_Solver\ solver,\ int\ relax\_type,\ int\ k)}
        {
(Optional) Defines the smoother at a given cycle}
        {6.2.16}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetRelaxOrder}
        {(HYPRE\_Solver\ solver,\ int\ relax\_order)}
        {
(Optional) Defines in which order the points are relaxed}
        {6.2.17}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetGridRelaxPoints}
        {(HYPRE\_Solver\ solver,\ int\ **grid\_relax\_points)}
        {
(Optional) Defines in which order the points are relaxed}
        {6.2.18}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetRelaxWeight}
        {(HYPRE\_Solver\ solver,\ double\ *relax\_weight)}
        {
(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR}
        {6.2.19}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetRelaxWt}
        {(HYPRE\_Solver\ solver,\ double\ relax\_weight)}
        {
(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR 
on all levels}
        {6.2.20}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetLevelRelaxWt}
        {(HYPRE\_Solver\ solver,\ double\ relax\_weight,\ int\ level)}
        {
(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR
on the user defined level}
        {6.2.21}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetOmega}
        {(HYPRE\_Solver\ solver,\ double\ *omega)}
        {
(Optional) Defines the outer relaxation weight for hybrid SOR}
        {6.2.22}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetOuterWt}
        {(HYPRE\_Solver\ solver,\ double\ omega)}
        {
(Optional) Defines the outer relaxation weight for hybrid SOR and SSOR
on all levels}
        {6.2.23}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetLevelOuterWt}
        {(HYPRE\_Solver\ solver,\ double\ omega,\ int\ level)}
        {
(Optional) Defines the outer relaxation weight for hybrid SOR or SSOR
on the user defined level}
        {6.2.24}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetDebugFlag}
        {(HYPRE\_Solver\ solver,\ int\ debug\_flag)}
        {
(Optional)}
        {}
\label{cxx.6.2.58}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGGetResidual}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParVector\ *\ residual)}
        {
Returns the residual}
        {}
\label{cxx.6.2.59}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGGetNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *num\_iterations)}
        {
Returns the number of iterations taken}
        {}
\label{cxx.6.2.60}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGGetFinalRelativeResidualNorm}
        {(HYPRE\_Solver\ solver,\ double\ *rel\_resid\_norm)}
        {
Returns the norm of the final relative residual}
        {}
\label{cxx.6.2.61}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetTruncFactor}
        {(HYPRE\_Solver\ solver,\ double\ trunc\_factor)}
        {
(Optional) Defines a truncation factor for the interpolation}
        {6.2.25}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetPMaxElmts}
        {(HYPRE\_Solver\ solver,\ int\ P\_max\_elmts)}
        {
(Optional) Defines the maximal number of elements per row for the interpolation}
        {6.2.26}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetSCommPkgSwitch}
        {(HYPRE\_Solver\ solver,\ double\ S\_commpkg\_switch)}
        {
(Optional) Defines the largest strength threshold for which 
the strength matrix S uses the communication package of the operator A}
        {6.2.27}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetInterpType}
        {(HYPRE\_Solver\ solver,\ int\ interp\_type)}
        {
(Optional) Defines which parallel interpolation operator is used}
        {6.2.28}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetMinIter}
        {(HYPRE\_Solver\ solver,\ int\ min\_iter)}
        {
(Optional)}
        {}
\label{cxx.6.2.62}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGInitGridRelaxation}
        {(int\ **num\_grid\_sweeps\_ptr,\ int\ **grid\_relax\_type\_ptr,\ int\ ***grid\_relax\_points\_ptr,\ int\ coarsen\_type,\ double\ **relax\_weights\_ptr,\ int\ max\_levels)}
        {
(Optional) This routine will be eliminated in the future}
        {}
\label{cxx.6.2.63}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetSmoothType}
        {(HYPRE\_Solver\ solver,\ int\ smooth\_type)}
        {
(Optional) Enables the use of more complex smoothers}
        {6.2.29}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetSmoothNumLevels}
        {(HYPRE\_Solver\ solver,\ int\ smooth\_num\_levels)}
        {
(Optional) Sets the number of levels for more complex smoothers}
        {6.2.30}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetSmoothNumSweeps}
        {(HYPRE\_Solver\ solver,\ int\ smooth\_num\_sweeps)}
        {
(Optional) Sets the number of sweeps for more complex smoothers}
        {6.2.31}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ print\_level)}
        {
(Optional) Requests automatic printing of setup and solve information}
        {6.2.32}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
(Optional) Requests additional computations for diagnostic and similar
data to be logged by the user}
        {6.2.33}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetNumFunctions}
        {(HYPRE\_Solver\ solver,\ int\ num\_functions)}
        {
(Optional) Sets the size of the system of PDEs, if using the systems version}
        {6.2.34}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetNodal}
        {(HYPRE\_Solver\ solver,\ int\ nodal)}
        {
(Optional) Sets whether to use the nodal systems version}
        {6.2.35}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetNodalDiag}
        {(HYPRE\_Solver\ solver,\ int\ nodal\_diag)}
        {
(Optional) Sets whether to give spoecial treatment to diagonal elements in 
the nodal systems version}
        {6.2.36}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetDofFunc}
        {(HYPRE\_Solver\ solver,\ int\ *dof\_func)}
        {
(Optional) Sets the mapping that assigns the function to each variable, 
if using the systems version}
        {6.2.37}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetAggNumLevels}
        {(HYPRE\_Solver\ solver,\ int\ agg\_num\_levels)}
        {
(Optional) Defines the number of levels of aggressive coarsening}
        {6.2.38}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetNumPaths}
        {(HYPRE\_Solver\ solver,\ int\ num\_paths)}
        {
(Optional) Defines the degree of aggressive coarsening}
        {6.2.39}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetVariant}
        {(HYPRE\_Solver\ solver,\ int\ variant)}
        {
(Optional) Defines which variant of the Schwarz method is used}
        {6.2.40}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetOverlap}
        {(HYPRE\_Solver\ solver,\ int\ overlap)}
        {
(Optional) Defines the overlap for the Schwarz method}
        {6.2.41}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetDomainType}
        {(HYPRE\_Solver\ solver,\ int\ domain\_type)}
        {
(Optional) Defines the type of domain used for the Schwarz method}
        {6.2.42}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetSchwarzRlxWeight}
        {(HYPRE\_Solver\ solver,\ double\ schwarz\_rlx\_weight)}
        {
(Optional) Defines a smoothing parameter for the additive Schwarz method}
        {}
\label{cxx.6.2.64}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetSchwarzUseNonSymm}
        {(\ HYPRE\_Solver\ solver,\ int\ use\_nonsymm)}
        {
(Optional) Indicates that the aggregates may not be SPD for the Schwarz method}
        {6.2.43}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetSym}
        {(HYPRE\_Solver\ solver,\ int\ sym)}
        {
(Optional) Defines symmetry for ParaSAILS}
        {6.2.44}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetLevel}
        {(HYPRE\_Solver\ solver,\ int\ level)}
        {
(Optional) Defines number of levels for ParaSAILS}
        {6.2.45}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetThreshold}
        {(HYPRE\_Solver\ solver,\ double\ threshold)}
        {
(Optional) Defines threshold for ParaSAILS}
        {6.2.46}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetFilter}
        {(HYPRE\_Solver\ solver,\ double\ filter)}
        {
(Optional) Defines filter for ParaSAILS}
        {6.2.47}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetDropTol}
        {(HYPRE\_Solver\ solver,\ double\ drop\_tol)}
        {
(Optional) Defines drop tolerance for PILUT}
        {6.2.48}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetMaxNzPerRow}
        {(HYPRE\_Solver\ solver,\ int\ max\_nz\_per\_row)}
        {
(Optional) Defines maximal number of nonzeros for PILUT}
        {6.2.49}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetEuclidFile}
        {(HYPRE\_Solver\ solver,\ char\ *euclidfile)}
        {
(Optional) Defines name of an input file for Euclid parameters}
        {6.2.50}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetEuLevel}
        {(HYPRE\_Solver\ solver,\ int\ eu\_level)}
        {
(Optional) Defines number of levels for ILU(k) in Euclid}
        {6.2.51}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetEuSparseA}
        {(HYPRE\_Solver\ solver,\ double\ eu\_sparse\_A)}
        {
(Optional) Defines filter for ILU(k) for Euclid}
        {6.2.52}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetEuBJ}
        {(HYPRE\_Solver\ solver,\ int\ eu\_bj)}
        {
(Optional) Defines use of block jacobi ILUT for Euclid}
        {6.2.53}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetGSMG}
        {(HYPRE\_Solver\ solver,\ int\ gsmg)}
        {
(Optional) Specifies the use of GSMG - geometrically smooth 
coarsening and interpolation}
        {6.2.54}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetNumSamples}
        {(HYPRE\_Solver\ solver,\ int\ num\_samples)}
        {
(Optional) Defines the number of sample vectors used in GSMG
or LS interpolation}
        {}
\label{cxx.6.2.65}
\cxxitem{int\ }
        {HYPRE\_BoomerAMGSetCGCIts}
        {(HYPRE\_Solver\ solver,\ int\ its)}
        {
(optional) Defines the number of pathes for CGC-coarsening}
        {}
\label{cxx.6.2.66}
\end{cxxnames}
\begin{cxxdoc}


Parallel unstructured algebraic multigrid solver and preconditioner
\end{cxxdoc}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Set up the BoomerAMG solver or preconditioner}
        {6.2.1}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] object to be set up.
\\
{\tt\strut A}\strut{} --- [IN] ParCSR matrix used to construct the solver/preconditioner.
\\
{\tt\strut b}\strut{} --- Ignored by this function.
\\
{\tt\strut x}\strut{} --- Ignored by this function.\strut}
\begin{cxxdoc}

Set up the BoomerAMG solver or preconditioner.  
If used as a preconditioner, this function should be passed
to the iterative solver {\tt SetPrecond} function.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Solve the system or apply AMG as a preconditioner}
        {6.2.2}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] solver or preconditioner object to be applied.
\\
{\tt\strut A}\strut{} --- [IN] ParCSR matrix, matrix of the linear system to be solved
\\
{\tt\strut b}\strut{} --- [IN] right hand side of the linear system to be solved
\\
{\tt\strut x}\strut{} --- [OUT] approximated solution of the linear system to be solved\strut}
\begin{cxxdoc}

Solve the system or apply AMG as a preconditioner.
If used as a preconditioner, this function should be passed
to the iterative solver {\tt SetPrecond} function.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSolveT}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Solve the transpose system $A^T x = b$ or apply AMG as a preconditioner
to the transpose system }
        {6.2.3}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] solver or preconditioner object to be applied.
\\
{\tt\strut A}\strut{} --- [IN] ParCSR matrix 
\\
{\tt\strut b}\strut{} --- [IN] right hand side of the linear system to be solved
\\
{\tt\strut x}\strut{} --- [OUT] approximated solution of the linear system to be solved\strut}
\begin{cxxdoc}

Solve the transpose system $A^T x = b$ or apply AMG as a preconditioner
to the transpose system .
If used as a preconditioner, this function should be passed
to the iterative solver {\tt SetPrecond} function.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance, if BoomerAMG is used
as a solver}
        {6.2.4}
\begin{cxxdoc}

(Optional) Set the convergence tolerance, if BoomerAMG is used
as a solver. If it is used as a preconditioner, this function has
no effect. The default is 1.e-7.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ max\_iter)}
        {
(Optional) Sets maximum number of iterations, if BoomerAMG is used
as a solver}
        {6.2.5}
\begin{cxxdoc}

(Optional) Sets maximum number of iterations, if BoomerAMG is used
as a solver. If it is used as a preconditioner, this function has
no effect. The default is 20.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetMaxLevels}
        {(HYPRE\_Solver\ solver,\ int\ max\_levels)}
        {
(Optional) Sets maximum number of multigrid levels}
        {6.2.6}
\begin{cxxdoc}

(Optional) Sets maximum number of multigrid levels.
The default is 25.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetStrongThreshold}
        {(HYPRE\_Solver\ solver,\ double\ strong\_threshold)}
        {
(Optional) Sets AMG strength threshold}
        {6.2.7}
\begin{cxxdoc}

(Optional) Sets AMG strength threshold. The default is 0.25.
For 2d Laplace operators, 0.25 is a good value, for 3d Laplace
operators, 0.5 or 0.6 is a better value. For elasticity problems,
a large strength threshold, such as 0.9, is often better.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetMaxRowSum}
        {(HYPRE\_Solver\ solver,\ double\ max\_row\_sum)}
        {
(Optional) Sets a parameter to modify the definition of strength for
diagonal dominant portions of the matrix}
        {6.2.8}
\begin{cxxdoc}

(Optional) Sets a parameter to modify the definition of strength for
diagonal dominant portions of the matrix. The default is 0.9.
If max\_row\_sum is 1, no checking for diagonally dominant rows is
performed.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetCoarsenType}
        {(HYPRE\_Solver\ solver,\ int\ coarsen\_type)}
        {
(Optional) Defines which parallel coarsening algorithm is used}
        {6.2.9}
\begin{cxxdoc}

(Optional) Defines which parallel coarsening algorithm is used.
There are the following options for coarsen\_type: 

\begin{tabular}{|c|l|} \hline
0 &	CLJP-coarsening (a parallel coarsening algorithm using independent sets. \\
1 &	classical Ruge-Stueben coarsening on each processor, no boundary treatment (not recommended!) \\
3 &	classical Ruge-Stueben coarsening on each processor, followed by a third pass, which adds coarse \\
& points on the boundaries \\
6 &   Falgout coarsening (uses 1 first, followed by CLJP using the interior coarse points \\
& generated by 1 as its first independent set) \\
7 &	CLJP-coarsening (using a fixed random vector, for debugging purposes only) \\
8 &	PMIS-coarsening (a parallel coarsening algorithm using independent sets, generating \\
& lower complexities than CLJP, might also lead to slower convergence) \\
9 &	PMIS-coarsening (using a fixed random vector, for debugging purposes only) \\
10 &	HMIS-coarsening (uses one pass Ruge-Stueben on each processor independently, followed \\
& by PMIS using the interior C-points generated as its first independent set) \\
11 &	one-pass Ruge-Stueben coarsening on each processor, no boundary treatment (not recommended!) \\
21 &	CGC coarsening by M. Griebel, B. Metsch and A. Schweitzer \\
22 &	CGC-E coarsening by M. Griebel, B. Metsch and A.Schweitzer \\
\hline
\end{tabular}

The default is 6. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetCycleType}
        {(HYPRE\_Solver\ solver,\ int\ cycle\_type)}
        {
(Optional) Defines the type of cycle}
        {6.2.10}
\begin{cxxdoc}

(Optional) Defines the type of cycle.
For a V-cycle, set cycle\_type to 1, for a W-cycle
set cycle\_type to 2. The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetNumGridSweeps}
        {(HYPRE\_Solver\ solver,\ int\ *num\_grid\_sweeps)}
        {
(Optional) Defines the number of sweeps for the fine and coarse grid, 
the up and down cycle}
        {6.2.11}
\begin{cxxdoc}

(Optional) Defines the number of sweeps for the fine and coarse grid, 
the up and down cycle.

Note: This routine will be phased out!!!!
Use HYPRE\_BoomerAMGSetNumSweeps or HYPRE\_BoomerAMGSetCycleNumSweeps instead.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetNumSweeps}
        {(HYPRE\_Solver\ solver,\ int\ num\_sweeps)}
        {
(Optional) Sets the number of sweeps}
        {6.2.12}
\begin{cxxdoc}

(Optional) Sets the number of sweeps. On the finest level, the up and 
the down cycle the number of sweeps are set to num\_sweeps and on the 
coarsest level to 1. The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetCycleNumSweeps}
        {(HYPRE\_Solver\ solver,\ int\ num\_sweeps,\ int\ k)}
        {
(Optional) Sets the number of sweeps at a specified cycle}
        {6.2.13}
\begin{cxxdoc}

(Optional) Sets the number of sweeps at a specified cycle.
There are the following options for k:

\begin{tabular}{|l|l|} \hline
the finest level &	if k=0 \\
the down cycle &	if k=1 \\
the up cycle	&	if k=2 \\
the coarsest level &  if k=3.\\
\hline
\end{tabular}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetGridRelaxType}
        {(HYPRE\_Solver\ solver,\ int\ *grid\_relax\_type)}
        {
(Optional) Defines which smoother is used on the fine and coarse grid, 
the up and down cycle}
        {6.2.14}
\begin{cxxdoc}

(Optional) Defines which smoother is used on the fine and coarse grid, 
the up and down cycle.

Note: This routine will be phased out!!!!
Use HYPRE\_BoomerAMGSetRelaxType or HYPRE\_BoomerAMGSetCycleRelaxType instead.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetRelaxType}
        {(HYPRE\_Solver\ solver,\ int\ relax\_type)}
        {
(Optional) Defines the smoother to be used}
        {6.2.15}
\begin{cxxdoc}

(Optional) Defines the smoother to be used. It uses the given
smoother on the fine grid, the up and 
the down cycle and sets the solver on the coarsest level to Gaussian
elimination (9). The default is Gauss-Seidel (3).

There are the following options for relax\_type:

\begin{tabular}{|c|l|} \hline
0 &	Jacobi \\
1 &	Gauss-Seidel, sequential (very slow!) \\
2 &	Gauss-Seidel, interior points in parallel, boundary sequential (slow!) \\
3 &	hybrid Gauss-Seidel or SOR, forward solve \\
4 &	hybrid Gauss-Seidel or SOR, backward solve \\
5 &	hybrid chaotic Gauss-Seidel (works only with OpenMP) \\
6 &	hybrid symmetric Gauss-Seidel or SSOR \\
9 &	Gaussian elimination (only on coarsest level) \\
\hline
\end{tabular}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetCycleRelaxType}
        {(HYPRE\_Solver\ solver,\ int\ relax\_type,\ int\ k)}
        {
(Optional) Defines the smoother at a given cycle}
        {6.2.16}
\begin{cxxdoc}

(Optional) Defines the smoother at a given cycle.
For options of relax\_type see
description of HYPRE\_BoomerAMGSetRelaxType). Options for k are

\begin{tabular}{|l|l|} \hline
the finest level &	if k=0 \\
the down cycle &	if k=1 \\
the up cycle	&	if k=2 \\
the coarsest level &  if k=3. \\
\hline
\end{tabular}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetRelaxOrder}
        {(HYPRE\_Solver\ solver,\ int\ relax\_order)}
        {
(Optional) Defines in which order the points are relaxed}
        {6.2.17}
\begin{cxxdoc}

(Optional) Defines in which order the points are relaxed. There are
the following options for
relax\_order: 

\begin{tabular}{|c|l|} \hline
0 & the points are relaxed in natural or lexicographic
order on each processor \\
1 &  CF-relaxation is used, i.e on the fine grid and the down
cycle the coarse points are relaxed first, \\
& followed by the fine points; on the up cycle the F-points are relaxed
first, followed by the C-points. \\
& On the coarsest level, if an iterative scheme is used, 
the points are relaxed in lexicographic order. \\
\hline
\end{tabular}

The default is 1 (CF-relaxation).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetGridRelaxPoints}
        {(HYPRE\_Solver\ solver,\ int\ **grid\_relax\_points)}
        {
(Optional) Defines in which order the points are relaxed}
        {6.2.18}
\begin{cxxdoc}

(Optional) Defines in which order the points are relaxed. 

Note: This routine will be phased out!!!!
Use HYPRE\_BoomerAMGSetRelaxOrder instead.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetRelaxWeight}
        {(HYPRE\_Solver\ solver,\ double\ *relax\_weight)}
        {
(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR}
        {6.2.19}
\begin{cxxdoc}

(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR.

Note: This routine will be phased out!!!!
Use HYPRE\_BoomerAMGSetRelaxWt or HYPRE\_BoomerAMGSetLevelRelaxWt instead.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetRelaxWt}
        {(HYPRE\_Solver\ solver,\ double\ relax\_weight)}
        {
(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR 
on all levels}
        {6.2.20}
\begin{cxxdoc}

(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR 
on all levels. 

\begin{tabular}{|l|l|} \hline
relax\_weight \> 0 & this assigns the given relaxation weight on all levels \\
relax\_weight = 0 &  the weight is determined on each level
with the estimate $3 \over {4\|D^{-1/2}AD^{-1/2}\|}$,\\
& where $D$ is the diagonal matrix of $A$ (this should only be used with Jacobi) \\
relax\_weight = -k & the relaxation weight is determined with at most k CG steps
on each level \\
& this should only be used for symmetric positive definite problems) \\
\hline
\end{tabular} 

The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetLevelRelaxWt}
        {(HYPRE\_Solver\ solver,\ double\ relax\_weight,\ int\ level)}
        {
(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR
on the user defined level}
        {6.2.21}
\begin{cxxdoc}

(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR
on the user defined level. Note that the finest level is denoted 0, the
next coarser level 1, etc. For nonpositive relax\_weight, the parameter is
determined on the given level as described for HYPRE\_BoomerAMGSetRelaxWt. 
The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetOmega}
        {(HYPRE\_Solver\ solver,\ double\ *omega)}
        {
(Optional) Defines the outer relaxation weight for hybrid SOR}
        {6.2.22}
\begin{cxxdoc}

(Optional) Defines the outer relaxation weight for hybrid SOR.
Note: This routine will be phased out!!!!
Use HYPRE\_BoomerAMGSetOuterWt or HYPRE\_BoomerAMGSetLevelOuterWt instead.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetOuterWt}
        {(HYPRE\_Solver\ solver,\ double\ omega)}
        {
(Optional) Defines the outer relaxation weight for hybrid SOR and SSOR
on all levels}
        {6.2.23}
\begin{cxxdoc}

(Optional) Defines the outer relaxation weight for hybrid SOR and SSOR
on all levels.

\begin{tabular}{|l|l|} \hline 
omega \> 0 & this assigns the same outer relaxation weight omega on each level\\
omega = -k & an outer relaxation weight is determined with at most k CG
steps on each level \\
& (this only makes sense for symmetric
positive definite problems and smoothers, e.g. SSOR) \\
\hline
\end{tabular} 

The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetLevelOuterWt}
        {(HYPRE\_Solver\ solver,\ double\ omega,\ int\ level)}
        {
(Optional) Defines the outer relaxation weight for hybrid SOR or SSOR
on the user defined level}
        {6.2.24}
\begin{cxxdoc}

(Optional) Defines the outer relaxation weight for hybrid SOR or SSOR
on the user defined level. Note that the finest level is denoted 0, the
next coarser level 1, etc. For nonpositive omega, the parameter is
determined on the given level as described for HYPRE\_BoomerAMGSetOuterWt. 
The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetTruncFactor}
        {(HYPRE\_Solver\ solver,\ double\ trunc\_factor)}
        {
(Optional) Defines a truncation factor for the interpolation}
        {6.2.25}
\begin{cxxdoc}

(Optional) Defines a truncation factor for the interpolation.
The default is 0.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetPMaxElmts}
        {(HYPRE\_Solver\ solver,\ int\ P\_max\_elmts)}
        {
(Optional) Defines the maximal number of elements per row for the interpolation}
        {6.2.26}
\begin{cxxdoc}

(Optional) Defines the maximal number of elements per row for the interpolation.
The default is 0.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetSCommPkgSwitch}
        {(HYPRE\_Solver\ solver,\ double\ S\_commpkg\_switch)}
        {
(Optional) Defines the largest strength threshold for which 
the strength matrix S uses the communication package of the operator A}
        {6.2.27}
\begin{cxxdoc}

(Optional) Defines the largest strength threshold for which 
the strength matrix S uses the communication package of the operator A.
If the strength threshold is larger than this values,
a communication package is generated for S. This can save
memory and decrease the amount of data that needs to be communicated,
if S is substantially sparser than A.
The default is 1.0.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetInterpType}
        {(HYPRE\_Solver\ solver,\ int\ interp\_type)}
        {
(Optional) Defines which parallel interpolation operator is used}
        {6.2.28}
\begin{cxxdoc}

(Optional) Defines which parallel interpolation operator is used.
There are the following options for interp\_type: 

\begin{tabular}{|c|l|} \hline
0 &	classical modified interpolation \\
1 &	LS interpolation (for use with GSMG) \\
2 &	classical modified interpolation for hyperbolic PDEs \\
3 &	direct interpolation (with separation of weights) \\
4 &	multipass interpolation \\
5 &	multipass interpolation (with separation of weights) \\
6 &  extended classical modified interpolation \\
7 &  extended (if no common C neighbor) classical modified interpolation \\
8 &	standard interpolation \\
9 &	standard interpolation (with separation of weights) \\
10 &	classical block interpolation (for use with nodal systems version only) \\
11 &	classical block interpolation (for use with nodal systems version only) \\
&	with diagonalized diagonal blocks \\
12 &	FF interpolation \\
13 &	FF1 interpolation \\
\hline
\end{tabular}

The default is 0. 
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetSmoothType}
        {(HYPRE\_Solver\ solver,\ int\ smooth\_type)}
        {
(Optional) Enables the use of more complex smoothers}
        {6.2.29}
\begin{cxxdoc}

(Optional) Enables the use of more complex smoothers.
The following options exist for smooth\_type:

\begin{tabular}{|c|l|l|} \hline
value & smoother & routines needed to set smoother parameters \\
6 &	Schwarz smoothers & HYPRE\_BoomerAMGSetDomainType, HYPRE\_BoomerAMGSetOverlap, \\
&  & HYPRE\_BoomerAMGSetVariant, HYPRE\_BoomerAMGSetSchwarzRlxWeight \\
7 &	Pilut & HYPRE\_BoomerAMGSetDropTol, HYPRE\_BoomerAMGSetMaxNzPerRow \\
8 &	ParaSails & HYPRE\_BoomerAMGSetSym, HYPRE\_BoomerAMGSetLevel, \\
&  &  HYPRE\_BoomerAMGSetFilter, HYPRE\_BoomerAMGSetThreshold \\
9 &	Euclid & HYPRE\_BoomerAMGSetEuclidFile \\
\hline
\end{tabular}

The default is 6. Also, if no smoother parameters are set via the routines mentioned in the table above,
default values are used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetSmoothNumLevels}
        {(HYPRE\_Solver\ solver,\ int\ smooth\_num\_levels)}
        {
(Optional) Sets the number of levels for more complex smoothers}
        {6.2.30}
\begin{cxxdoc}

(Optional) Sets the number of levels for more complex smoothers.
The smoothers, 
as defined by HYPRE\_BoomerAMGSetSmoothType, will be used
on level 0 (the finest level) through level smooth\_num\_levels-1. 
The default is 0, i.e. no complex smoothers are used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetSmoothNumSweeps}
        {(HYPRE\_Solver\ solver,\ int\ smooth\_num\_sweeps)}
        {
(Optional) Sets the number of sweeps for more complex smoothers}
        {6.2.31}
\begin{cxxdoc}

(Optional) Sets the number of sweeps for more complex smoothers.
The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ print\_level)}
        {
(Optional) Requests automatic printing of setup and solve information}
        {6.2.32}
\begin{cxxdoc}

(Optional) Requests automatic printing of setup and solve information.

\begin{tabular}{|c|l|} \hline
0 & no printout (default) \\
1 & print setup information \\
2 & print solve information \\
3 & print both setup and solve information \\
\hline
\end{tabular}

Note, that if one desires to print information and uses BoomerAMG as a 
preconditioner, suggested print$\_$level is 1 to avoid excessive output,
and use print$\_$level of solver for solve phase information.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
(Optional) Requests additional computations for diagnostic and similar
data to be logged by the user}
        {6.2.33}
\begin{cxxdoc}

(Optional) Requests additional computations for diagnostic and similar
data to be logged by the user. Default to 0 for do nothing.  The latest
residual will be available if logging \> 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetNumFunctions}
        {(HYPRE\_Solver\ solver,\ int\ num\_functions)}
        {
(Optional) Sets the size of the system of PDEs, if using the systems version}
        {6.2.34}
\begin{cxxdoc}

(Optional) Sets the size of the system of PDEs, if using the systems version.
The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetNodal}
        {(HYPRE\_Solver\ solver,\ int\ nodal)}
        {
(Optional) Sets whether to use the nodal systems version}
        {6.2.35}
\begin{cxxdoc}

(Optional) Sets whether to use the nodal systems version.
The default is 0.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetNodalDiag}
        {(HYPRE\_Solver\ solver,\ int\ nodal\_diag)}
        {
(Optional) Sets whether to give spoecial treatment to diagonal elements in 
the nodal systems version}
        {6.2.36}
\begin{cxxdoc}

(Optional) Sets whether to give spoecial treatment to diagonal elements in 
the nodal systems version.
The default is 0.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetDofFunc}
        {(HYPRE\_Solver\ solver,\ int\ *dof\_func)}
        {
(Optional) Sets the mapping that assigns the function to each variable, 
if using the systems version}
        {6.2.37}
\begin{cxxdoc}

(Optional) Sets the mapping that assigns the function to each variable, 
if using the systems version. If no assignment is made and the number of
functions is k \> 1, the mapping generated is (0,1,...,k-1,0,1,...,k-1,...).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetAggNumLevels}
        {(HYPRE\_Solver\ solver,\ int\ agg\_num\_levels)}
        {
(Optional) Defines the number of levels of aggressive coarsening}
        {6.2.38}
\begin{cxxdoc}

(Optional) Defines the number of levels of aggressive coarsening.
The default is 0, i.e. no aggressive coarsening.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetNumPaths}
        {(HYPRE\_Solver\ solver,\ int\ num\_paths)}
        {
(Optional) Defines the degree of aggressive coarsening}
        {6.2.39}
\begin{cxxdoc}

(Optional) Defines the degree of aggressive coarsening.
The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetVariant}
        {(HYPRE\_Solver\ solver,\ int\ variant)}
        {
(Optional) Defines which variant of the Schwarz method is used}
        {6.2.40}
\begin{cxxdoc}

(Optional) Defines which variant of the Schwarz method is used.
The following options exist for variant:

\begin{tabular}{|c|l|} \hline
0 & hybrid multiplicative Schwarz method (no overlap across processor 
boundaries) \\
1 & hybrid additive Schwarz method (no overlap across processor 
boundaries) \\
2 & additive Schwarz method \\
3 & hybrid multiplicative Schwarz method (with overlap across processor 
boundaries) \\
\hline
\end{tabular}

The default is 0.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetOverlap}
        {(HYPRE\_Solver\ solver,\ int\ overlap)}
        {
(Optional) Defines the overlap for the Schwarz method}
        {6.2.41}
\begin{cxxdoc}

(Optional) Defines the overlap for the Schwarz method.
The following options exist for overlap:

\begin{tabular}{|c|l|} \hline
0  & no overlap \\
1  & minimal overlap (default) \\
2  & overlap generated by including all neighbors of domain boundaries \\
\hline
\end{tabular}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetDomainType}
        {(HYPRE\_Solver\ solver,\ int\ domain\_type)}
        {
(Optional) Defines the type of domain used for the Schwarz method}
        {6.2.42}
\begin{cxxdoc}

(Optional) Defines the type of domain used for the Schwarz method.
The following options exist for domain\_type:

\begin{tabular}{|c|l|} \hline
0 &  each point is a domain \\
1 &  each node is a domain (only of interest in "systems" AMG) \\
2 &  each domain is generated by agglomeration (default) \\
\hline
\end{tabular}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetSchwarzUseNonSymm}
        {(\ HYPRE\_Solver\ solver,\ int\ use\_nonsymm)}
        {
(Optional) Indicates that the aggregates may not be SPD for the Schwarz method}
        {6.2.43}
\begin{cxxdoc}

(Optional) Indicates that the aggregates may not be SPD for the Schwarz method.
The following options exist for use\_nonsymm:

\begin{tabular}{|c|l|} \hline
0  & assume SPD (default) \\
1  & assume non-symmetric \\
\hline
\end{tabular}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetSym}
        {(HYPRE\_Solver\ solver,\ int\ sym)}
        {
(Optional) Defines symmetry for ParaSAILS}
        {6.2.44}
\begin{cxxdoc}

(Optional) Defines symmetry for ParaSAILS. 
For further explanation see description of ParaSAILS.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetLevel}
        {(HYPRE\_Solver\ solver,\ int\ level)}
        {
(Optional) Defines number of levels for ParaSAILS}
        {6.2.45}
\begin{cxxdoc}

(Optional) Defines number of levels for ParaSAILS.
For further explanation see description of ParaSAILS.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetThreshold}
        {(HYPRE\_Solver\ solver,\ double\ threshold)}
        {
(Optional) Defines threshold for ParaSAILS}
        {6.2.46}
\begin{cxxdoc}

(Optional) Defines threshold for ParaSAILS.
For further explanation see description of ParaSAILS.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetFilter}
        {(HYPRE\_Solver\ solver,\ double\ filter)}
        {
(Optional) Defines filter for ParaSAILS}
        {6.2.47}
\begin{cxxdoc}

(Optional) Defines filter for ParaSAILS.
For further explanation see description of ParaSAILS.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetDropTol}
        {(HYPRE\_Solver\ solver,\ double\ drop\_tol)}
        {
(Optional) Defines drop tolerance for PILUT}
        {6.2.48}
\begin{cxxdoc}

(Optional) Defines drop tolerance for PILUT.
For further explanation see description of PILUT.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetMaxNzPerRow}
        {(HYPRE\_Solver\ solver,\ int\ max\_nz\_per\_row)}
        {
(Optional) Defines maximal number of nonzeros for PILUT}
        {6.2.49}
\begin{cxxdoc}

(Optional) Defines maximal number of nonzeros for PILUT.
For further explanation see description of PILUT.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetEuclidFile}
        {(HYPRE\_Solver\ solver,\ char\ *euclidfile)}
        {
(Optional) Defines name of an input file for Euclid parameters}
        {6.2.50}
\begin{cxxdoc}

(Optional) Defines name of an input file for Euclid parameters.
For further explanation see description of Euclid.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetEuLevel}
        {(HYPRE\_Solver\ solver,\ int\ eu\_level)}
        {
(Optional) Defines number of levels for ILU(k) in Euclid}
        {6.2.51}
\begin{cxxdoc}

(Optional) Defines number of levels for ILU(k) in Euclid.
For further explanation see description of Euclid.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetEuSparseA}
        {(HYPRE\_Solver\ solver,\ double\ eu\_sparse\_A)}
        {
(Optional) Defines filter for ILU(k) for Euclid}
        {6.2.52}
\begin{cxxdoc}

(Optional) Defines filter for ILU(k) for Euclid.
For further explanation see description of Euclid.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetEuBJ}
        {(HYPRE\_Solver\ solver,\ int\ eu\_bj)}
        {
(Optional) Defines use of block jacobi ILUT for Euclid}
        {6.2.53}
\begin{cxxdoc}

(Optional) Defines use of block jacobi ILUT for Euclid.
For further explanation see description of Euclid.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BoomerAMGSetGSMG}
        {(HYPRE\_Solver\ solver,\ int\ gsmg)}
        {
(Optional) Specifies the use of GSMG - geometrically smooth 
coarsening and interpolation}
        {6.2.54}
\begin{cxxdoc}

(Optional) Specifies the use of GSMG - geometrically smooth 
coarsening and interpolation. Currently any nonzero value for
gsmg will lead to the use of GSMG.
The default is 0, i.e. (GSMG is not used)
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR ParaSails Preconditioner}
        {}
        {
}
        {6.3}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_ParaSailsCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_Solver\ *solver)}
        {
Create a ParaSails preconditioner}
        {}
\label{cxx.6.3.10}
\cxxitem{int\ }
        {HYPRE\_ParaSailsDestroy}
        {(HYPRE\_Solver\ solver)}
        {
Destroy a ParaSails preconditioner}
        {}
\label{cxx.6.3.11}
\cxxitem{int\ }
        {HYPRE\_ParaSailsSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Set up the ParaSails preconditioner}
        {6.3.1}
\cxxitem{int\ }
        {HYPRE\_ParaSailsSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Apply the ParaSails preconditioner}
        {6.3.2}
\cxxitem{int\ }
        {HYPRE\_ParaSailsSetParams}
        {(HYPRE\_Solver\ solver,\ double\ thresh,\ int\ nlevels)}
        {
Set the threshold and levels parameter for the ParaSails
preconditioner}
        {6.3.3}
\cxxitem{int\ }
        {HYPRE\_ParaSailsSetFilter}
        {(HYPRE\_Solver\ solver,\ double\ filter)}
        {
Set the filter parameter for the 
ParaSails preconditioner}
        {6.3.4}
\cxxitem{int\ }
        {HYPRE\_ParaSailsSetSym}
        {(HYPRE\_Solver\ solver,\ int\ sym)}
        {
Set the symmetry parameter for the
ParaSails preconditioner}
        {6.3.5}
\cxxitem{int\ }
        {HYPRE\_ParaSailsSetLoadbal}
        {(HYPRE\_Solver\ solver,\ double\ loadbal)}
        {
Set the load balance parameter for the
ParaSails preconditioner}
        {6.3.6}
\cxxitem{int\ }
        {HYPRE\_ParaSailsSetReuse}
        {(HYPRE\_Solver\ solver,\ int\ reuse)}
        {
Set the pattern reuse parameter for the
ParaSails preconditioner}
        {6.3.7}
\cxxitem{int\ }
        {HYPRE\_ParaSailsSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
Set the logging parameter for the
ParaSails preconditioner}
        {6.3.8}
\cxxitem{int\ }
        {HYPRE\_ParaSailsBuildIJMatrix}
        {(HYPRE\_Solver\ solver,\ HYPRE\_IJMatrix\ *pij\_A)}
        {
Build IJ Matrix of the sparse approximate inverse (factor)}
        {6.3.9}
\end{cxxnames}
\begin{cxxdoc}


Parallel sparse approximate inverse preconditioner for the
ParCSR matrix format.
\end{cxxdoc}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParaSailsSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Set up the ParaSails preconditioner}
        {6.3.1}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] Preconditioner object to set up.
\\
{\tt\strut A}\strut{} --- [IN] ParCSR matrix used to construct the preconditioner.
\\
{\tt\strut b}\strut{} --- Ignored by this function.
\\
{\tt\strut x}\strut{} --- Ignored by this function.\strut}
\begin{cxxdoc}

Set up the ParaSails preconditioner.  This function should be passed
to the iterative solver {\tt SetPrecond} function.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParaSailsSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Apply the ParaSails preconditioner}
        {6.3.2}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] Preconditioner object to apply.
\\
{\tt\strut A}\strut{} --- Ignored by this function.
\\
{\tt\strut b}\strut{} --- [IN] Vector to precondition.
\\
{\tt\strut x}\strut{} --- [OUT] Preconditioned vector.\strut}
\begin{cxxdoc}

Apply the ParaSails preconditioner.  This function should be passed
to the iterative solver {\tt SetPrecond} function.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParaSailsSetParams}
        {(HYPRE\_Solver\ solver,\ double\ thresh,\ int\ nlevels)}
        {
Set the threshold and levels parameter for the ParaSails
preconditioner}
        {6.3.3}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] Preconditioner object for which to set parameters.
\\
{\tt\strut thresh}\strut{} --- [IN] Value of threshold parameter, $0 \le$ thresh $\le 1$.
The default value is 0.1.
\\
{\tt\strut nlevels}\strut{} --- [IN] Value of levels parameter, $0 \le$ nlevels.  
The default value is 1.\strut}
\begin{cxxdoc}

Set the threshold and levels parameter for the ParaSails
preconditioner.  The accuracy and cost of ParaSails are
parameterized by these two parameters.  Lower values of the
threshold parameter and higher values of levels parameter 
lead to more accurate, but more expensive preconditioners.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParaSailsSetFilter}
        {(HYPRE\_Solver\ solver,\ double\ filter)}
        {
Set the filter parameter for the 
ParaSails preconditioner}
        {6.3.4}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] Preconditioner object for which to set filter parameter.
\\
{\tt\strut filter}\strut{} --- [IN] Value of filter parameter.  The filter parameter is
used to drop small nonzeros in the preconditioner,
to reduce the cost of applying the preconditioner.
Values from 0.05 to 0.1 are recommended.
The default value is 0.1.\strut}
\begin{cxxdoc}

Set the filter parameter for the 
ParaSails preconditioner.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParaSailsSetSym}
        {(HYPRE\_Solver\ solver,\ int\ sym)}
        {
Set the symmetry parameter for the
ParaSails preconditioner}
        {6.3.5}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] Preconditioner object for which to set symmetry parameter.
\\
{\tt\strut sym}\strut{} --- [IN] Value of the symmetry parameter:
\begin{tabular}{|c|l|} \hline 
value & meaning \\ \hline 
0 & nonsymmetric and/or indefinite problem, and nonsymmetric preconditioner\\
1 & SPD problem, and SPD (factored) preconditioner \\
2 & nonsymmetric, definite problem, and SPD (factored) preconditioner \\
\hline
\end{tabular}\strut}
\begin{cxxdoc}

Set the symmetry parameter for the
ParaSails preconditioner.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParaSailsSetLoadbal}
        {(HYPRE\_Solver\ solver,\ double\ loadbal)}
        {
Set the load balance parameter for the
ParaSails preconditioner}
        {6.3.6}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] Preconditioner object for which to set the load balance
parameter.
\\
{\tt\strut loadbal}\strut{} --- [IN] Value of the load balance parameter, 
$0 \le$ loadbal $\le 1$.  A zero value indicates that
no load balance is attempted; a value of unity indicates
that perfect load balance will be attempted.  The 
recommended value is 0.9 to balance the overhead of
data exchanges for load balancing.  No load balancing
is needed if the preconditioner is very sparse and
fast to construct.  The default value when this 
parameter is not set is 0.\strut}
\begin{cxxdoc}

Set the load balance parameter for the
ParaSails preconditioner.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParaSailsSetReuse}
        {(HYPRE\_Solver\ solver,\ int\ reuse)}
        {
Set the pattern reuse parameter for the
ParaSails preconditioner}
        {6.3.7}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] Preconditioner object for which to set the pattern reuse 
parameter.
\\
{\tt\strut reuse}\strut{} --- [IN] Value of the pattern reuse parameter.  A nonzero value
indicates that the pattern of the preconditioner should
be reused for subsequent constructions of the 
preconditioner.  A zero value indicates that the 
preconditioner should be constructed from scratch.
The default value when this parameter is not set is 0.\strut}
\begin{cxxdoc}

Set the pattern reuse parameter for the
ParaSails preconditioner.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParaSailsSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
Set the logging parameter for the
ParaSails preconditioner}
        {6.3.8}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] Preconditioner object for which to set the logging
parameter.
\\
{\tt\strut logging}\strut{} --- [IN] Value of the logging parameter.  A nonzero value
sends statistics of the setup procedure to stdout.
The default value when this parameter is not set is 0.\strut}
\begin{cxxdoc}

Set the logging parameter for the
ParaSails preconditioner.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParaSailsBuildIJMatrix}
        {(HYPRE\_Solver\ solver,\ HYPRE\_IJMatrix\ *pij\_A)}
        {
Build IJ Matrix of the sparse approximate inverse (factor)}
        {6.3.9}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] Preconditioner object.
\\
{\tt\strut pij\_A}\strut{} --- [OUT] Pointer to the IJ Matrix.\strut}
\begin{cxxdoc}

Build IJ Matrix of the sparse approximate inverse (factor).
This function explicitly creates the IJ Matrix corresponding to 
the sparse approximate inverse or the inverse factor.
Example:  HYPRE\_IJMatrix ij\_A;
HYPRE\_ParaSailsBuildIJMatrix(solver, \&ij\_A);


\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR Euclid Preconditioner }
        {}
        {
}
        {6.4}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_EuclidCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_Solver\ *solver)}
        {
Create a Euclid object}
        {}
\label{cxx.6.4.7}
\cxxitem{int\ }
        {HYPRE\_EuclidDestroy}
        {(HYPRE\_Solver\ solver)}
        {
Destroy a Euclid object}
        {}
\label{cxx.6.4.8}
\cxxitem{int\ }
        {HYPRE\_EuclidSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Set up the Euclid preconditioner}
        {6.4.1}
\cxxitem{int\ }
        {HYPRE\_EuclidSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Apply the Euclid preconditioner}
        {6.4.2}
\cxxitem{int\ }
        {HYPRE\_EuclidSetParams}
        {(HYPRE\_Solver\ solver,\ int\ argc,\ char\ *argv[])}
        {
Insert (name, value) pairs in Euclid's options database
by passing Euclid the command line (or an array of strings)}
        {6.4.3}
\cxxitem{int\ }
        {HYPRE\_EuclidSetParamsFromFile}
        {(HYPRE\_Solver\ solver,\ char\ *filename)}
        {
Insert (name, value) pairs in Euclid's options database}
        {6.4.4}
\cxxitem{int\ }
        {HYPRE\_EuclidSetLevel}
        {(HYPRE\_Solver\ solver,\ int\ level)}
        {
Set level k for ILU(k) factorization, default: 1}
        {}
\label{cxx.6.4.9}
\cxxitem{int\ }
        {HYPRE\_EuclidSetBJ}
        {(HYPRE\_Solver\ solver,\ int\ bj)}
        {
Use block Jacobi ILU preconditioning instead of PILU}
        {}
\label{cxx.6.4.10}
\cxxitem{int\ }
        {HYPRE\_EuclidSetStats}
        {(HYPRE\_Solver\ solver,\ int\ eu\_stats)}
        {
If eu\_stats not equal 0, a summary of runtime settings and 
timing information is printed to stdout}
        {}
\label{cxx.6.4.11}
\cxxitem{int\ }
        {HYPRE\_EuclidSetMem}
        {(HYPRE\_Solver\ solver,\ int\ eu\_mem)}
        {
If eu\_mem not equal 0, a summary of Euclid's memory usage
is printed to stdout}
        {}
\label{cxx.6.4.12}
\cxxitem{int\ }
        {HYPRE\_EuclidSetSparseA}
        {(HYPRE\_Solver\ solver,\ double\ sparse\_A)}
        {
Defines a drop tolerance for ILU(k)}
        {6.4.5}
\cxxitem{int\ }
        {HYPRE\_EuclidSetRowScale}
        {(HYPRE\_Solver\ solver,\ int\ row\_scale)}
        {
If row\_scale not equal 0, values are scaled prior to factorization
so that largest value in any row is +1 or -1}
        {6.4.6}
\cxxitem{int\ }
        {HYPRE\_EuclidSetILUT}
        {(HYPRE\_Solver\ solver,\ double\ drop\_tol)}
        {
uses ILUT and defines a drop tolerance relative to the largest
absolute value of any entry in the row being factored}
        {}
\label{cxx.6.4.13}
\end{cxxnames}
\begin{cxxdoc}


MPI Parallel ILU preconditioner 

Options summary:
\begin{center}
\begin{tabular}{|l|c|l|}
\hline
Option & Default & Synopsis \\
\hline
-level    & 1 & ILU($k$) factorization level \\ \hline
-bj       & 0 (false) & Use Block Jacobi ILU instead of PILU \\ \hline
-eu\_stats & 0 (false) & Print  internal timing and statistics \\ \hline
-eu\_mem   & 0 (false) & Print  internal memory usage \\ \hline
\end{tabular}
\end{center}

\end{cxxdoc}
\begin{cxxfunction}
{int\ }
        {HYPRE\_EuclidSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Set up the Euclid preconditioner}
        {6.4.1}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] Preconditioner object to set up.
\\
{\tt\strut A}\strut{} --- [IN] ParCSR matrix used to construct the preconditioner.
\\
{\tt\strut b}\strut{} --- Ignored by this function.
\\
{\tt\strut x}\strut{} --- Ignored by this function.\strut}
\begin{cxxdoc}

Set up the Euclid preconditioner.  This function should be passed
to the iterative solver {\tt SetPrecond} function.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_EuclidSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Apply the Euclid preconditioner}
        {6.4.2}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] Preconditioner object to apply.
\\
{\tt\strut A}\strut{} --- Ignored by this function.
\\
{\tt\strut b}\strut{} --- [IN] Vector to precondition.
\\
{\tt\strut x}\strut{} --- [OUT] Preconditioned vector.\strut}
\begin{cxxdoc}

Apply the Euclid preconditioner. This function should be passed
to the iterative solver {\tt SetPrecond} function.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_EuclidSetParams}
        {(HYPRE\_Solver\ solver,\ int\ argc,\ char\ *argv[])}
        {
Insert (name, value) pairs in Euclid's options database
by passing Euclid the command line (or an array of strings)}
        {6.4.3}
\cxxParameter{
{\tt\strut argc}\strut{} --- [IN] Length of argv array
\\
{\tt\strut argv}\strut{} --- [IN] Array of strings\strut}
\begin{cxxdoc}

Insert (name, value) pairs in Euclid's options database
by passing Euclid the command line (or an array of strings).
All Euclid options (e.g, level, drop-tolerance) are stored in
this database.  
If a (name, value) pair already exists, this call updates the value.
See also: HYPRE\_EuclidSetParamsFromFile.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_EuclidSetParamsFromFile}
        {(HYPRE\_Solver\ solver,\ char\ *filename)}
        {
Insert (name, value) pairs in Euclid's options database}
        {6.4.4}
\cxxParameter{
{\tt\strut filename[IN]}\strut{} --- Pathname/filename to read\strut}
\begin{cxxdoc}

Insert (name, value) pairs in Euclid's options database.
Each line of the file should either begin with a ``\#,''
indicating a comment line, or contain a (name value)
pair, e.g: \\

\>cat optionsFile \\
\#sample runtime parameter file \\
-blockJacobi 3 \\
-matFile     /home/hysom/myfile.euclid \\
-doSomething true \\
-xx\_coeff -1.0

See also: HYPRE\_EuclidSetParams.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_EuclidSetSparseA}
        {(HYPRE\_Solver\ solver,\ double\ sparse\_A)}
        {
Defines a drop tolerance for ILU(k)}
        {6.4.5}
\begin{cxxdoc}

Defines a drop tolerance for ILU(k). Default: 0
Use with HYPRE\_EuclidSetRowScale. 
Note that this can destroy symmetry in a matrix.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_EuclidSetRowScale}
        {(HYPRE\_Solver\ solver,\ int\ row\_scale)}
        {
If row\_scale not equal 0, values are scaled prior to factorization
so that largest value in any row is +1 or -1}
        {6.4.6}
\begin{cxxdoc}

If row\_scale not equal 0, values are scaled prior to factorization
so that largest value in any row is +1 or -1.
Note that this can destroy symmetry in a matrix.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR Pilut Preconditioner}
        {}
        {
}
        {6.5}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_ParCSRPilutCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_Solver\ *solver)}
        {
Create a preconditioner object}
        {}
\label{cxx.6.5.1}
\cxxitem{int\ }
        {HYPRE\_ParCSRPilutDestroy}
        {(HYPRE\_Solver\ solver)}
        {
Destroy a preconditioner object}
        {}
\label{cxx.6.5.2}
\cxxitem{int\ }
        {HYPRE\_ParCSRPilutSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {}
        {}
\label{cxx.6.5.3}
\cxxitem{int\ }
        {HYPRE\_ParCSRPilutSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Precondition the system}
        {}
\label{cxx.6.5.4}
\cxxitem{int\ }
        {HYPRE\_ParCSRPilutSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.6.5.5}
\cxxitem{int\ }
        {HYPRE\_ParCSRPilutSetDropTolerance}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional)}
        {}
\label{cxx.6.5.6}
\cxxitem{int\ }
        {HYPRE\_ParCSRPilutSetFactorRowSize}
        {(HYPRE\_Solver\ solver,\ int\ size)}
        {
(Optional)}
        {}
\label{cxx.6.5.7}
\end{cxxnames}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR AMS Solver and Preconditioner}
        {}
        {
}
        {6.6}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_AMSCreate}
        {(HYPRE\_Solver\ *solver)}
        {
Create an AMS solver object}
        {}
\label{cxx.6.6.17}
\cxxitem{int\ }
        {HYPRE\_AMSDestroy}
        {(HYPRE\_Solver\ solver)}
        {
Destroy an AMS solver object}
        {}
\label{cxx.6.6.18}
\cxxitem{int\ }
        {HYPRE\_AMSSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Set up the AMS solver or preconditioner}
        {6.6.1}
\cxxitem{int\ }
        {HYPRE\_AMSSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Solve the system or apply AMS as a preconditioner}
        {6.6.2}
\cxxitem{int\ }
        {HYPRE\_AMSSetDimension}
        {(HYPRE\_Solver\ solver,\ int\ dim)}
        {
(Optional) Sets the problem dimension (2 or 3)}
        {6.6.3}
\cxxitem{int\ }
        {HYPRE\_AMSSetDiscreteGradient}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ G)}
        {
Sets the discrete gradient matrix $G$}
        {6.6.4}
\cxxitem{int\ }
        {HYPRE\_AMSSetCoordinateVectors}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParVector\ x,\ HYPRE\_ParVector\ y,\ HYPRE\_ParVector\ z)}
        {
Sets the $x$, $y$ and $z$ coordinates of the vertices in the mesh}
        {6.6.5}
\cxxitem{int\ }
        {HYPRE\_AMSSetEdgeConstantVectors}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParVector\ Gx,\ HYPRE\_ParVector\ Gy,\ HYPRE\_ParVector\ Gz)}
        {
Sets the vectors $Gx$, $Gy$ and $Gz$ which give the representations of
the constant vector fields $(1,0,0)$, $(0,1,0)$ and $(0,0,1)$ in the
edge element basis}
        {6.6.6}
\cxxitem{int\ }
        {HYPRE\_AMSSetAlphaPoissonMatrix}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A\_alpha)}
        {
(Optional) Sets the matrix $A_\alpha$ corresponding to the Poisson
problem with coefficient $\alpha$ (the curl-curl term coefficient in
the Maxwell problem)}
        {6.6.7}
\cxxitem{int\ }
        {HYPRE\_AMSSetBetaPoissonMatrix}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A\_beta)}
        {
(Optional) Sets the matrix $A_\beta$ corresponding to the Poisson
problem with coefficient $\beta$ (the mass term coefficient in the
Maxwell problem)}
        {6.6.8}
\cxxitem{int\ }
        {HYPRE\_AMSSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ maxit)}
        {
(Optional) Sets maximum number of iterations, if AMS is used
as a solver}
        {6.6.9}
\cxxitem{int\ }
        {HYPRE\_AMSSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance, if AMS is used
as a solver}
        {6.6.10}
\cxxitem{int\ }
        {HYPRE\_AMSSetCycleType}
        {(HYPRE\_Solver\ solver,\ int\ cycle\_type)}
        {
(Optional) Choose which three-level solver to use}
        {6.6.11}
\cxxitem{int\ }
        {HYPRE\_AMSSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ print\_level)}
        {
(Optional) Control how much information is printed during the
solution iterations}
        {6.6.12}
\cxxitem{int\ }
        {HYPRE\_AMSSetSmoothingOptions}
        {(HYPRE\_Solver\ solver,\ int\ relax\_type,\ int\ relax\_times,\ double\ relax\_weight,\ double\ omega)}
        {
(Optional) Sets relaxation parameters for $A$}
        {6.6.13}
\cxxitem{int\ }
        {HYPRE\_AMSSetAlphaAMGOptions}
        {(HYPRE\_Solver\ solver,\ int\ alpha\_coarsen\_type,\ int\ alpha\_agg\_levels,\ int\ alpha\_relax\_type,\ double\ alpha\_strength\_threshold,\ int\ alpha\_interp\_type,\ int\ alpha\_Pmax)}
        {
(Optional) Sets AMG parameters for $B_\Pi$}
        {6.6.14}
\cxxitem{int\ }
        {HYPRE\_AMSSetBetaAMGOptions}
        {(HYPRE\_Solver\ solver,\ int\ beta\_coarsen\_type,\ int\ beta\_agg\_levels,\ int\ beta\_relax\_type,\ double\ beta\_strength\_threshold,\ int\ beta\_interp\_type,\ int\ beta\_Pmax)}
        {
(Optional) Sets AMG parameters for $B_G$}
        {6.6.15}
\cxxitem{int\ }
        {HYPRE\_AMSGetNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *num\_iterations)}
        {
Returns the number of iterations taken}
        {}
\label{cxx.6.6.19}
\cxxitem{int\ }
        {HYPRE\_AMSGetFinalRelativeResidualNorm}
        {(HYPRE\_Solver\ solver,\ double\ *rel\_resid\_norm)}
        {
Returns the norm of the final relative residual}
        {}
\label{cxx.6.6.20}
\cxxitem{int\ }
        {HYPRE\_AMSConstructDiscreteGradient}
        {(HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ x\_coord,\ int\ *edge\_vertex,\ HYPRE\_ParCSRMatrix\ *G)}
        {
Construct and return the discrete gradient matrix G using some
edge and vertex information}
        {6.6.16}
\end{cxxnames}
\begin{cxxdoc}


Parallel auxiliary space Maxwell solver and preconditioner
\end{cxxdoc}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Set up the AMS solver or preconditioner}
        {6.6.1}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] object to be set up.
\\
{\tt\strut A}\strut{} --- [IN] ParCSR matrix used to construct the solver/preconditioner.
\\
{\tt\strut b}\strut{} --- Ignored by this function.
\\
{\tt\strut x}\strut{} --- Ignored by this function.\strut}
\begin{cxxdoc}

Set up the AMS solver or preconditioner.
If used as a preconditioner, this function should be passed
to the iterative solver {\tt SetPrecond} function.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Solve the system or apply AMS as a preconditioner}
        {6.6.2}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] solver or preconditioner object to be applied.
\\
{\tt\strut A}\strut{} --- [IN] ParCSR matrix, matrix of the linear system to be solved
\\
{\tt\strut b}\strut{} --- [IN] right hand side of the linear system to be solved
\\
{\tt\strut x}\strut{} --- [OUT] approximated solution of the linear system to be solved\strut}
\begin{cxxdoc}

Solve the system or apply AMS as a preconditioner.
If used as a preconditioner, this function should be passed
to the iterative solver {\tt SetPrecond} function.


\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSetDimension}
        {(HYPRE\_Solver\ solver,\ int\ dim)}
        {
(Optional) Sets the problem dimension (2 or 3)}
        {6.6.3}
\begin{cxxdoc}

(Optional) Sets the problem dimension (2 or 3). The default is 3.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSetDiscreteGradient}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ G)}
        {
Sets the discrete gradient matrix $G$}
        {6.6.4}
\begin{cxxdoc}

Sets the discrete gradient matrix $G$.
This function should be called before HYPRE\_AMSSetup()!
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSetCoordinateVectors}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParVector\ x,\ HYPRE\_ParVector\ y,\ HYPRE\_ParVector\ z)}
        {
Sets the $x$, $y$ and $z$ coordinates of the vertices in the mesh}
        {6.6.5}
\begin{cxxdoc}

Sets the $x$, $y$ and $z$ coordinates of the vertices in the mesh.

Either HYPRE\_AMSSetCoordinateVectors() or HYPRE\_AMSSetEdgeConstantVectors()
should be called before HYPRE\_AMSSetup()!
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSetEdgeConstantVectors}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParVector\ Gx,\ HYPRE\_ParVector\ Gy,\ HYPRE\_ParVector\ Gz)}
        {
Sets the vectors $Gx$, $Gy$ and $Gz$ which give the representations of
the constant vector fields $(1,0,0)$, $(0,1,0)$ and $(0,0,1)$ in the
edge element basis}
        {6.6.6}
\begin{cxxdoc}

Sets the vectors $Gx$, $Gy$ and $Gz$ which give the representations of
the constant vector fields $(1,0,0)$, $(0,1,0)$ and $(0,0,1)$ in the
edge element basis.

Either HYPRE\_AMSSetCoordinateVectors() or HYPRE\_AMSSetEdgeConstantVectors()
should be called before HYPRE\_AMSSetup()!
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSetAlphaPoissonMatrix}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A\_alpha)}
        {
(Optional) Sets the matrix $A_\alpha$ corresponding to the Poisson
problem with coefficient $\alpha$ (the curl-curl term coefficient in
the Maxwell problem)}
        {6.6.7}
\begin{cxxdoc}

(Optional) Sets the matrix $A_\alpha$ corresponding to the Poisson
problem with coefficient $\alpha$ (the curl-curl term coefficient in
the Maxwell problem).

If this function is called, the coarse space solver on the range
of $\Pi^T$ is a block-diagonal version of $A_\Pi$. If this function is not
called, the coarse space solver on the range of $\Pi^T$ is constructed
as $\Pi^T A \Pi$ in HYPRE\_AMSSetup(). See the user's manual for more details.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSetBetaPoissonMatrix}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A\_beta)}
        {
(Optional) Sets the matrix $A_\beta$ corresponding to the Poisson
problem with coefficient $\beta$ (the mass term coefficient in the
Maxwell problem)}
        {6.6.8}
\begin{cxxdoc}

(Optional) Sets the matrix $A_\beta$ corresponding to the Poisson
problem with coefficient $\beta$ (the mass term coefficient in the
Maxwell problem).

If not given, the Poisson matrix will be computed in HYPRE\_AMSSetup().
If the given matrix is NULL, we assume that $\beta$ is identically $0$
and use two-level (instead of three-level) methods. See the user's manual for more details.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ maxit)}
        {
(Optional) Sets maximum number of iterations, if AMS is used
as a solver}
        {6.6.9}
\begin{cxxdoc}

(Optional) Sets maximum number of iterations, if AMS is used
as a solver. To use AMS as a preconditioner, set the maximum
number of iterations to $1$. The default is $20$.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance, if AMS is used
as a solver}
        {6.6.10}
\begin{cxxdoc}

(Optional) Set the convergence tolerance, if AMS is used
as a solver. When using AMS as a preconditioner, set the tolerance
to $0.0$. The default is $10^{-6}$.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSetCycleType}
        {(HYPRE\_Solver\ solver,\ int\ cycle\_type)}
        {
(Optional) Choose which three-level solver to use}
        {6.6.11}
\begin{cxxdoc}

(Optional) Choose which three-level solver to use. Possible values are:

\begin{tabular}{|c|l|}
\hline
1 & 3-level multiplicative solver (01210) \\
2 & 3-level additive solver (0+1+2) \\
3 & 3-level multiplicative solver (02120) \\
4 & 3-level additive solver (010+2) \\
5 & 3-level multiplicative solver (0102010) \\
6 & 3-level additive solver (1+020) \\
7 & 3-level multiplicative solver (0201020) \\
8 & 3-level additive solver (0(1+2)0) \\
11 & 5-level multiplicative solver (013454310) \\
12 & 5-level additive solver (0+1+3+4+5) \\
13 & 5-level multiplicative solver (034515430) \\
14 & 5-level additive solver (01(3+4+5)10) \\
\hline
\end{tabular}

The default is $1$. See the user's manual for more details.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ print\_level)}
        {
(Optional) Control how much information is printed during the
solution iterations}
        {6.6.12}
\begin{cxxdoc}

(Optional) Control how much information is printed during the
solution iterations.
The default is $1$ (print residual norm at each step).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSetSmoothingOptions}
        {(HYPRE\_Solver\ solver,\ int\ relax\_type,\ int\ relax\_times,\ double\ relax\_weight,\ double\ omega)}
        {
(Optional) Sets relaxation parameters for $A$}
        {6.6.13}
\begin{cxxdoc}

(Optional) Sets relaxation parameters for $A$.
The defaults are $2$, $1$, $1.0$, $1.0$.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSetAlphaAMGOptions}
        {(HYPRE\_Solver\ solver,\ int\ alpha\_coarsen\_type,\ int\ alpha\_agg\_levels,\ int\ alpha\_relax\_type,\ double\ alpha\_strength\_threshold,\ int\ alpha\_interp\_type,\ int\ alpha\_Pmax)}
        {
(Optional) Sets AMG parameters for $B_\Pi$}
        {6.6.14}
\begin{cxxdoc}

(Optional) Sets AMG parameters for $B_\Pi$.
The defaults are $10$, $1$, $3$, $0.25$, $0$, $0$. See the user's manual for more details.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSSetBetaAMGOptions}
        {(HYPRE\_Solver\ solver,\ int\ beta\_coarsen\_type,\ int\ beta\_agg\_levels,\ int\ beta\_relax\_type,\ double\ beta\_strength\_threshold,\ int\ beta\_interp\_type,\ int\ beta\_Pmax)}
        {
(Optional) Sets AMG parameters for $B_G$}
        {6.6.15}
\begin{cxxdoc}

(Optional) Sets AMG parameters for $B_G$.
The defaults are $10$, $1$, $3$, $0.25$, $0$, $0$. See the user's manual for more details.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_AMSConstructDiscreteGradient}
        {(HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ x\_coord,\ int\ *edge\_vertex,\ HYPRE\_ParCSRMatrix\ *G)}
        {
Construct and return the discrete gradient matrix G using some
edge and vertex information}
        {6.6.16}
\begin{cxxdoc}

Construct and return the discrete gradient matrix G using some
edge and vertex information. We assume that edge\_vertex lists
the edge vertices consecutively, and that the orientation of edge i
depends only on the sign of edge\_vertex[2*i+1] - edge\_vertex[2*i].
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR Hybrid Solver}
        {}
        {
}
        {6.7}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridCreate}
        {(\ HYPRE\_Solver\ *solver)}
        {
Create solver object}
        {}
\label{cxx.6.7.28}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridDestroy}
        {(HYPRE\_Solver\ solver)}
        {
Destroy solver object}
        {}
\label{cxx.6.7.29}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Setup the hybrid solver
}
        {6.7.1}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Solve linear system
}
        {6.7.2}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
Set the convergence tolerance for the Krylov solver}
        {6.7.3}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
Set the absolute convergence tolerance for the Krylov solver}
        {6.7.4}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetConvergenceTol}
        {(HYPRE\_Solver\ solver,\ double\ cf\_tol)}
        {
Set the desired convergence factor}
        {}
\label{cxx.6.7.30}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetDSCGMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ dscg\_max\_its)}
        {
Set the maximal number of iterations for the diagonally
preconditioned solver}
        {}
\label{cxx.6.7.31}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetPCGMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ pcg\_max\_its)}
        {
Set the maximal number of iterations for the AMG
preconditioned solver}
        {}
\label{cxx.6.7.32}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetSolverType}
        {(HYPRE\_Solver\ solver,\ int\ solver\_type)}
        {
Set the desired solver type}
        {6.7.5}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetKDim}
        {(HYPRE\_Solver\ solver,\ int\ k\_dim)}
        {
Set the Krylov dimension for restarted GMRES}
        {6.7.6}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetTwoNorm}
        {(HYPRE\_Solver\ solver,\ int\ two\_norm)}
        {
Set the type of norm for PCG}
        {}
\label{cxx.6.7.33}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_PtrToParSolverFcn\ precond,\ HYPRE\_PtrToParSolverFcn\ precond\_setup,\ HYPRE\_Solver\ precond\_solver)}
        {
Set preconditioner if wanting to use one that is not set up by
the hybrid solver}
        {}
\label{cxx.6.7.34}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
Set logging parameter (default: 0, no logging)}
        {}
\label{cxx.6.7.35}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ print\_level)}
        {
Set print level (default: 0, no printing)}
        {}
\label{cxx.6.7.36}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetStrongThreshold}
        {(\ HYPRE\_Solver\ solver,\ double\ strong\_threshold\ )}
        {
(Optional) Sets AMG strength threshold}
        {6.7.7}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetMaxRowSum}
        {(\ HYPRE\_Solver\ solver,\ double\ max\_row\_sum\ )}
        {
(Optional) Sets a parameter to modify the definition of strength for
diagonal dominant portions of the matrix}
        {6.7.8}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetTruncFactor}
        {(\ HYPRE\_Solver\ solver,\ double\ trunc\_factor\ )}
        {
(Optional) Defines a truncation factor for the interpolation}
        {6.7.9}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetPMaxElmts}
        {(HYPRE\_Solver\ solver,\ int\ P\_max\_elmts)}
        {
(Optional) Defines the maximal number of elements per row for the interpolation}
        {6.7.10}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetMaxLevels}
        {(\ HYPRE\_Solver\ solver,\ int\ max\_levels\ )}
        {
(Optional) Defines the maximal number of levels used for AMG}
        {6.7.11}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetMeasureType}
        {(\ HYPRE\_Solver\ solver,\ int\ measure\_type\ )}
        {
(Optional) Defines whether local or global measures are used}
        {}
\label{cxx.6.7.37}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetCoarsenType}
        {(\ HYPRE\_Solver\ solver,\ int\ coarsen\_type\ )}
        {
(Optional) Defines which parallel coarsening algorithm is used}
        {6.7.12}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetCycleType}
        {(\ HYPRE\_Solver\ solver,\ int\ cycle\_type\ )}
        {
(Optional) Defines the type of cycle}
        {6.7.13}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetNumSweeps}
        {(\ HYPRE\_Solver\ solver,\ int\ num\_sweeps\ )}
        {
(Optional) Sets the number of sweeps}
        {6.7.14}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetCycleNumSweeps}
        {(\ HYPRE\_Solver\ solver,\ int\ num\_sweeps,\ int\ k\ )}
        {
(Optional) Sets the number of sweeps at a specified cycle}
        {6.7.15}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetRelaxType}
        {(\ HYPRE\_Solver\ solver,\ int\ relax\_type\ )}
        {
(Optional) Defines the smoother to be used}
        {6.7.16}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetCycleRelaxType}
        {(\ HYPRE\_Solver\ solver,\ int\ relax\_type,\ int\ k\ )}
        {
(Optional) Defines the smoother at a given cycle}
        {6.7.17}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetRelaxOrder}
        {(\ HYPRE\_Solver\ solver,\ int\ relax\_order\ )}
        {
(Optional) Defines in which order the points are relaxed}
        {6.7.18}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetRelaxWt}
        {(\ HYPRE\_Solver\ solver,\ double\ relax\_wt\ )}
        {
(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR
on all levels}
        {6.7.19}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetLevelRelaxWt}
        {(\ HYPRE\_Solver\ solver,\ double\ relax\_wt,\ int\ level\ )}
        {
(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR
on the user defined level}
        {6.7.20}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetOuterWt}
        {(\ HYPRE\_Solver\ solver,\ double\ outer\_wt\ )}
        {
(Optional) Defines the outer relaxation weight for hybrid SOR and SSOR
on all levels}
        {6.7.21}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetLevelOuterWt}
        {(\ HYPRE\_Solver\ solver,\ double\ outer\_wt,\ int\ level\ )}
        {
(Optional) Defines the outer relaxation weight for hybrid SOR or SSOR
on the user defined level}
        {6.7.22}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetAggNumLevels}
        {(\ HYPRE\_Solver\ solver,\ int\ agg\_num\_levels\ )}
        {
(Optional) Defines the number of levels of aggressive coarsening,
starting with the finest level}
        {6.7.23}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetNumPaths}
        {(\ HYPRE\_Solver\ solver,\ int\ num\_paths\ )}
        {
(Optional) Defines the degree of aggressive coarsening}
        {6.7.24}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetNumFunctions}
        {(\ HYPRE\_Solver\ solver,\ int\ num\_functions)}
        {
(Optional) Sets the size of the system of PDEs, if using the systems version}
        {6.7.25}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetDofFunc}
        {(\ HYPRE\_Solver\ solver,\ int\ *dof\_func\ )}
        {
(Optional) Sets the mapping that assigns the function to each variable,
if using the systems version}
        {6.7.26}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridSetNodal}
        {(\ HYPRE\_Solver\ solver,\ int\ nodal\ )}
        {
(Optional) Sets whether to use the nodal systems version}
        {6.7.27}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridGetNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *num\_its)}
        {
Retrieves the total number of iterations}
        {}
\label{cxx.6.7.38}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridGetDSCGNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *dscg\_num\_its)}
        {
Retrieves the number of iterations used by the diagonally scaled solver}
        {}
\label{cxx.6.7.39}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridGetPCGNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *pcg\_num\_its)}
        {
Retrieves the number of iterations used by the AMG preconditioned solver}
        {}
\label{cxx.6.7.40}
\cxxitem{int\ }
        {HYPRE\_ParCSRHybridGetFinalRelativeResidualNorm}
        {(HYPRE\_Solver\ solver,\ double\ *norm)}
        {
Retrieves the final relative residual norm}
        {}
\label{cxx.6.7.41}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Setup the hybrid solver
}
        {6.7.1}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] object to be set up.
\\
{\tt\strut A}\strut{} --- [IN] ParCSR matrix used to construct the solver/preconditioner.
\\
{\tt\strut b}\strut{} --- Ignored by this function.
\\
{\tt\strut x}\strut{} --- Ignored by this function.\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Solve linear system
}
        {6.7.2}
\cxxParameter{
{\tt\strut solver}\strut{} --- [IN] solver or preconditioner object to be applied.
\\
{\tt\strut A}\strut{} --- [IN] ParCSR matrix, matrix of the linear system to be solved
\\
{\tt\strut b}\strut{} --- [IN] right hand side of the linear system to be solved
\\
{\tt\strut x}\strut{} --- [OUT] approximated solution of the linear system to be solved\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
Set the convergence tolerance for the Krylov solver}
        {6.7.3}
\begin{cxxdoc}

Set the convergence tolerance for the Krylov solver. The default is 1.e-7.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
Set the absolute convergence tolerance for the Krylov solver}
        {6.7.4}
\begin{cxxdoc}

Set the absolute convergence tolerance for the Krylov solver. The default is 0.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetSolverType}
        {(HYPRE\_Solver\ solver,\ int\ solver\_type)}
        {
Set the desired solver type}
        {6.7.5}
\begin{cxxdoc}

Set the desired solver type. There are the following options:
\begin{tabular}{l l}
1 & PCG (default) \\
2 & GMRES \\
3 & BiCGSTAB
\end{tabular}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetKDim}
        {(HYPRE\_Solver\ solver,\ int\ k\_dim)}
        {
Set the Krylov dimension for restarted GMRES}
        {6.7.6}
\begin{cxxdoc}

Set the Krylov dimension for restarted GMRES.
The default is 5.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetStrongThreshold}
        {(\ HYPRE\_Solver\ solver,\ double\ strong\_threshold\ )}
        {
(Optional) Sets AMG strength threshold}
        {6.7.7}
\begin{cxxdoc}

(Optional) Sets AMG strength threshold. The default is 0.25.
For 2d Laplace operators, 0.25 is a good value, for 3d Laplace
operators, 0.5 or 0.6 is a better value. For elasticity problems,
a large strength threshold, such as 0.9, is often better.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetMaxRowSum}
        {(\ HYPRE\_Solver\ solver,\ double\ max\_row\_sum\ )}
        {
(Optional) Sets a parameter to modify the definition of strength for
diagonal dominant portions of the matrix}
        {6.7.8}
\begin{cxxdoc}

(Optional) Sets a parameter to modify the definition of strength for
diagonal dominant portions of the matrix. The default is 0.9.
If max\_row\_sum is 1, no checking for diagonally dominant rows is
performed.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetTruncFactor}
        {(\ HYPRE\_Solver\ solver,\ double\ trunc\_factor\ )}
        {
(Optional) Defines a truncation factor for the interpolation}
        {6.7.9}
\begin{cxxdoc}

(Optional) Defines a truncation factor for the interpolation.
The default is 0.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetPMaxElmts}
        {(HYPRE\_Solver\ solver,\ int\ P\_max\_elmts)}
        {
(Optional) Defines the maximal number of elements per row for the interpolation}
        {6.7.10}
\begin{cxxdoc}

(Optional) Defines the maximal number of elements per row for the interpolation.
The default is 0.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetMaxLevels}
        {(\ HYPRE\_Solver\ solver,\ int\ max\_levels\ )}
        {
(Optional) Defines the maximal number of levels used for AMG}
        {6.7.11}
\begin{cxxdoc}

(Optional) Defines the maximal number of levels used for AMG.
The default is 25.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetCoarsenType}
        {(\ HYPRE\_Solver\ solver,\ int\ coarsen\_type\ )}
        {
(Optional) Defines which parallel coarsening algorithm is used}
        {6.7.12}
\begin{cxxdoc}

(Optional) Defines which parallel coarsening algorithm is used.
There are the following options for coarsen\_type:

\begin{tabular}{|c|l|} \hline
0 &  CLJP-coarsening (a parallel coarsening algorithm using independent sets). \\
1 &  classical Ruge-Stueben coarsening on each processor, no boundary treatment \\
3 &  classical Ruge-Stueben coarsening on each processor, followed by a third \\
&  pass, which adds coarse points on the boundaries \\
6 &  Falgout coarsening (uses 1 first, followed by CLJP using the interior coarse \\
& points generated by 1 as its first independent set) \\
7 &  CLJP-coarsening (using a fixed random vector, for debugging purposes only) \\
8 &  PMIS-coarsening (a parallel coarsening algorithm using independent sets \\
& with lower complexities than CLJP, might also lead to slower convergence) \\
9 &  PMIS-coarsening (using a fixed random vector, for debugging purposes only) \\
10 & HMIS-coarsening (uses one pass Ruge-Stueben on each processor independently, \\
& followed by PMIS using the interior C-points as its first independent set) \\
11 & one-pass Ruge-Stueben coarsening on each processor, no boundary treatment \\
\hline
\end{tabular}

The default is 6.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetCycleType}
        {(\ HYPRE\_Solver\ solver,\ int\ cycle\_type\ )}
        {
(Optional) Defines the type of cycle}
        {6.7.13}
\begin{cxxdoc}

(Optional) Defines the type of cycle.
For a V-cycle, set cycle\_type to 1, for a W-cycle
set cycle\_type to 2. The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetNumSweeps}
        {(\ HYPRE\_Solver\ solver,\ int\ num\_sweeps\ )}
        {
(Optional) Sets the number of sweeps}
        {6.7.14}
\begin{cxxdoc}

(Optional) Sets the number of sweeps. On the finest level, the up and
the down cycle the number of sweeps are set to num\_sweeps and on the
coarsest level to 1. The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetCycleNumSweeps}
        {(\ HYPRE\_Solver\ solver,\ int\ num\_sweeps,\ int\ k\ )}
        {
(Optional) Sets the number of sweeps at a specified cycle}
        {6.7.15}
\begin{cxxdoc}

(Optional) Sets the number of sweeps at a specified cycle.
There are the following options for k:

\begin{tabular}{|l|l|} \hline
the down cycle &     if k=1 \\
the up cycle &       if k=2 \\
the coarsest level &  if k=3.\\
\hline
\end{tabular}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetRelaxType}
        {(\ HYPRE\_Solver\ solver,\ int\ relax\_type\ )}
        {
(Optional) Defines the smoother to be used}
        {6.7.16}
\begin{cxxdoc}

(Optional) Defines the smoother to be used. It uses the given
smoother on the fine grid, the up and
the down cycle and sets the solver on the coarsest level to Gaussian
elimination (9). The default is Gauss-Seidel (3).

There are the following options for relax\_type:

\begin{tabular}{|c|l|} \hline
0 &  Jacobi \\
1 &  Gauss-Seidel, sequential (very slow!) \\
2 &  Gauss-Seidel, interior points in parallel, boundary sequential (slow!) \\
3 &  hybrid Gauss-Seidel or SOR, forward solve \\
4 &  hybrid Gauss-Seidel or SOR, backward solve \\
5 &  hybrid chaotic Gauss-Seidel (works only with OpenMP) \\
6 &  hybrid symmetric Gauss-Seidel or SSOR \\
9 &  Gaussian elimination (only on coarsest level) \\
\hline
\end{tabular}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetCycleRelaxType}
        {(\ HYPRE\_Solver\ solver,\ int\ relax\_type,\ int\ k\ )}
        {
(Optional) Defines the smoother at a given cycle}
        {6.7.17}
\begin{cxxdoc}

(Optional) Defines the smoother at a given cycle.
For options of relax\_type see
description of HYPRE\_BoomerAMGSetRelaxType). Options for k are

\begin{tabular}{|l|l|} \hline
the down cycle &     if k=1 \\
the up cycle &       if k=2 \\
the coarsest level &  if k=3. \\
\hline
\end{tabular}
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetRelaxOrder}
        {(\ HYPRE\_Solver\ solver,\ int\ relax\_order\ )}
        {
(Optional) Defines in which order the points are relaxed}
        {6.7.18}
\begin{cxxdoc}

(Optional) Defines in which order the points are relaxed. There are
the following options for
relax\_order:

\begin{tabular}{|c|l|} \hline
0 & the points are relaxed in natural or lexicographic
order on each processor \\
1 &  CF-relaxation is used, i.e on the fine grid and the down
cycle the coarse points are relaxed first, \\
& followed by the fine points; on the up cycle the F-points are relaxed
first, followed by the C-points. \\
& On the coarsest level, if an iterative scheme is used,
the points are relaxed in lexicographic order. \\
\hline
\end{tabular}

The default is 1 (CF-relaxation).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetRelaxWt}
        {(\ HYPRE\_Solver\ solver,\ double\ relax\_wt\ )}
        {
(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR
on all levels}
        {6.7.19}
\begin{cxxdoc}

(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR
on all levels.

\begin{tabular}{|l|l|} \hline
relax\_weight \> 0 & this assigns the given relaxation weight on all levels \\
relax\_weight = 0 &  the weight is determined on each level
with the estimate $3 \over {4\|D^{-1/2}AD^{-1/2}\|}$,\\
& where $D$ is the diagonal matrix of $A$ (this should only be used with Jacobi) \\
relax\_weight = -k & the relaxation weight is determined with at most k CG steps
on each level \\
& this should only be used for symmetric positive definite problems) \\
\hline
\end{tabular}

The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetLevelRelaxWt}
        {(\ HYPRE\_Solver\ solver,\ double\ relax\_wt,\ int\ level\ )}
        {
(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR
on the user defined level}
        {6.7.20}
\begin{cxxdoc}

(Optional) Defines the relaxation weight for smoothed Jacobi and hybrid SOR
on the user defined level. Note that the finest level is denoted 0, the
next coarser level 1, etc. For nonpositive relax\_weight, the parameter is
determined on the given level as described for HYPRE\_BoomerAMGSetRelaxWt.
The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetOuterWt}
        {(\ HYPRE\_Solver\ solver,\ double\ outer\_wt\ )}
        {
(Optional) Defines the outer relaxation weight for hybrid SOR and SSOR
on all levels}
        {6.7.21}
\begin{cxxdoc}

(Optional) Defines the outer relaxation weight for hybrid SOR and SSOR
on all levels.

\begin{tabular}{|l|l|} \hline
omega \> 0 & this assigns the same outer relaxation weight omega on each level\\
omega = -k & an outer relaxation weight is determined with at most k CG
steps on each level \\
& (this only makes sense for symmetric
positive definite problems and smoothers, e.g. SSOR) \\
\hline
\end{tabular}

The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetLevelOuterWt}
        {(\ HYPRE\_Solver\ solver,\ double\ outer\_wt,\ int\ level\ )}
        {
(Optional) Defines the outer relaxation weight for hybrid SOR or SSOR
on the user defined level}
        {6.7.22}
\begin{cxxdoc}

(Optional) Defines the outer relaxation weight for hybrid SOR or SSOR
on the user defined level. Note that the finest level is denoted 0, the
next coarser level 1, etc. For nonpositive omega, the parameter is
determined on the given level as described for HYPRE\_BoomerAMGSetOuterWt.
The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetAggNumLevels}
        {(\ HYPRE\_Solver\ solver,\ int\ agg\_num\_levels\ )}
        {
(Optional) Defines the number of levels of aggressive coarsening,
starting with the finest level}
        {6.7.23}
\begin{cxxdoc}

(Optional) Defines the number of levels of aggressive coarsening,
starting with the finest level.
The default is 0, i.e. no aggressive coarsening.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetNumPaths}
        {(\ HYPRE\_Solver\ solver,\ int\ num\_paths\ )}
        {
(Optional) Defines the degree of aggressive coarsening}
        {6.7.24}
\begin{cxxdoc}

(Optional) Defines the degree of aggressive coarsening.
The default is 1, which leads to the most aggressive coarsening.
Setting num$\_$paths to 2 will increase complexity somewhat,
but can lead to better convergence.*
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetNumFunctions}
        {(\ HYPRE\_Solver\ solver,\ int\ num\_functions)}
        {
(Optional) Sets the size of the system of PDEs, if using the systems version}
        {6.7.25}
\begin{cxxdoc}

(Optional) Sets the size of the system of PDEs, if using the systems version.
The default is 1.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetDofFunc}
        {(\ HYPRE\_Solver\ solver,\ int\ *dof\_func\ )}
        {
(Optional) Sets the mapping that assigns the function to each variable,
if using the systems version}
        {6.7.26}
\begin{cxxdoc}

(Optional) Sets the mapping that assigns the function to each variable,
if using the systems version. If no assignment is made and the number of
functions is k \> 1, the mapping generated is (0,1,...,k-1,0,1,...,k-1,...).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRHybridSetNodal}
        {(\ HYPRE\_Solver\ solver,\ int\ nodal\ )}
        {
(Optional) Sets whether to use the nodal systems version}
        {6.7.27}
\begin{cxxdoc}

(Optional) Sets whether to use the nodal systems version.
The default is 0 (the unknown based approach).
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR PCG Solver}
        {}
        {
}
        {6.8}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_Solver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.6.8.2}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGDestroy}
        {(HYPRE\_Solver\ solver)}
        {
Destroy a solver object}
        {}
\label{cxx.6.8.3}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {}
        {}
\label{cxx.6.8.4}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Solve the system}
        {}
\label{cxx.6.8.5}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the relative convergence tolerance}
        {}
\label{cxx.6.8.6}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the absolute convergence tolerance (default is
0)}
        {6.8.1}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.6.8.7}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGSetTwoNorm}
        {(HYPRE\_Solver\ solver,\ int\ two\_norm)}
        {
(Optional) Use the two-norm in stopping criteria}
        {}
\label{cxx.6.8.8}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGSetRelChange}
        {(HYPRE\_Solver\ solver,\ int\ rel\_change)}
        {
(Optional) Additionally require that the relative difference in
successive iterates be small}
        {}
\label{cxx.6.8.9}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGSetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_PtrToParSolverFcn\ precond,\ HYPRE\_PtrToParSolverFcn\ precond\_setup,\ HYPRE\_Solver\ precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.6.8.10}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGGetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Solver\ *precond\_data)}
        {}
        {}
\label{cxx.6.8.11}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.6.8.12}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ print\_level)}
        {
(Optional) Set the print level}
        {}
\label{cxx.6.8.13}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGGetNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.6.8.14}
\cxxitem{int\ }
        {HYPRE\_ParCSRPCGGetFinalRelativeResidualNorm}
        {(HYPRE\_Solver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.6.8.15}
\cxxitem{int\ }
        {HYPRE\_ParCSRDiagScaleSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ y,\ HYPRE\_ParVector\ x)}
        {
Setup routine for diagonal preconditioning}
        {}
\label{cxx.6.8.16}
\cxxitem{int\ }
        {HYPRE\_ParCSRDiagScale}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ HA,\ HYPRE\_ParVector\ Hy,\ HYPRE\_ParVector\ Hx)}
        {
Solve routine for diagonal preconditioning}
        {}
\label{cxx.6.8.17}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRPCGSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the absolute convergence tolerance (default is
0)}
        {6.8.1}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default is
0). If one desires the convergence test to check the absolute
convergence tolerance {\it only}, then set the relative convergence
tolerance to 0.0.  (The default convergence test is $ \<C*r,r\> \leq$
max(relative$\_$tolerance$^{2} \ast \<C*b, b\>$, absolute$\_$tolerance$^2$).)


\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR GMRES Solver}
        {}
        {
}
        {6.9}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_ParCSRGMRESCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_Solver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.6.9.2}
\cxxitem{int\ }
        {HYPRE\_ParCSRGMRESDestroy}
        {(HYPRE\_Solver\ solver)}
        {
Destroy a solver object}
        {}
\label{cxx.6.9.3}
\cxxitem{int\ }
        {HYPRE\_ParCSRGMRESSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {}
        {}
\label{cxx.6.9.4}
\cxxitem{int\ }
        {HYPRE\_ParCSRGMRESSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Solve the system}
        {}
\label{cxx.6.9.5}
\cxxitem{int\ }
        {HYPRE\_ParCSRGMRESSetKDim}
        {(HYPRE\_Solver\ solver,\ int\ k\_dim)}
        {
(Optional) Set the maximum size of the Krylov space}
        {}
\label{cxx.6.9.6}
\cxxitem{int\ }
        {HYPRE\_ParCSRGMRESSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.6.9.7}
\cxxitem{int\ }
        {HYPRE\_ParCSRGMRESSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {6.9.1}
\cxxitem{int\ }
        {HYPRE\_ParCSRGMRESSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.6.9.8}
\cxxitem{int\ }
        {HYPRE\_ParCSRGMRESSetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_PtrToParSolverFcn\ precond,\ HYPRE\_PtrToParSolverFcn\ precond\_setup,\ HYPRE\_Solver\ precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.6.9.9}
\cxxitem{int\ }
        {HYPRE\_ParCSRGMRESGetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Solver\ *precond\_data)}
        {}
        {}
\label{cxx.6.9.10}
\cxxitem{int\ }
        {HYPRE\_ParCSRGMRESSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.6.9.11}
\cxxitem{int\ }
        {HYPRE\_ParCSRGMRESSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ print\_level)}
        {
(Optional) Set print level}
        {}
\label{cxx.6.9.12}
\cxxitem{int\ }
        {HYPRE\_ParCSRGMRESGetNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.6.9.13}
\cxxitem{int\ }
        {HYPRE\_ParCSRGMRESGetFinalRelativeResidualNorm}
        {(HYPRE\_Solver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.6.9.14}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRGMRESSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {6.9.1}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default is 0). 
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance $\ast \|b\|$, absolute$\_$tolerance).)

\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR FlexGMRES Solver}
        {}
        {
}
        {6.10}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_Solver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.6.10.2}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESDestroy}
        {(HYPRE\_Solver\ solver)}
        {
Destroy a solver object}
        {}
\label{cxx.6.10.3}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {}
        {}
\label{cxx.6.10.4}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Solve the system}
        {}
\label{cxx.6.10.5}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESSetKDim}
        {(HYPRE\_Solver\ solver,\ int\ k\_dim)}
        {
(Optional) Set the maximum size of the Krylov space}
        {}
\label{cxx.6.10.6}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.6.10.7}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {6.10.1}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.6.10.8}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESSetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_PtrToParSolverFcn\ precond,\ HYPRE\_PtrToParSolverFcn\ precond\_setup,\ HYPRE\_Solver\ precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.6.10.9}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESGetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Solver\ *precond\_data)}
        {}
        {}
\label{cxx.6.10.10}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.6.10.11}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ print\_level)}
        {
(Optional) Set print level}
        {}
\label{cxx.6.10.12}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESGetNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.6.10.13}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESGetFinalRelativeResidualNorm}
        {(HYPRE\_Solver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.6.10.14}
\cxxitem{int\ }
        {HYPRE\_ParCSRFlexGMRESSetModifyPC}
        {(\ HYPRE\_Solver\ solver,\ HYPRE\_PtrToModifyPCFcn\ modify\_pc)}
        {
Set a user-defined function to modify solve-time preconditioner attributes}
        {}
\label{cxx.6.10.15}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRFlexGMRESSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {6.10.1}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default is 0). 
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance $\ast \|b\|$, absolute$\_$tolerance).)

\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR LGMRES Solver}
        {}
        {
}
        {6.11}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_Solver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.6.11.3}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESDestroy}
        {(HYPRE\_Solver\ solver)}
        {
Destroy a solver object}
        {}
\label{cxx.6.11.4}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {}
        {}
\label{cxx.6.11.5}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Solve the system}
        {6.11.1}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESSetKDim}
        {(HYPRE\_Solver\ solver,\ int\ k\_dim)}
        {
(Optional) Set the maximum size of the approximation space}
        {}
\label{cxx.6.11.6}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESSetAugDim}
        {(HYPRE\_Solver\ solver,\ int\ aug\_dim)}
        {
(Optional) Set the maximum number of augmentation vectors (default: 2)}
        {}
\label{cxx.6.11.7}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.6.11.8}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default: 0)}
        {6.11.2}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.6.11.9}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESSetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_PtrToParSolverFcn\ precond,\ HYPRE\_PtrToParSolverFcn\ precond\_setup,\ HYPRE\_Solver\ precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.6.11.10}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESGetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Solver\ *precond\_data)}
        {}
        {}
\label{cxx.6.11.11}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.6.11.12}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ print\_level)}
        {
(Optional) Set print level}
        {}
\label{cxx.6.11.13}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESGetNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.6.11.14}
\cxxitem{int\ }
        {HYPRE\_ParCSRLGMRESGetFinalRelativeResidualNorm}
        {(HYPRE\_Solver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.6.11.15}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRLGMRESSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Solve the system}
        {6.11.1}
\begin{cxxdoc}

Solve the system. Details on LGMRES may be found in A. H. Baker,
E.R. Jessup, and T.A. Manteuffel. A technique for accelerating the
convergence of restarted GMRES. SIAM Journal on Matrix Analysis and
Applications, 26 (2005), pp. 962-984. LGMRES(m,k) in the paper
corresponds to LGMRES(Kdim+AugDim, AugDim).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRLGMRESSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default: 0)}
        {6.11.2}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default: 0). 
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance $\ast \|b\|$, absolute$\_$tolerance).)

\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {ParCSR BiCGSTAB Solver}
        {}
        {
}
        {6.12}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABCreate}
        {(MPI\_Comm\ comm,\ HYPRE\_Solver\ *solver)}
        {
Create a solver object}
        {}
\label{cxx.6.12.6}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABDestroy}
        {(HYPRE\_Solver\ solver)}
        {
Destroy a solver object}
        {}
\label{cxx.6.12.7}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Set up BiCGSTAB solver}
        {}
\label{cxx.6.12.8}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_ParCSRMatrix\ A,\ HYPRE\_ParVector\ b,\ HYPRE\_ParVector\ x)}
        {
Solve the linear system}
        {}
\label{cxx.6.12.9}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance (default is 1}
        {6.12.1}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {6.12.2}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABSetMinIter}
        {(HYPRE\_Solver\ solver,\ int\ min\_iter)}
        {
(Optional) Set the minimal number of iterations (default: 0)}
        {}
\label{cxx.6.12.10}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ max\_iter)}
        {
(Optional) Set the maximal number of iterations allowed (default: 1000)}
        {}
\label{cxx.6.12.11}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABSetStopCrit}
        {(HYPRE\_Solver\ solver,\ int\ stop\_crit)}
        {
(Optional) If stop$\_$crit = 1, the absolute residual norm is used
for the stopping criterion}
        {6.12.3}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABSetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_PtrToParSolverFcn\ precond,\ HYPRE\_PtrToParSolverFcn\ precond\_setup,\ HYPRE\_Solver\ precond\_solver)}
        {
(Optional) Set the preconditioner}
        {}
\label{cxx.6.12.12}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABGetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Solver\ *precond\_data)}
        {
Get the preconditioner object}
        {}
\label{cxx.6.12.13}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to be done}
        {6.12.4}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ print\_level)}
        {
(Optional) Set the desired print level}
        {6.12.5}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABGetNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *num\_iterations)}
        {
Retrieve the number of iterations taken}
        {}
\label{cxx.6.12.14}
\cxxitem{int\ }
        {HYPRE\_ParCSRBiCGSTABGetFinalRelativeResidualNorm}
        {(HYPRE\_Solver\ solver,\ double\ *norm)}
        {
Retrieve the final relative residual norm}
        {}
\label{cxx.6.12.15}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRBiCGSTABSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance (default is 1}
        {6.12.1}
\begin{cxxdoc}

(Optional) Set the convergence tolerance (default is 1.e-6).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRBiCGSTABSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {6.12.2}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default is 0). 
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance $\ast \|b\|$, absolute$\_$tolerance).)

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRBiCGSTABSetStopCrit}
        {(HYPRE\_Solver\ solver,\ int\ stop\_crit)}
        {
(Optional) If stop$\_$crit = 1, the absolute residual norm is used
for the stopping criterion}
        {6.12.3}
\begin{cxxdoc}

(Optional) If stop$\_$crit = 1, the absolute residual norm is used
for the stopping criterion. The default is the relative residual
norm (stop$\_$crit = 0). Note: This function will be phased out in favor
of using HYPRE$\_$ParCSRBiCGSTABSetAbsoluteTol if an absolute stopping
criteria is desired.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRBiCGSTABSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to be done}
        {6.12.4}
\begin{cxxdoc}

(Optional) Set the amount of logging to be done. The default is 0, i.e.
no logging.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_ParCSRBiCGSTABSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ print\_level)}
        {
(Optional) Set the desired print level}
        {6.12.5}
\begin{cxxdoc}

(Optional) Set the desired print level. The default is 0, i.e. no printing.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{extern }
        {Krylov Solvers}
        {}
        {A basic interface for Krylov solvers}
        {7}
\begin{cxxnames}
\cxxitem{}
        {Krylov Solvers}
        {}
        {
}
        {7.1}
\cxxitem{}
        {PCG Solver}
        {}
        {
}
        {7.2}
\cxxitem{}
        {GMRES Solver}
        {}
        {
}
        {7.3}
\cxxitem{}
        {FlexGMRES Solver}
        {}
        {
}
        {7.4}
\cxxitem{}
        {BiCGSTAB Solver}
        {}
        {
}
        {7.5}
\cxxitem{}
        {LGMRES Solver}
        {}
        {
}
        {7.6}
\cxxitem{}
        {CGNR Solver}
        {}
        {
}
        {7.7}
\end{cxxnames}
\begin{cxxdoc}


These solvers support many of the matrix/vector storage schemes in hypre.
They should be used in conjunction with the storage-specific interfaces,
particularly the specific Create() and Destroy() functions.


\end{cxxdoc}
\begin{cxxentry}
{}
        {Krylov Solvers}
        {}
        {
}
        {7.1}
\begin{cxxnames}
\cxxitem{typedef\ struct\ \ \ hypre\_Solver\_struct*\ }
        {HYPRE\_Solver}
        {}
        {
The solver object}
        {}
\label{cxx.7.1.1}
\cxxitem{typedef\ struct\ \ \ hypre\_Matrix\_struct*\ }
        {HYPRE\_Matrix}
        {}
        {
The matrix object}
        {}
\label{cxx.7.1.2}
\cxxitem{typedef\ struct\ \ \ hypre\_Vector\_struct*\ }
        {HYPRE\_Vector}
        {}
        {
The vector object}
        {}
\label{cxx.7.1.3}
\end{cxxnames}
\end{cxxentry}
\begin{cxxentry}
{}
        {PCG Solver}
        {}
        {
}
        {7.2}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_PCGSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Prepare to solve the system}
        {7.2.1}
\cxxitem{int\ }
        {HYPRE\_PCGSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Solve the system}
        {}
\label{cxx.7.2.3}
\cxxitem{int\ }
        {HYPRE\_PCGSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the relative convergence tolerance}
        {}
\label{cxx.7.2.4}
\cxxitem{int\ }
        {HYPRE\_PCGSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is
0)}
        {7.2.2}
\cxxitem{int\ }
        {HYPRE\_PCGSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.7.2.5}
\cxxitem{int\ }
        {HYPRE\_PCGSetTwoNorm}
        {(HYPRE\_Solver\ solver,\ int\ two\_norm)}
        {
(Optional) Use the two-norm in stopping criteria}
        {}
\label{cxx.7.2.6}
\cxxitem{int\ }
        {HYPRE\_PCGSetRelChange}
        {(HYPRE\_Solver\ solver,\ int\ rel\_change)}
        {
(Optional) Additionally require that the relative difference in
successive iterates be small}
        {}
\label{cxx.7.2.7}
\cxxitem{int\ }
        {HYPRE\_PCGSetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_PtrToSolverFcn\ precond,\ HYPRE\_PtrToSolverFcn\ precond\_setup,\ HYPRE\_Solver\ precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.7.2.8}
\cxxitem{int\ }
        {HYPRE\_PCGSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.7.2.9}
\cxxitem{int\ }
        {HYPRE\_PCGSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.7.2.10}
\cxxitem{int\ }
        {HYPRE\_PCGGetNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.7.2.11}
\cxxitem{int\ }
        {HYPRE\_PCGGetFinalRelativeResidualNorm}
        {(HYPRE\_Solver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.7.2.12}
\cxxitem{int\ }
        {HYPRE\_PCGGetResidual}
        {(HYPRE\_Solver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.7.2.13}
\cxxitem{int\ }
        {HYPRE\_PCGGetTol}
        {(HYPRE\_Solver\ solver,\ double\ *tol)}
        {}
        {}
\label{cxx.7.2.14}
\cxxitem{int\ }
        {HYPRE\_PCGGetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ *max\_iter)}
        {}
        {}
\label{cxx.7.2.15}
\cxxitem{int\ }
        {HYPRE\_PCGGetTwoNorm}
        {(HYPRE\_Solver\ solver,\ int\ *two\_norm)}
        {}
        {}
\label{cxx.7.2.16}
\cxxitem{int\ }
        {HYPRE\_PCGGetRelChange}
        {(HYPRE\_Solver\ solver,\ int\ *rel\_change)}
        {}
        {}
\label{cxx.7.2.17}
\cxxitem{int\ }
        {HYPRE\_PCGGetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Solver\ *precond\_data\_ptr)}
        {}
        {}
\label{cxx.7.2.18}
\cxxitem{int\ }
        {HYPRE\_PCGGetLogging}
        {(HYPRE\_Solver\ solver,\ int\ *level)}
        {}
        {}
\label{cxx.7.2.19}
\cxxitem{int\ }
        {HYPRE\_PCGGetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ *level)}
        {}
        {}
\label{cxx.7.2.20}
\cxxitem{int\ }
        {HYPRE\_PCGGetConverged}
        {(HYPRE\_Solver\ solver,\ int\ *converged)}
        {}
        {}
\label{cxx.7.2.21}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_PCGSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Prepare to solve the system}
        {7.2.1}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_PCGSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is
0)}
        {7.2.2}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default is
0). If one desires the convergence test to check the absolute
convergence tolerance {\it only}, then set the relative convergence
tolerance to 0.0.  (The default convergence test is $ \<C*r,r\> \leq$
max(relative$\_$tolerance$^{2} \ast \<C*b, b\>$, absolute$\_$tolerance$^2$).)
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {GMRES Solver}
        {}
        {
}
        {7.3}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_GMRESSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Prepare to solve the system}
        {7.3.1}
\cxxitem{int\ }
        {HYPRE\_GMRESSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Solve the system}
        {}
\label{cxx.7.3.3}
\cxxitem{int\ }
        {HYPRE\_GMRESSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the relative convergence tolerance}
        {}
\label{cxx.7.3.4}
\cxxitem{int\ }
        {HYPRE\_GMRESSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {7.3.2}
\cxxitem{int\ }
        {HYPRE\_GMRESSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.7.3.5}
\cxxitem{int\ }
        {HYPRE\_GMRESSetKDim}
        {(HYPRE\_Solver\ solver,\ int\ k\_dim)}
        {
(Optional) Set the maximum size of the Krylov space}
        {}
\label{cxx.7.3.6}
\cxxitem{int\ }
        {HYPRE\_GMRESSetRelChange}
        {(HYPRE\_Solver\ solver,\ int\ rel\_change)}
        {
(Optional) Additionally require that the relative difference in
successive iterates be small}
        {}
\label{cxx.7.3.7}
\cxxitem{int\ }
        {HYPRE\_GMRESSetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_PtrToSolverFcn\ precond,\ HYPRE\_PtrToSolverFcn\ precond\_setup,\ HYPRE\_Solver\ precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.7.3.8}
\cxxitem{int\ }
        {HYPRE\_GMRESSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.7.3.9}
\cxxitem{int\ }
        {HYPRE\_GMRESSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.7.3.10}
\cxxitem{int\ }
        {HYPRE\_GMRESGetNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.7.3.11}
\cxxitem{int\ }
        {HYPRE\_GMRESGetFinalRelativeResidualNorm}
        {(HYPRE\_Solver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.7.3.12}
\cxxitem{int\ }
        {HYPRE\_GMRESGetResidual}
        {(HYPRE\_Solver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.7.3.13}
\cxxitem{int\ }
        {HYPRE\_GMRESGetTol}
        {(HYPRE\_Solver\ solver,\ double\ *tol)}
        {}
        {}
\label{cxx.7.3.14}
\cxxitem{int\ }
        {HYPRE\_GMRESGetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ *tol)}
        {}
        {}
\label{cxx.7.3.15}
\cxxitem{int\ }
        {HYPRE\_GMRESGetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ *max\_iter)}
        {}
        {}
\label{cxx.7.3.16}
\cxxitem{int\ }
        {HYPRE\_GMRESGetKDim}
        {(HYPRE\_Solver\ solver,\ int\ *k\_dim)}
        {}
        {}
\label{cxx.7.3.17}
\cxxitem{int\ }
        {HYPRE\_GMRESGetRelChange}
        {(HYPRE\_Solver\ solver,\ int\ *rel\_change)}
        {}
        {}
\label{cxx.7.3.18}
\cxxitem{int\ }
        {HYPRE\_GMRESGetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Solver\ *precond\_data\_ptr)}
        {}
        {}
\label{cxx.7.3.19}
\cxxitem{int\ }
        {HYPRE\_GMRESGetLogging}
        {(HYPRE\_Solver\ solver,\ int\ *level)}
        {}
        {}
\label{cxx.7.3.20}
\cxxitem{int\ }
        {HYPRE\_GMRESGetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ *level)}
        {}
        {}
\label{cxx.7.3.21}
\cxxitem{int\ }
        {HYPRE\_GMRESGetConverged}
        {(HYPRE\_Solver\ solver,\ int\ *converged)}
        {}
        {}
\label{cxx.7.3.22}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_GMRESSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Prepare to solve the system}
        {7.3.1}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_GMRESSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {7.3.2}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default is 0). 
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance$\ast \|b\|$, absolute$\_$tolerance).)

\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {FlexGMRES Solver}
        {}
        {
}
        {7.4}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Prepare to solve the system}
        {7.4.1}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Solve the system}
        {}
\label{cxx.7.4.3}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.7.4.4}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {7.4.2}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.7.4.5}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESSetKDim}
        {(HYPRE\_Solver\ solver,\ int\ k\_dim)}
        {
(Optional) Set the maximum size of the Krylov space}
        {}
\label{cxx.7.4.6}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESSetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_PtrToSolverFcn\ precond,\ HYPRE\_PtrToSolverFcn\ precond\_setup,\ HYPRE\_Solver\ precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.7.4.7}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.7.4.8}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.7.4.9}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESGetNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.7.4.10}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESGetFinalRelativeResidualNorm}
        {(HYPRE\_Solver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.7.4.11}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESGetResidual}
        {(HYPRE\_Solver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.7.4.12}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESGetTol}
        {(HYPRE\_Solver\ solver,\ double\ *tol)}
        {}
        {}
\label{cxx.7.4.13}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESGetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ *max\_iter)}
        {}
        {}
\label{cxx.7.4.14}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESGetKDim}
        {(HYPRE\_Solver\ solver,\ int\ *k\_dim)}
        {}
        {}
\label{cxx.7.4.15}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESGetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Solver\ *precond\_data\_ptr)}
        {}
        {}
\label{cxx.7.4.16}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESGetLogging}
        {(HYPRE\_Solver\ solver,\ int\ *level)}
        {}
        {}
\label{cxx.7.4.17}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESGetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ *level)}
        {}
        {}
\label{cxx.7.4.18}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESGetConverged}
        {(HYPRE\_Solver\ solver,\ int\ *converged)}
        {}
        {}
\label{cxx.7.4.19}
\cxxitem{int\ }
        {HYPRE\_FlexGMRESSetModifyPC}
        {(\ HYPRE\_Solver\ solver,\ HYPRE\_PtrToModifyPCFcn\ modify\_pc)}
        {
(Optional) Set a user-defined function to modify solve-time preconditioner
attributes}
        {}
\label{cxx.7.4.20}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_FlexGMRESSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Prepare to solve the system}
        {7.4.1}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_FlexGMRESSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {7.4.2}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default is 0). 
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance$\ast \|b\|$, absolute$\_$tolerance).)

\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {BiCGSTAB Solver}
        {}
        {
}
        {7.5}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_BiCGSTABSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Prepare to solve the system}
        {7.5.1}
\cxxitem{int\ }
        {HYPRE\_BiCGSTABSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Solve the system}
        {}
\label{cxx.7.5.3}
\cxxitem{int\ }
        {HYPRE\_BiCGSTABSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.7.5.4}
\cxxitem{int\ }
        {HYPRE\_BiCGSTABSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {7.5.2}
\cxxitem{int\ }
        {HYPRE\_BiCGSTABSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.7.5.5}
\cxxitem{int\ }
        {HYPRE\_BiCGSTABSetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_PtrToSolverFcn\ precond,\ HYPRE\_PtrToSolverFcn\ precond\_setup,\ HYPRE\_Solver\ precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.7.5.6}
\cxxitem{int\ }
        {HYPRE\_BiCGSTABSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.7.5.7}
\cxxitem{int\ }
        {HYPRE\_BiCGSTABSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.7.5.8}
\cxxitem{int\ }
        {HYPRE\_BiCGSTABGetNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.7.5.9}
\cxxitem{int\ }
        {HYPRE\_BiCGSTABGetFinalRelativeResidualNorm}
        {(HYPRE\_Solver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.7.5.10}
\cxxitem{int\ }
        {HYPRE\_BiCGSTABGetResidual}
        {(HYPRE\_Solver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.7.5.11}
\cxxitem{int\ }
        {HYPRE\_BiCGSTABGetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Solver\ *precond\_data\_ptr)}
        {}
        {}
\label{cxx.7.5.12}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BiCGSTABSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Prepare to solve the system}
        {7.5.1}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_BiCGSTABSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {7.5.2}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default is 0). 
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance $\ast \|b\|$, absolute$\_$tolerance).)

\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {LGMRES Solver}
        {}
        {
}
        {7.6}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_LGMRESSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Prepare to solve the system}
        {7.6.1}
\cxxitem{int\ }
        {HYPRE\_LGMRESSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Solve the system}
        {7.6.2}
\cxxitem{int\ }
        {HYPRE\_LGMRESSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.7.6.4}
\cxxitem{int\ }
        {HYPRE\_LGMRESSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {7.6.3}
\cxxitem{int\ }
        {HYPRE\_LGMRESSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.7.6.5}
\cxxitem{int\ }
        {HYPRE\_LGMRESSetKDim}
        {(HYPRE\_Solver\ solver,\ int\ k\_dim)}
        {
(Optional) Set the maximum size of the approximation space
(includes the augmentation vectors)}
        {}
\label{cxx.7.6.6}
\cxxitem{int\ }
        {HYPRE\_LGMRESSetAugDim}
        {(HYPRE\_Solver\ solver,\ int\ aug\_dim)}
        {
(Optional) Set the number of augmentation vectors  (default: 2)}
        {}
\label{cxx.7.6.7}
\cxxitem{int\ }
        {HYPRE\_LGMRESSetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_PtrToSolverFcn\ precond,\ HYPRE\_PtrToSolverFcn\ precond\_setup,\ HYPRE\_Solver\ precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.7.6.8}
\cxxitem{int\ }
        {HYPRE\_LGMRESSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.7.6.9}
\cxxitem{int\ }
        {HYPRE\_LGMRESSetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ level)}
        {
(Optional) Set the amount of printing to do to the screen}
        {}
\label{cxx.7.6.10}
\cxxitem{int\ }
        {HYPRE\_LGMRESGetNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.7.6.11}
\cxxitem{int\ }
        {HYPRE\_LGMRESGetFinalRelativeResidualNorm}
        {(HYPRE\_Solver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.7.6.12}
\cxxitem{int\ }
        {HYPRE\_LGMRESGetResidual}
        {(HYPRE\_Solver\ solver,\ void\ **residual)}
        {
Return the residual}
        {}
\label{cxx.7.6.13}
\cxxitem{int\ }
        {HYPRE\_LGMRESGetTol}
        {(HYPRE\_Solver\ solver,\ double\ *tol)}
        {}
        {}
\label{cxx.7.6.14}
\cxxitem{int\ }
        {HYPRE\_LGMRESGetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ *max\_iter)}
        {}
        {}
\label{cxx.7.6.15}
\cxxitem{int\ }
        {HYPRE\_LGMRESGetKDim}
        {(HYPRE\_Solver\ solver,\ int\ *k\_dim)}
        {}
        {}
\label{cxx.7.6.16}
\cxxitem{int\ }
        {HYPRE\_LGMRESGetAugDim}
        {(HYPRE\_Solver\ solver,\ int\ *k\_dim)}
        {}
        {}
\label{cxx.7.6.17}
\cxxitem{int\ }
        {HYPRE\_LGMRESGetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Solver\ *precond\_data\_ptr)}
        {}
        {}
\label{cxx.7.6.18}
\cxxitem{int\ }
        {HYPRE\_LGMRESGetLogging}
        {(HYPRE\_Solver\ solver,\ int\ *level)}
        {}
        {}
\label{cxx.7.6.19}
\cxxitem{int\ }
        {HYPRE\_LGMRESGetPrintLevel}
        {(HYPRE\_Solver\ solver,\ int\ *level)}
        {}
        {}
\label{cxx.7.6.20}
\cxxitem{int\ }
        {HYPRE\_LGMRESGetConverged}
        {(HYPRE\_Solver\ solver,\ int\ *converged)}
        {}
        {}
\label{cxx.7.6.21}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_LGMRESSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Prepare to solve the system}
        {7.6.1}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_LGMRESSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Solve the system}
        {7.6.2}
\begin{cxxdoc}

Solve the system. Details on LGMRES may be found in A. H. Baker,
E.R. Jessup, and T.A. Manteuffel, "A technique for accelerating the
convergence of restarted GMRES." SIAM Journal on Matrix Analysis and
Applications, 26 (2005), pp. 962-984. LGMRES(m,k) in the paper
corresponds to LGMRES(Kdim+AugDim, AugDim).
\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {HYPRE\_LGMRESSetAbsoluteTol}
        {(HYPRE\_Solver\ solver,\ double\ a\_tol)}
        {
(Optional) Set the absolute convergence tolerance (default is 0)}
        {7.6.3}
\begin{cxxdoc}

(Optional) Set the absolute convergence tolerance (default is 0). 
If one desires
the convergence test to check the absolute convergence tolerance {\it only}, then
set the relative convergence tolerance to 0.0.  (The convergence test is 
$\|r\| \leq$ max(relative$\_$tolerance$\ast \|b\|$, absolute$\_$tolerance).)

\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {CGNR Solver}
        {}
        {
}
        {7.7}
\begin{cxxnames}
\cxxitem{int\ }
        {HYPRE\_CGNRSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Prepare to solve the system}
        {7.7.1}
\cxxitem{int\ }
        {HYPRE\_CGNRSolve}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Solve the system}
        {}
\label{cxx.7.7.2}
\cxxitem{int\ }
        {HYPRE\_CGNRSetTol}
        {(HYPRE\_Solver\ solver,\ double\ tol)}
        {
(Optional) Set the convergence tolerance}
        {}
\label{cxx.7.7.3}
\cxxitem{int\ }
        {HYPRE\_CGNRSetMaxIter}
        {(HYPRE\_Solver\ solver,\ int\ max\_iter)}
        {
(Optional) Set maximum number of iterations}
        {}
\label{cxx.7.7.4}
\cxxitem{int\ }
        {HYPRE\_CGNRSetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_PtrToSolverFcn\ precond,\ HYPRE\_PtrToSolverFcn\ precondT,\ HYPRE\_PtrToSolverFcn\ precond\_setup,\ HYPRE\_Solver\ precond\_solver)}
        {
(Optional) Set the preconditioner to use}
        {}
\label{cxx.7.7.5}
\cxxitem{int\ }
        {HYPRE\_CGNRSetLogging}
        {(HYPRE\_Solver\ solver,\ int\ logging)}
        {
(Optional) Set the amount of logging to do}
        {}
\label{cxx.7.7.6}
\cxxitem{int\ }
        {HYPRE\_CGNRGetNumIterations}
        {(HYPRE\_Solver\ solver,\ int\ *num\_iterations)}
        {
Return the number of iterations taken}
        {}
\label{cxx.7.7.7}
\cxxitem{int\ }
        {HYPRE\_CGNRGetFinalRelativeResidualNorm}
        {(HYPRE\_Solver\ solver,\ double\ *norm)}
        {
Return the norm of the final relative residual}
        {}
\label{cxx.7.7.8}
\cxxitem{int\ }
        {HYPRE\_CGNRGetPrecond}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Solver\ *precond\_data\_ptr)}
        {}
        {}
\label{cxx.7.7.9}
\end{cxxnames}
\begin{cxxfunction}
{int\ }
        {HYPRE\_CGNRSetup}
        {(HYPRE\_Solver\ solver,\ HYPRE\_Matrix\ A,\ HYPRE\_Vector\ b,\ HYPRE\_Vector\ x)}
        {
Prepare to solve the system}
        {7.7.1}
\begin{cxxdoc}

Prepare to solve the system.  The coefficient data in {\tt b} and {\tt x} is
ignored here, but information about the layout of the data may be used.
\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\end{cxxentry}
\begin{cxxentry}
{}
        {Finite Element Interface}
        {}
        {A finite element-based conceptual interface}
        {8}
\begin{cxxnames}
\cxxitem{}
        {FEI Functions }
        {}
        {
}
        {8.1}
\cxxitem{}
        {FEI Solver Parameters}
        {}
        {
}
        {8.2}
\end{cxxnames}
\begin{cxxentry}
{}
        {FEI Functions }
        {}
        {
}
        {8.1}
\begin{cxxnames}
\cxxitem{}
        {LLNL\_FEI\_Impl}
        {(MPI\_Comm\ comm)}
        {
Finite element interface constructor: this function creates an
instantiation of the HYPRE fei class}
        {8.1.1}
\cxxitem{}
        {\cxxtilde LLNL\_FEI\_Impl}
        {()}
        {
Finite element interface destructor: this function destroys
the object as well as its internal memory allocations}
        {8.1.2}
\cxxitem{int\ }
        {parameters}
        {(int\ numParams,\ char\ **paramStrings)}
        {
The parameter function is the single most important function
to pass solver information (which solver, which preconditioner,
tolerance, other solver parameters) to HYPRE}
        {8.1.3}
\cxxitem{int\ }
        {initFields}
        {(int\ numFields,\ int\ *fieldSizes,\ int\ *fieldIDs)}
        {
Each node or element variable has one or more fields}
        {8.1.4}
\cxxitem{int\ }
        {initElemBlock}
        {(int\ elemBlockID,\ int\ numElements,\ int\ numNodesPerElement,\ int\ *numFieldsPerNode,\ int\ **nodalFieldIDs,\ int\ numElemDOFFieldsPerElement,\ int\ *elemDOFFieldIDs,\ int\ interleaveStrategy)}
        {
The whole finite element mesh can be broken down into a number of
element blocks}
        {8.1.5}
\cxxitem{int\ }
        {initElem}
        {(int\ elemBlockID,\ int\ elemID,\ int\ *elemConn)}
        {
This function initializes element connectivity (that is, the node
identifiers associated with the current element) given an element 
block identifier and the element identifier with the element block}
        {8.1.6}
\cxxitem{int\ }
        {initSharedNodes}
        {(int\ nShared,\ int\ *sharedIDs,\ int\ *sharedLengs,\ int\ **sharedProcs)}
        {
This function initializes the nodes that are shared between the
current processor and its neighbors}
        {8.1.7}
\cxxitem{int\ }
        {initCRMult}
        {(int\ CRListLen,\ int\ *CRNodeList,\ int\ *CRFieldList,\ int\ *CRID)}
        {
This function initializes the Lagrange multiplier constraints
}
        {8.1.8}
\cxxitem{int\ }
        {initComplete}
        {()}
        {
This function signals to the FEI that the initialization step has
been completed}
        {8.1.9}
\cxxitem{int\ }
        {resetSystem}
        {(double\ s)}
        {
This function resets the global matrix to be of the same sparsity
pattern as before but with every entry set to s}
        {8.1.10}
\cxxitem{int\ }
        {resetMatrix}
        {(double\ s)}
        {
This function resets the global matrix to be of the same sparsity
pattern as before but with every entry set to s}
        {8.1.11}
\cxxitem{int\ }
        {resetRHSVector}
        {(double\ s)}
        {
This function resets the right hand side vector to s}
        {8.1.12}
\cxxitem{int\ }
        {resetInitialGuess}
        {(double\ s)}
        {
This function resets the solution vector to s}
        {8.1.13}
\cxxitem{int\ }
        {loadNodeBCs}
        {(int\ nNodes,\ int\ *nodeIDs,\ int\ fieldID,\ double\ **alpha,\ double\ **beta,\ double\ **gamma)}
        {
This function loads the nodal boundary conditions}
        {8.1.14}
\cxxitem{int\ }
        {sumInElem}
        {(int\ elemBlockID,\ int\ elemID,\ int\ *elemConn,\ double\ **elemStiff,\ double\ *elemLoad,\ int\ elemFormat)}
        {
This function adds the element contribution to the global stiffness matrix
and also the element load to the right hand side vector
}
        {8.1.15}
\cxxitem{int\ }
        {sumInElemMatrix}
        {(int\ elemBlock,\ int\ elemID,\ int*\ elemConn,\ double\ **elemStiffness,\ int\ elemFormat)}
        {
This function differs from the sumInElem function in that the right hand
load vector is not passed}
        {8.1.16}
\cxxitem{int\ }
        {sumInElemRHS}
        {(int\ elemBlock,\ int\ elemID,\ int\ *elemConn,\ double\ *elemLoad)}
        {
This function adds the element load to the right hand side vector
}
        {8.1.17}
\cxxitem{int\ }
        {loadComplete}
        {()}
        {
This function signals to the FEI that the loading phase has
been completed}
        {8.1.18}
\cxxitem{int\ }
        {getNumBlockActNodes}
        {(int\ elemBlockID,\ int\ *nNodes)}
        {
This function returns the number of nodes given the element block}
        {8.1.19}
\cxxitem{int\ }
        {getNumBlockActEqns}
        {(int\ elemBlockID,\ int\ *nEqns)}
        {
This function returns the number of unknowns given the element block}
        {8.1.20}
\cxxitem{int\ }
        {getBlockNodeIDList}
        {(int\ elemBlockID,\ int\ numNodes,\ int\ *nodeIDList)}
        {
This function returns the node identifiers given the element block}
        {8.1.21}
\cxxitem{int\ }
        {getBlockNodeSolution}
        {(int\ elemBlockID,\ int\ numNodes,\ int\ *nodeIDList,\ int\ *solnOffsets,\ double\ *solnValues)}
        {
This function returns the nodal solutions given the element block number}
        {8.1.22}
\cxxitem{int\ }
        {loadCRMult}
        {(int\ CRID,\ int\ CRListLen,\ int\ *CRNodeList,\ int\ *CRFieldList,\ double\ *CRWeightList,\ double\ CRValue)}
        {
This function loads the Lagrange multiplier constraints
}
        {8.1.23}
\end{cxxnames}
\begin{cxxfunction}
{}
        {LLNL\_FEI\_Impl}
        {(MPI\_Comm\ comm)}
        {
Finite element interface constructor: this function creates an
instantiation of the HYPRE fei class}
        {8.1.1}
\cxxParameter{
{\tt\strut comm}\strut{} --- - an MPI communicator\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{}
        {\cxxtilde LLNL\_FEI\_Impl}
        {()}
        {
Finite element interface destructor: this function destroys
the object as well as its internal memory allocations}
        {8.1.2}
\cxxParameter{
{\tt\strut -}\strut{} --- no parameter needed\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {parameters}
        {(int\ numParams,\ char\ **paramStrings)}
        {
The parameter function is the single most important function
to pass solver information (which solver, which preconditioner,
tolerance, other solver parameters) to HYPRE}
        {8.1.3}
\cxxParameter{
{\tt\strut numParams}\strut{} --- - number of command strings
\\
{\tt\strut paramStrings}\strut{} --- - the command strings\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {initFields}
        {(int\ numFields,\ int\ *fieldSizes,\ int\ *fieldIDs)}
        {
Each node or element variable has one or more fields}
        {8.1.4}
\cxxParameter{
{\tt\strut numFields}\strut{} --- - total number of fields for all variable types 
\\
{\tt\strut fieldSizes}\strut{} --- - degree of freedom for each field type
\\
{\tt\strut fieldIDs}\strut{} --- - a list of field identifiers\strut}
\begin{cxxdoc}

Each node or element variable has one or more fields. The field
information can be set up using this function.

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {initElemBlock}
        {(int\ elemBlockID,\ int\ numElements,\ int\ numNodesPerElement,\ int\ *numFieldsPerNode,\ int\ **nodalFieldIDs,\ int\ numElemDOFFieldsPerElement,\ int\ *elemDOFFieldIDs,\ int\ interleaveStrategy)}
        {
The whole finite element mesh can be broken down into a number of
element blocks}
        {8.1.5}
\cxxParameter{
{\tt\strut elemblockID}\strut{} --- - element block identifier
\\
{\tt\strut numElements}\strut{} --- - number of element in this block 
\\
{\tt\strut numNodesPerElement}\strut{} --- - number of nodes per element in this block 
\\
{\tt\strut numFieldsPerNode}\strut{} --- - number of fields for each node 
\\
{\tt\strut nodalFieldIDs}\strut{} --- - field identifiers for the nodal unknowns
\\
{\tt\strut numElemDOFFieldsPerElement}\strut{} --- - number of fields for the element
\\
{\tt\strut elemDOFFieldIDs}\strut{} --- - field identifier for the element unknowns
\\
{\tt\strut interleaveStratety}\strut{} --- - indicates how unknowns are ordered\strut}
\begin{cxxdoc}

The whole finite element mesh can be broken down into a number of
element blocks. The attributes for each element block are: an
identifier, number of elements, number of nodes per elements, 
the number of fields in each element node, etc.

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {initElem}
        {(int\ elemBlockID,\ int\ elemID,\ int\ *elemConn)}
        {
This function initializes element connectivity (that is, the node
identifiers associated with the current element) given an element 
block identifier and the element identifier with the element block}
        {8.1.6}
\cxxParameter{
{\tt\strut elemblockID}\strut{} --- - element block identifier
\\
{\tt\strut elemID}\strut{} --- - element identifier
\\
{\tt\strut elemConn}\strut{} --- - a list of node identifiers for this element\strut}
\begin{cxxdoc}

This function initializes element connectivity (that is, the node
identifiers associated with the current element) given an element 
block identifier and the element identifier with the element block.  

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {initSharedNodes}
        {(int\ nShared,\ int\ *sharedIDs,\ int\ *sharedLengs,\ int\ **sharedProcs)}
        {
This function initializes the nodes that are shared between the
current processor and its neighbors}
        {8.1.7}
\cxxParameter{
{\tt\strut nShared}\strut{} --- - number of shared nodes
\\
{\tt\strut sharedIDs}\strut{} --- - shared node identifiers
\\
{\tt\strut sharedLengs}\strut{} --- - the number of processors each node shares with
\\
{\tt\strut sharedProcs}\strut{} --- - the processor identifiers each node shares with\strut}
\begin{cxxdoc}

This function initializes the nodes that are shared between the
current processor and its neighbors. The FEI will decide a unique
processor each shared node will be assigned to. 

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {initCRMult}
        {(int\ CRListLen,\ int\ *CRNodeList,\ int\ *CRFieldList,\ int\ *CRID)}
        {
This function initializes the Lagrange multiplier constraints
}
        {8.1.8}
\cxxParameter{
{\tt\strut CRListLen}\strut{} --- - the number of constraints
\\
{\tt\strut CRNodeList}\strut{} --- - node identifiers where constraints are applied
\\
{\tt\strut CRFieldList}\strut{} --- - field identifiers within nodes where constraints are applied
\\
{\tt\strut CRID}\strut{} --- - the constraint identifier\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {initComplete}
        {()}
        {
This function signals to the FEI that the initialization step has
been completed}
        {8.1.9}
\cxxParameter{
{\tt\strut -}\strut{} --- no parameter needed\strut}
\begin{cxxdoc}

This function signals to the FEI that the initialization step has
been completed. The loading step will follow.

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {resetSystem}
        {(double\ s)}
        {
This function resets the global matrix to be of the same sparsity
pattern as before but with every entry set to s}
        {8.1.10}
\cxxParameter{
{\tt\strut s}\strut{} --- - the value each matrix entry is set to.\strut}
\begin{cxxdoc}

This function resets the global matrix to be of the same sparsity
pattern as before but with every entry set to s. The right hand
side is set to 0.

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {resetMatrix}
        {(double\ s)}
        {
This function resets the global matrix to be of the same sparsity
pattern as before but with every entry set to s}
        {8.1.11}
\cxxParameter{
{\tt\strut s}\strut{} --- - the value each matrix entry is set to.\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {resetRHSVector}
        {(double\ s)}
        {
This function resets the right hand side vector to s}
        {8.1.12}
\cxxParameter{
{\tt\strut s}\strut{} --- - the value each right hand side vector entry is set to.\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {resetInitialGuess}
        {(double\ s)}
        {
This function resets the solution vector to s}
        {8.1.13}
\cxxParameter{
{\tt\strut s}\strut{} --- - the value each solution vector entry is set to.\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {loadNodeBCs}
        {(int\ nNodes,\ int\ *nodeIDs,\ int\ fieldID,\ double\ **alpha,\ double\ **beta,\ double\ **gamma)}
        {
This function loads the nodal boundary conditions}
        {8.1.14}
\cxxParameter{
{\tt\strut nNodes}\strut{} --- - number of nodes boundary conditions are imposed
\\
{\tt\strut nodeIDs}\strut{} --- - nodal identifiers
\\
{\tt\strut fieldID}\strut{} --- - field identifier with nodes where BC are imposed
\\
{\tt\strut alpha}\strut{} --- - the multipliers for the field
\\
{\tt\strut beta}\strut{} --- - the multipliers for the normal derivative of the field
\\
{\tt\strut gamma}\strut{} --- - the boundary values on the right hand side of the equations\strut}
\begin{cxxdoc}

This function loads the nodal boundary conditions. The boundary conditions

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {sumInElem}
        {(int\ elemBlockID,\ int\ elemID,\ int\ *elemConn,\ double\ **elemStiff,\ double\ *elemLoad,\ int\ elemFormat)}
        {
This function adds the element contribution to the global stiffness matrix
and also the element load to the right hand side vector
}
        {8.1.15}
\cxxParameter{
{\tt\strut elemBlockID}\strut{} --- - element block identifier
\\
{\tt\strut elemID}\strut{} --- - element identifier
\\
{\tt\strut elemConn}\strut{} --- - a list of node identifiers for this element
\\
{\tt\strut elemStiff}\strut{} --- - element stiffness matrix
\\
{\tt\strut elemLoad}\strut{} --- - right hand side (load) for this element
\\
{\tt\strut elemFormat}\strut{} --- - the format the unknowns are passed in\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {sumInElemMatrix}
        {(int\ elemBlock,\ int\ elemID,\ int*\ elemConn,\ double\ **elemStiffness,\ int\ elemFormat)}
        {
This function differs from the sumInElem function in that the right hand
load vector is not passed}
        {8.1.16}
\cxxParameter{
{\tt\strut elemBlockID}\strut{} --- - element block identifier
\\
{\tt\strut elemID}\strut{} --- - element identifier
\\
{\tt\strut elemConn}\strut{} --- - a list of node identifiers for this element
\\
{\tt\strut elemStiff}\strut{} --- - element stiffness matrix
\\
{\tt\strut elemFormat}\strut{} --- - the format the unknowns are passed in\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {sumInElemRHS}
        {(int\ elemBlock,\ int\ elemID,\ int\ *elemConn,\ double\ *elemLoad)}
        {
This function adds the element load to the right hand side vector
}
        {8.1.17}
\cxxParameter{
{\tt\strut elemBlockID}\strut{} --- - element block identifier
\\
{\tt\strut elemID}\strut{} --- - element identifier
\\
{\tt\strut elemConn}\strut{} --- - a list of node identifiers for this element
\\
{\tt\strut elemLoad}\strut{} --- - right hand side (load) for this element\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {loadComplete}
        {()}
        {
This function signals to the FEI that the loading phase has
been completed}
        {8.1.18}
\cxxParameter{
{\tt\strut -}\strut{} --- no parameter needed\strut}
\begin{cxxdoc}

This function signals to the FEI that the loading phase has
been completed. 

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {getNumBlockActNodes}
        {(int\ elemBlockID,\ int\ *nNodes)}
        {
This function returns the number of nodes given the element block}
        {8.1.19}
\cxxParameter{
{\tt\strut elemBlockID}\strut{} --- - element block identifier
\\
{\tt\strut nNodes}\strut{} --- - the number of nodes to be returned\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {getNumBlockActEqns}
        {(int\ elemBlockID,\ int\ *nEqns)}
        {
This function returns the number of unknowns given the element block}
        {8.1.20}
\cxxParameter{
{\tt\strut elemBlockID}\strut{} --- - element block identifier
\\
{\tt\strut nEqns}\strut{} --- - the number of unknowns to be returned\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {getBlockNodeIDList}
        {(int\ elemBlockID,\ int\ numNodes,\ int\ *nodeIDList)}
        {
This function returns the node identifiers given the element block}
        {8.1.21}
\cxxParameter{
{\tt\strut elemBlockID}\strut{} --- - element block identifier
\\
{\tt\strut numNodes}\strut{} --- - the number of nodes
\\
{\tt\strut nodeIDList}\strut{} --- - the node identifiers\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {getBlockNodeSolution}
        {(int\ elemBlockID,\ int\ numNodes,\ int\ *nodeIDList,\ int\ *solnOffsets,\ double\ *solnValues)}
        {
This function returns the nodal solutions given the element block number}
        {8.1.22}
\cxxParameter{
{\tt\strut elemBlockID}\strut{} --- - element block identifier
\\
{\tt\strut numNodes}\strut{} --- - the number of nodes
\\
{\tt\strut nodeIDList}\strut{} --- - the node identifiers
\\
{\tt\strut solnOffsets}\strut{} --- - the equation number for each nodal solution
\\
{\tt\strut solnValues}\strut{} --- - the nodal solution values\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\begin{cxxfunction}
{int\ }
        {loadCRMult}
        {(int\ CRID,\ int\ CRListLen,\ int\ *CRNodeList,\ int\ *CRFieldList,\ double\ *CRWeightList,\ double\ CRValue)}
        {
This function loads the Lagrange multiplier constraints
}
        {8.1.23}
\cxxParameter{
{\tt\strut CRID}\strut{} --- - the constraint identifier
\\
{\tt\strut CRListLen}\strut{} --- - the number of constraints
\\
{\tt\strut CRNodeList}\strut{} --- - node identifiers where constraints are applied
\\
{\tt\strut CRFieldList}\strut{} --- - field identifiers within nodes where constraints are applied
\\
{\tt\strut CRWeightList}\strut{} --- - a list of weights applied to each specified field
\\
{\tt\strut CRValue}\strut{} --- - the constraint value (right hand side of the constraint)\strut}
\begin{cxxdoc}

\end{cxxdoc}
\end{cxxfunction}
\end{cxxentry}
\begin{cxxentry}
{}
        {FEI Solver Parameters}
        {}
        {
}
        {8.2}
\begin{cxxnames}
\cxxitem{Preconditioners\ \ and\ }
        {Solvers}
        {}
        {
Here the various options for solvers and preconditioners
are defined}
        {8.2.1}
\cxxitem{}
        {BoomerAMG}
        {}
        {
Parameter options for the algebraic multigrid preconditioner BoomerAMG}
        {8.2.2}
\cxxitem{}
        {MLI}
        {}
        {
Parameter options for the smoothed aggregation preconditioner MLI}
        {8.2.3}
\cxxitem{}
        {Various}
        {}
        {
Parameter options for ILUT, ParaSails and polynomial preconditioners
are defined}
        {8.2.4}
\cxxitem{Matrix\ }
        {Reduction}
        {}
        {
Parameters which define different reduction modes}
        {8.2.5}
\cxxitem{Performance\ \ Tuning\ \ and\ }
        {Diagnostics}
        {}
        {
Parameters control diagnostic information, memory use, etc}
        {8.2.6}
\cxxitem{}
        {Miscellaneous}
        {}
        {
Parameters that are helpful for finite element information}
        {8.2.7}
\end{cxxnames}
\begin{cxxentry}
{Preconditioners\ \ and\ }
        {Solvers}
        {}
        {
Here the various options for solvers and preconditioners
are defined}
        {8.2.1}
\begin{cxxdoc}

Here the various options for solvers and preconditioners
are defined.

\begin{description}
\item[solver xxx] where xxx specifies one of {\sf cg}, {\sf gmres},
{\sf fgmres}, {\sf bicgs}, {\sf bicgstab}, {\sf tfqmr}, 
{\sf symqmr}, {\sf superlu}, or {\sf superlux}.  The 
default is {\sf gmres}.
The solver type can be followed by {\sf override} to
specify its priority when multiple solvers are declared
at random order.
\item[preconditioner xxx] where xxx is one of {\sf diagonal}, {\sf pilut},
{\sf euclid}, {\sf parasails}, {\sf boomeramg}, {\sf poly}, or 
{\sf mli}. The default is {\sf diagonal}.  Another option for 
xxx is {\sf reuse} which allows the preconditioner to be reused 
(this should only be set after a preconditioner has been set 
up already).
The preconditioner type can be followed by {\sf override} to
specify its priority when multiple preconditioners are declared
at random order.
\item[maxIterations xxx] where xxx is an integer specifying the maximum 
number of iterations permitted for the iterative solvers.
The default value is 1000.
\item[tolerance xxx] where xxx is a floating point number specifying the 
termination criterion for the iterative solvers.  The default 
value is 1.0E-6.
\item[gmresDim xxx] where xxx is an integer specifying the value of m in
restarted GMRES(m).  The default value is 100.
\item[stopCrit xxx] where xxx is one of {\sf absolute} or {\sf relative}
stopping criterion.
\item[superluOrdering xxx] - where xxx specifies one of {\sf natural} or
{\sf mmd} (minimum degree ordering).  This ordering
is used to minimize the number of nonzeros generated
in the LU decomposition.  The default is natural ordering.
\item[superluScale xxx] where xxx specifies one of {\sf y} (perform row
and column scalings before decomposition) or {\sf n}.
The default is no scaling.
\end{description}
\end{cxxdoc}
\end{cxxentry}
\begin{cxxentry}
{}
        {BoomerAMG}
        {}
        {
Parameter options for the algebraic multigrid preconditioner BoomerAMG}
        {8.2.2}
\begin{cxxdoc}

Parameter options for the algebraic multigrid preconditioner BoomerAMG.

\begin{description}
\item[amgMaxLevels xxx] where xxx is an integer specifying the maximum 
number of levels to be used for the grid hierarchy.
\item[amgCoarsenType xxx] where xxx specifies one of {\sf falgout} or
{\sf ruge}, or {\sf default (CLJP)} coarsening for BoomerAMG.
\item[amgMeasureType xxx] where xxx specifies one of {\sf local} or
or {\sf global}.  This parameter affects how coarsening is 
performed in parallel.
\item[amgRelaxType xxx] where xxx is one of {\sf jacobi} (Damped Jacobi),
{\sf gs-slow} (sequential Gauss-Seidel), {\sf gs-fast}
(Gauss-Seidel on interior nodes), or {\sf hybrid}.
The default is {\sf hybrid}.
\item[amgNumSweeps xxx] where xxx is an integer specifying the number of
pre- and post-smoothing at each level of BoomerAMG.
The default is two pre- and two post-smoothings.
\item[amgRelaxWeight xxx] where xxx is a floating point number between 
0 and 1 specifying the damping factor for BoomerAMG's damped
Jacobi and GS smoothers.  The default value is 1.0.
\item[amgRelaxOmega xxx] where xxx is a floating point number between 
0 and 1 specifying the damping factor for BoomerAMG's hybrid
smoother for multiple processors.  The default value is 1.0.
\item[amgStrongThreshold xxx] where xxx is a floating point number between 0 
and 1 specifying the threshold used to determine
strong coupling in BoomerAMG's coasening.  The default 
value is 0.25.
\item[amgSystemSize xxx] where xxx is the degree of freedom per node.
\item[amgMaxLevels xxx] where xxx is an integer specifying the maximum 
number of iterations to be used during the solve phase.
\item[amgUseGSMG] - tells BoomerAMG to use a different coarsening called 
GSMG.
\item[amgGSMGNumSamples] where xxx is the number of samples to generate
to determine how to coarsen for GSMG.
\end{description}
\end{cxxdoc}
\end{cxxentry}
\begin{cxxentry}
{}
        {MLI}
        {}
        {
Parameter options for the smoothed aggregation preconditioner MLI}
        {8.2.3}
\begin{cxxdoc}

Parameter options for the smoothed aggregation preconditioner MLI.

\begin{description}
\item[outputLevel xxx] where xxx is the output level for diagnostics.
\item[method xxx] where xxx is either {\sf AMGSA} (default), {\sf AMGSAe},
to indicate which MLI algorithm is to be used.
\item[numLevels xxx] where xxx is the maximum number of levels (default=30)
used.
\item[maxIterations xxx] where xxx is the maximum number of iterations
(default = 1 as preconditioner).
\item[cycleType xxx] where xxx is either 'V' or 'W' cycle (default = 'V').
\item[strengthThreshold xxx] strength threshold for coarsening (default = 0).
\item[smoother xxx] where xxx is either {\sf Jacobi}, {\sf BJacobi}, {\sf GS}, 
{\sf SGS}, {\sf HSGS} (SSOR,default), {\sf BSGS}, {\sf ParaSails}, 
{\sf MLS}, {\sf CGJacobi}, {\sf CGBJacobi}, or {\sf Chebyshev}.
\item[numSweeps xxx] where xxx is the number of smoother sweeps (default = 2).
\item[coarseSolver xxx] where xxx is one of those in 'smoother' or
{\sf SuperLU} (default).
\item[minCoarseSize xxx] where xxx is the minimum coarse grid size to
control the number of levels used (default = 3000).
\item[Pweight xxx] where xxx is the relaxation parameter for the prolongation
smoother (default 0.0).
\item[nodeDOF xxx] where xxx is the degree of freedom for each node
(default = 1).
\item[nullSpaceDim xxx] where xxx is the dimension of the null space for
the coarse grid (default = 1).
\item[useNodalCoord xxx] where xxx is either 'on' or 'off' (default)
to indicate whether the nodal coordinates are used to generate the 
initial null space.
\item[saAMGCalibrationSize xxx] where xxx is the additional null space 
vectors to be generated via calibration (default = 0).
\item[numSmoothVecs xxx] where xxx is the number of near null space 
vectors used to create the prolongation operator (default = 0).
\item[smoothVecSteps xxx] where xxx is the number of smoothing steps
used to generate the smooth vectors (default = 0).
\end{description}

In addition, to use 'AMGSAe', the parameter 'haveSFEI' has to be sent into
the FEI using the parameters function (this option is valid only for the
Sandia FEI implementation).
\end{cxxdoc}
\end{cxxentry}
\begin{cxxentry}
{}
        {Various}
        {}
        {
Parameter options for ILUT, ParaSails and polynomial preconditioners
are defined}
        {8.2.4}
\begin{cxxdoc}

Parameter options for ILUT, ParaSails and polynomial preconditioners
are defined.

\begin{description}
\item[euclidNlevels xxx] where xxx is an non-negative integer specifying 
the desired sparsity of the incomplete factors.  The
default value is 0.
\item[euclidThreshold xxx] where xxx is a floating point number specifying 
the threshold used to sparsify the incomplete factors.  The default
value is 0.0.
\item[parasailsThreshold xxx] where xxx is a floating point number between 0 
and 1 specifying the threshold used to prune small entries
in setting up the sparse approximate inverse.  The default
value is 0.0.
\item[parasailsNlevels xxx] where xxx is an integer larger than 0 specifying 
the desired sparsity of the approximate inverse.  The
default value is 1.
\item[parasailsFilter xxx] where xxx is a floating point number between 0 
and 1 specifying the threshold used to prune small entries
in $A$.  The default value is 0.0.
\item[parasailsLoadbal xxx] where xxx is a floating point number between 0 
and 1 specifying how load balancing has to be done 
(Edmond, explain please).  The default value is 0.0.
\item[parasailsSymmetric] sets Parasails to take $A$ as symmetric.
\item[parasailsUnSymmetric] sets Parasails to take $A$ as nonsymmetric
(default).
\item[parasailsReuse] sets Parasails to reuse the sparsity pattern of $A$.
\item[polyorder xxx] where xxx is the order of the least-squares polynomial 
preconditioner.
\end{description}
\end{cxxdoc}
\end{cxxentry}
\begin{cxxentry}
{Matrix\ }
        {Reduction}
        {}
        {
Parameters which define different reduction modes}
        {8.2.5}
\begin{cxxdoc}

Parameters which define different reduction modes.

\begin{description}
\item[schurReduction] turns on the Schur reduction mode.
\item[slideReduction] turns on the slide reduction mode.
\item[slideReduction2] turns on the slide reduction mode version 2 
(see section 2).
\item[slideReduction3] turns on the slide reduction mode version 3 
(see section 2).
\end{description}
\end{cxxdoc}
\end{cxxentry}
\begin{cxxentry}
{Performance\ \ Tuning\ \ and\ }
        {Diagnostics}
        {}
        {
Parameters control diagnostic information, memory use, etc}
        {8.2.6}
\begin{cxxdoc}

Parameters control diagnostic information, memory use, etc.

\begin{description}
\item[outputLevel xxx] where xxx is an integer specifying the output
level.  An output level of $1$ prints only the solver 
information such as number of iterations and timings.
An output level of $2$ prints debug information such as
the functions visited and preconditioner information.
An output level of $3$ or higher prints more debug information 
such as the matrix and right hand side loaded via the 
LinearSystemCore functions to the standard output.
\item[setDebug xxx] where xxx is one of {\sf slideReduction1}, 
{\sf slideReduction2},
{\sf slideReduction3} (level 1,2,3 diagnostics in the slide surface
reduction code), {\sf printMat} (print the original matrix
into a file), {\sf printReducedMat} (print the reduced matrix
into a file),  {\sf printSol} (print the solution into a file), 
{\sf ddilut} (output diagnostic information for DDIlut
preconditioner setup), and {\sf amgDebug} (output diagnostic 
information for AMG).
\item[optimizeMemory] cleans up the matrix sparsity pattern after the matrix
has been loaded. (It has been kept to allow matrix reuse.)
\item[imposeNoBC] turns off the boundary condition to allow diagnosing the
matrix (for example, checking the null space.)
\end{description}
\end{cxxdoc}
\end{cxxentry}
\begin{cxxvariable}
{}
        {Miscellaneous}
        {}
        {
Parameters that are helpful for finite element information}
        {8.2.7}
\begin{cxxdoc}

Parameters that are helpful for finite element information.

\begin{description}
\item[AConjugateProjection xxx] where xxx specifies the number of previous
solution vectors to keep for the A-conjugate projection. 
The default is 0 (the projection is off).
\item[minResProjection xxx] where xxx specifies the number of previous
solution vectors to keep for projection. 
The default is 0 (the projection is off).
\item[haveFEData] indicates that additional finite element information are 
available to assist in building more efficient solvers. 
\item[haveSFEI] indicates that the simplified finite element information are 
available to assist in building more efficient solvers. 
\end{description}
\end{cxxdoc}
\end{cxxvariable}
\end{cxxentry}
\end{cxxentry}
\begin{cxxClassGraph}
\label{cxx.}
\end{cxxClassGraph}
\end{document}
