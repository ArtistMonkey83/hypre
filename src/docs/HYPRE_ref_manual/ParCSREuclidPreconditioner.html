<html><head><TITLE>ParCSR Euclid Preconditioner </TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  ParCSR Euclid Preconditioner   </H2>
<hr>
<DL>
<DT>
<IMG BORDER=0 SRC=icon1.gif>int  <B>HYPRE_EuclidCreate</B>(MPI_Comm comm, <!2><A HREF="KrylovSolvers.2.html#DOC.7.1.1">HYPRE_Solver</A> *solver)
 <DD><I>
Create a Euclid object</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>int  <B>HYPRE_EuclidDestroy</B>(<!2><A HREF="KrylovSolvers.2.html#DOC.7.1.1">HYPRE_Solver</A> solver)
 <DD><I>
Destroy a Euclid object</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=HYPRE_EuclidSetup.html><B>HYPRE_EuclidSetup</B></A> 
 <DD><I>
Set up the Euclid preconditioner</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=HYPRE_EuclidSolve.html><B>HYPRE_EuclidSolve</B></A> 
 <DD><I>
Apply the Euclid preconditioner</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=HYPRE_EuclidSetParams.html><B>HYPRE_EuclidSetParams</B></A> 
 <DD><I>
Insert (name, value) pairs in Euclid's options database
by passing Euclid the command line (or an array of strings)</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=HYPRE_EuclidSetParamsFromFile.html><B>HYPRE_EuclidSetParamsFromFile</B></A> 
 <DD><I>
Insert (name, value) pairs in Euclid's options database</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>int  <B>HYPRE_EuclidSetLevel</B>(<!2><A HREF="KrylovSolvers.2.html#DOC.7.1.1">HYPRE_Solver</A> solver, int level)
 <DD><I>
Set level k for ILU(k) factorization, default: 1</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>int  <B>HYPRE_EuclidSetBJ</B>(<!2><A HREF="KrylovSolvers.2.html#DOC.7.1.1">HYPRE_Solver</A> solver, int bj)
 <DD><I>
Use block Jacobi ILU preconditioning instead of PILU</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>int  <B>HYPRE_EuclidSetStats</B>(<!2><A HREF="KrylovSolvers.2.html#DOC.7.1.1">HYPRE_Solver</A> solver, int eu_stats)
 <DD><I>
If eu_stats not equal 0, a summary of runtime settings and 
timing information is printed to stdout</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>int  <B>HYPRE_EuclidSetMem</B>(<!2><A HREF="KrylovSolvers.2.html#DOC.7.1.1">HYPRE_Solver</A> solver, int eu_mem)
 <DD><I>
If eu_mem not equal 0, a summary of Euclid's memory usage
is printed to stdout</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=HYPRE_EuclidSetSparseA.html><B>HYPRE_EuclidSetSparseA</B></A> 
 <DD><I>
Defines a drop tolerance for ILU(k)</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=HYPRE_EuclidSetRowScale.html><B>HYPRE_EuclidSetRowScale</B></A> 
 <DD><I>
If row_scale not equal 0, values are scaled prior to factorization
so that largest value in any row is +1 or -1</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>int  <B>HYPRE_EuclidSetILUT</B>(<!2><A HREF="KrylovSolvers.2.html#DOC.7.1.1">HYPRE_Solver</A> solver, double drop_tol)
 <DD><I>
uses ILUT and defines a drop tolerance relative to the largest
absolute value of any entry in the row being factored</I>
</DL>
<A NAME="DOC.DOCU">
<BLOCKQUOTE>
<P>MPI Parallel ILU preconditioner <P>Options summary:
<CENTER>
<TABLE BORDER>
<TR><TD>
</TD></TR><TR><TD>
Option </TD><TD> Default </TD><TD> Synopsis </TD></TR><TD>
</TD></TR><TR><TD>
-level    </TD><TD> 1 </TD><TD> ILU(<IMG BORDER=0 SRC=g000019.gif>) factorization level </TD></TR><TD> </TD></TR><TR><TD>
-bj       </TD><TD> 0 (false) </TD><TD> Use Block Jacobi ILU instead of PILU </TD></TR><TD> </TD></TR><TR><TD>
-eu_stats </TD><TD> 0 (false) </TD><TD> Print  internal timing and statistics </TD></TR><TD> </TD></TR><TR><TD>
-eu_mem   </TD><TD> 0 (false) </TD><TD> Print  internal memory usage </TD></TR><TD> </TD></TR><TR><TD>
</TR></TABLE>
</CENTER>

</BLOCKQUOTE>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<center>
<img src="hypre_wiw.gif">
</center>

<P Align=right><I>generated by <A HREF="http://www.zib.de/Visual/software/doc++/index.html">doc++</A></I>
</BODY>
